<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<!DOCTYPE event [<!ELEMENT zip_code (#PCDATA)><!ELEMENT url_link_display (#PCDATA)><!ELEMENT url (#PCDATA)><!ELEMENT tracks (track+)><!ELEMENT track (#PCDATA)><!ELEMENT title (#PCDATA)><!ELEMENT timeslot (slot_id?, title, room, date, start_time, end_time, description?, acm_doi?, persons?, tracks?, tags?)><!ELEMENT tags (tag+)><!ELEMENT tag (#PCDATA)><!ELEMENT suffix (#PCDATA)><!ELEMENT subevent_logo_url (#PCDATA)><!ELEMENT subevent_id (#PCDATA)><!ELEMENT subevent (subevent_id?, title, acronym?, subevent_type, description?, room, date, url?, url_link_display?, subevent_logo_url?, acm_doi?, persons?, tracks?, tags?, sponsor?, timeslot*)><!ELEMENT state (#PCDATA)><!ELEMENT start_time (#PCDATA)><!ELEMENT start_date (#PCDATA)><!ELEMENT sponsor (#PCDATA)><!ELEMENT sort_key (#PCDATA)><!ELEMENT slot_id (#PCDATA)><!ELEMENT subevent_type EMPTY><!ATTLIST subevent_type	type (case_study | demonstration | poster | regular | tutorial | workshop) #IMPLIED><!ELEMENT room (#PCDATA)><!ELEMENT role (#PCDATA)><!ELEMENT picture_url (#PCDATA)><!ELEMENT persons (person+)><!ELEMENT person (role, sort_key, first_name, middle_name?, last_name, suffix?, affiliation, acm_profile_id?, email?, bio?, homepage_url?, picture_url?)><!ELEMENT middle_name (#PCDATA)><!ELEMENT location (facility_name, facility_map_url?, address, city, state?, country, zip_code?)><!ELEMENT last_name (#PCDATA)><!ELEMENT homepage_url (#PCDATA)><!ELEMENT first_name (#PCDATA)><!ELEMENT facility_name (#PCDATA)><!ELEMENT facility_map_url (#PCDATA)><!ELEMENT event_type EMPTY><!ATTLIST event_type	type (conference|workshop|symposium) #IMPLIED><!ELEMENT event (event_details, subevent*, timeslot*)><!ELEMENT event_logo_url (#PCDATA)><!ELEMENT event_details (title, acronym, event_type, start_date, end_date, location, description, url?, url_link_display?, event_logo_url?, persons?)><!ELEMENT end_time (#PCDATA)><!ELEMENT end_date (#PCDATA)><!ELEMENT email (#PCDATA)><!ELEMENT description (#PCDATA)><!ELEMENT date (#PCDATA)><!ELEMENT country (#PCDATA)><!ELEMENT city (#PCDATA)><!ELEMENT bio (#PCDATA)><!ELEMENT affiliation (#PCDATA)><!ELEMENT address (#PCDATA)><!ELEMENT acronym (#PCDATA)><!ELEMENT acm_profile_id (#PCDATA)><!ELEMENT acm_doi (#PCDATA)>]>
<event>
  <event_details>
    <title>PLDI 2017</title>
    <acronym>PLDI 2017</acronym>
    <event_type type="conference"/>
    <start_date>2017/06/18</start_date>
    <end_date>2017/06/23</end_date>
    <location>
      <facility_name>Universitat Politècnica de Catalunya</facility_name>
      <address>Campus Nord, Carrer de Jordi Girona 1-3</address>
      <city>Barcelona</city>
      <country>Spain</country>
    </location>
    <description>Welcome to the website of the PLDI 2017 conference.
PLDI is the premier forum in the field of programming languages and programming systems research, covering the areas of design, implementation, theory, applications, and performance. The co-located conferences take place in Barcelona, June 18-23, 2017. 
Invited Speakers (joint with Curry On) 
 
 
  
  Mart&amp;iacute;n Abadi
  TensorFlow considered as a programming language
  
 
  
  Frank Wood
   Probabilistic Programming and Inference Compilation
  
 
  
  Martin Odersky
  What to leave implicit
  
 
 
 Student Travel Support Available 
SIGPLAN PAC may support travel, accommodation and registration for students who have a paper accepted at PLDI or co-located workshops. Hurry up to apply before May 1st! 
 
 Registration is now open! 
 PLDI registration gives you access to the Research Papers track and optionally to PLDI Workshops and Tutorials, LCTES, ISMM, ECOOP and DEBS. Visit the registration page for more details.  

PLDI welcomes outstanding research which clearly advances the field and has the potential to make a lasting contribution. 
Students can apply to volunteer at PLDI in exchange for free registration for the PLDI conference, workshops, panels and other co-located events. More info available at the student volunteers page.
PLDI will hold an ACM Student Research Competition and is now calling for submissions from undergraduate and graduate students. Submissions must include original, previously unpublished research. More info available at the PLDI SRC page.
SIGPLAN has opted to make access to published papers available for free via ACM OpenTOC. Accepted papers will be made available after the conference. 
 
 
  
  
 
  This year, PLDI is co-located with ECOOP, LCTES, DEBS, ISMM, Curry On and others. The conferences will take place at the Universitat Polyt&amp;egrave;cnica de Catalunya in Barcelona, Spain.</description>
    <url>http://pldi17.sigplan.org/home</url>
    <url_link_display>PLDI 2017</url_link_display>
    <persons>
      <person>
        <role>Chair in Steering Committee</role>
        <sort_key>1</sort_key>
        <first_name>Cormac</first_name>
        <last_name>Flanagan</last_name>
        <affiliation>University of California, Santa Cruz</affiliation>
        <bio>undefined</bio>
        <homepage_url>http://users.soe.ucsc.edu/~cormac/</homepage_url>
        <picture_url>http://pldi17.sigplan.org/getProfileImage/cormacflanagan/fd454a8e-4230-4fa5-a4da-1d16a1027de3/small.jpg</picture_url>
      </person>
      <person>
        <role>General Chair in Organizing Committee</role>
        <sort_key>2</sort_key>
        <first_name>Albert</first_name>
        <last_name>Cohen</last_name>
        <affiliation>INRIA</affiliation>
        <bio>undefined</bio>
        <homepage_url>https://who.rocq.inria.fr/Albert.Cohen</homepage_url>
        <picture_url>http://pldi17.sigplan.org/getProfileImage/albertcohen/274c10d0-dc94-46c6-bde3-4077f30e13d8/small.jpg</picture_url>
      </person>
      <person>
        <role>Co-chair in Artifact Evaluation Committee, Artifact Evaluation Co-Chair in Organizing Committee</role>
        <sort_key>3</sort_key>
        <first_name>Murali</first_name>
        <last_name>Krishna Ramanathan</last_name>
        <affiliation>Indian Institute of Science, Bangalore</affiliation>
        <bio>Murali Krishna Ramanathan is an Assistant Professor in the Department of Computer Science and Automation at Indian Institute of Science, Bangalore. Before IISc, he was a member of the core analysis team at Coverity Inc. building program analysis tools for bug detection in industrial codebases, with an emphasis on finding concurrency defects. He received his PhD in Computer Science from Purdue University.</bio>
        <homepage_url>http://www.csa.iisc.ernet.in/~muralikrishna</homepage_url>
        <picture_url>http://pldi17.sigplan.org/getProfileImage/muralikrishnaramanathan/52304999-046a-4d35-a2ed-9eb9ca2db709/small.jpg</picture_url>
      </person>
      <person>
        <role>Co-chair in Artifact Evaluation Committee, Committee Member in External Review Committee, Artifact Evaluation Co-Chair in Organizing Committee</role>
        <sort_key>4</sort_key>
        <first_name>Brandon</first_name>
        <last_name>Lucia</last_name>
        <affiliation>Carnegie Mellon University</affiliation>
        <bio>undefined</bio>
        <homepage_url>http://brandonlucia.com</homepage_url>
        <picture_url>http://pldi17.sigplan.org/getProfileImage/brandonlucia/16fdd4eb-8f38-4c24-b29c-fa7ed8a15fb8/small.jpg</picture_url>
      </person>
      <person>
        <role>Chair in SRC Panel, Student Research Competition Chair in Organizing Committee</role>
        <sort_key>5</sort_key>
        <first_name>Xavier</first_name>
        <last_name>Martorell</last_name>
        <affiliation>Barcelona Supercomputing Center</affiliation>
        <bio>undefined</bio>
        <homepage_url>https://www.bsc.es/martorell-bofill-xavier</homepage_url>
        <picture_url>http://pldi17.sigplan.org/getProfileImage/xaviermartorell/38524045-2209-4f5a-b3be-24927f76f4d7/small.jpg</picture_url>
      </person>
      <person>
        <role>Program Chair in Program Committee, Program Chair in Organizing Committee</role>
        <sort_key>6</sort_key>
        <first_name>Martin</first_name>
        <last_name>Vechev</last_name>
        <affiliation>DeepCode and ETH Zurich, Switzerland</affiliation>
        <bio>I am an Assistant Professor of Computer Science at ETH Zurich where I lead the Software Reliability Lab. Prior to ETH, I was a Research Staff Member at the IBM T.J. Watson Research Center in New York. I obtained my PhD from Cambridge University, England and my B.Sc. from Simon Fraser University. I am interested in program analysis, program synthesis, application of machine learning to programming languages, and concurrency.</bio>
        <homepage_url>http://www.srl.inf.ethz.ch/vechev.php</homepage_url>
        <picture_url>http://pldi17.sigplan.org/getProfileImage/martinvechev/1c8d199e-8f0e-435e-9b2c-506be67ed12c/small.jpg</picture_url>
      </person>
      <person>
        <role>Committee Member in Artifact Evaluation Committee</role>
        <sort_key>7</sort_key>
        <first_name>Aravind</first_name>
        <last_name>Acharya</last_name>
        <affiliation>Indian Institute of Science, Bangalore</affiliation>
        <bio>undefined</bio>
        <homepage_url>http://clweb.csa.iisc.ernet.in/aravind.acharya/</homepage_url>
      </person>
      <person>
        <role>Committee Member in External Review Committee</role>
        <sort_key>8</sort_key>
        <first_name>Sara</first_name>
        <last_name>Achour</last_name>
        <affiliation>MIT</affiliation>
        <bio>undefined</bio>
        <homepage_url>https://people.csail.mit.edu/sachour/</homepage_url>
        <picture_url>http://pldi17.sigplan.org/getProfileImage/saraachour/f1aad314-c255-4cc9-97cd-2243cac4dcf7/small.jpg</picture_url>
      </person>
      <person>
        <role>Committee Member in Program Committee</role>
        <sort_key>9</sort_key>
        <first_name>Eddie</first_name>
        <last_name>Aftandilian</last_name>
        <affiliation>Google</affiliation>
        <bio>I lead the Java Compiler Team at Google. A large part of our work focuses on lightweight static analysis to prevent bugs from entering Google’s Java codebase. We provide our bug detection tool, Error Prone (github.com/google/error-prone), as open source and as part of the Bazel (bazel.io) build system. Additionally, we provide tools that allow developers to refactor code at the scale of the whole Google codebase.</bio>
        <homepage_url>https://research.google.com/pubs/EdwardAftandilian.html</homepage_url>
        <picture_url>http://pldi17.sigplan.org/getProfileImage/eddieaftandilian/4ada699b-4281-4cb2-a5fe-0d8015ff5c5b/small.jpg</picture_url>
      </person>
      <person>
        <role>Committee Member in External Review Committee</role>
        <sort_key>10</sort_key>
        <first_name>Aws</first_name>
        <last_name>Albarghouthi</last_name>
        <affiliation>University of Wisconsin - Madison</affiliation>
        <bio>undefined</bio>
        <picture_url>http://pldi17.sigplan.org/getProfileImage/awsalbarghouthi/3a3382aa-47f5-4e02-ac71-509eb94703ff/small.jpg</picture_url>
      </person>
      <person>
        <role>Committee Member in External Review Committee</role>
        <sort_key>11</sort_key>
        <first_name>Nada</first_name>
        <last_name>Amin</last_name>
        <affiliation>EPFL</affiliation>
        <bio>undefined</bio>
        <homepage_url>http://namin.net</homepage_url>
        <picture_url>http://pldi17.sigplan.org/getProfileImage/nadaamin/b083e70b-31f9-4a88-89ba-ae54f8ec9315/small.jpg</picture_url>
      </person>
      <person>
        <role>Committee Member in Program Committee</role>
        <sort_key>12</sort_key>
        <first_name>David F.</first_name>
        <last_name>Bacon</last_name>
        <affiliation>Google</affiliation>
        <bio>undefined</bio>
        <picture_url>http://pldi17.sigplan.org/getProfileImage/davidfbacon/0fd9df29-594c-4341-bb5e-cb4bbf0edf5e/small.jpg</picture_url>
      </person>
      <person>
        <role>Committee Member in External Program Committee, Committee Member in Steering Committee</role>
        <sort_key>13</sort_key>
        <first_name>Emery</first_name>
        <last_name>Berger</last_name>
        <affiliation>University of Massachusetts, Amherst</affiliation>
        <bio>Emery Berger is a Professor in the School of Computer Science at the University of Massachusetts Amherst, the flagship campus of the UMass system. See his home page for more information.</bio>
        <homepage_url>http://www.cs.umass.edu/~emery/</homepage_url>
        <picture_url>http://pldi17.sigplan.org/getProfileImage/emeryberger/d4ec3e3a-5455-4f37-a497-42366bd39ce2/small.jpg</picture_url>
      </person>
      <person>
        <role>Committee Member in Steering Committee, Committee Member in External Review Committee</role>
        <sort_key>14</sort_key>
        <first_name>Steve</first_name>
        <last_name>Blackburn</last_name>
        <affiliation>Australian National University </affiliation>
        <bio>My research interests are centered on the challenge of making software run faster and more power-efficiently on modern hardware. My primary interests include: microarchitectural support for managed languages, fast and efficient garbage collection, and the design and implementation of virtual machines. As a backdrop to this I have a longstanding interest in role of sound methodology and infrastructure in successful research innovation.</bio>
        <homepage_url>http://users.cecs.anu.edu.au/~steveb/</homepage_url>
        <picture_url>http://pldi17.sigplan.org/getProfileImage/steveblackburn/1deee732-405d-4403-a974-a418751399c2/small.jpg</picture_url>
      </person>
      <person>
        <role>Committee Member in SRC Panel</role>
        <sort_key>15</sort_key>
        <first_name>Sandrine</first_name>
        <last_name>Blazy</last_name>
        <affiliation>University of Rennes 1, France</affiliation>
        <bio>I am professor in the computer science department of the University of Rennes 1, where I am in charge of the research master in computer science. I am a member of CELTIQUE, a joint project-team with Inria Rennes Bretagne Atlantique and the IRISA laboratory. 
My research activities concern the formal verification using the Coq proof assistant of program transformations and semantic properties of programming languages, such as those found in the CompCert compiler and the Verasco static analyzer. I teach mechanized semantics (in Coq), functional programming (in OCaml), formal methods (using the Why3 tool), and software vulnerabilities.</bio>
        <homepage_url>http://www.irisa.fr/celtique/blazy/</homepage_url>
        <picture_url>http://pldi17.sigplan.org/getProfileImage/sandrineblazy/bacd0031-1d22-476c-b6e5-fc58b1ab1177/small.jpg</picture_url>
      </person>
      <person>
        <role>Committee Member in Artifact Evaluation Committee</role>
        <sort_key>16</sort_key>
        <first_name>Ben</first_name>
        <last_name>Blum</last_name>
        <affiliation>Carnegie Mellon University</affiliation>
        <bio>undefined</bio>
      </person>
      <person>
        <role>Committee Member in External Program Committee</role>
        <sort_key>17</sort_key>
        <first_name>Hans-J.</first_name>
        <last_name>Boehm</last_name>
        <affiliation>Google</affiliation>
        <bio>undefined</bio>
        <homepage_url>http://hboehm.info</homepage_url>
        <picture_url>http://pldi17.sigplan.org/getProfileImage/hansjboehm/286e268e-cfa4-4ce4-8898-ad67c5292241/small.jpg</picture_url>
      </person>
      <person>
        <role>Committee Member in External Program Committee</role>
        <sort_key>18</sort_key>
        <first_name>Michael</first_name>
        <last_name>Bond</last_name>
        <affiliation>Ohio State University</affiliation>
        <bio>undefined</bio>
        <homepage_url>http://www.cse.ohio-state.edu/~mikebond</homepage_url>
        <picture_url>http://pldi17.sigplan.org/getProfileImage/michaelbond/92c528d2-84b3-4369-8b57-6555f1016a8e/small.jpg</picture_url>
      </person>
      <person>
        <role>Committee Member in Program Committee</role>
        <sort_key>19</sort_key>
        <first_name>Uday</first_name>
        <last_name>Bondhugula</last_name>
        <affiliation>Indian Institute of Science</affiliation>
        <bio>Uday Bondhugula is an Associate Professor in the department of Computer Science &amp;amp; Automation at the Indian Institute of Science (IISc), Bangalore, India. His research interests are in the design of new programming and compiler technologies for multicore architectures with an emphasis on high performance and automatic parallelization. Before joining IISc, he was with the Advanced Compiler Technologies group at the IBM T.J. Watson Research Center, Yorktown Heights, New York. He obtained his Ph.D. in Computer Science and Engineering from the Ohio State University, and his bachelor’s from the Indian Institute of Technology, Madras.</bio>
        <homepage_url>http://www.csa.iisc.ac.in/~uday</homepage_url>
        <picture_url>http://pldi17.sigplan.org/getProfileImage/udaybondhugula/7e41aaae-8d52-473a-ba39-d2d1161c8810/small.jpg</picture_url>
      </person>
      <person>
        <role>Committee Member in External Review Committee</role>
        <sort_key>20</sort_key>
        <first_name>James</first_name>
        <last_name>Bornholt</last_name>
        <affiliation>University of Washington</affiliation>
        <bio>I’m a computer science PhD student in the PLSE and Sampa groups at the University of Washington, advised by Emina Torlak, Dan Grossman, and Luis Ceze. I work on programming languages and formal methods, from program synthesis frameworks to consistency models.</bio>
        <homepage_url>https://homes.cs.washington.edu/~bornholt/</homepage_url>
        <picture_url>http://pldi17.sigplan.org/getProfileImage/jamesbornholt/3b627eda-8767-4bbc-b7f3-575ee248dc3e/small.jpg</picture_url>
      </person>
      <person>
        <role>Committee Member in External Program Committee</role>
        <sort_key>21</sort_key>
        <first_name>Ahmed</first_name>
        <last_name>Bouajjani</last_name>
        <affiliation>IRIF, Université Paris Diderot</affiliation>
        <bio>undefined</bio>
        <homepage_url>https://www.irif.univ-paris-diderot.fr/~abou/</homepage_url>
        <picture_url>http://pldi17.sigplan.org/getProfileImage/ahmedbouajjani/3337b070-be98-4f0a-8133-f5f0b630707f/small.jpg</picture_url>
      </person>
      <person>
        <role>Committee Member in SRC Panel</role>
        <sort_key>22</sort_key>
        <first_name>Timothy</first_name>
        <last_name>Bourke</last_name>
        <affiliation>INRIA</affiliation>
        <bio>undefined</bio>
        <homepage_url>http://www.tbrk.org</homepage_url>
        <picture_url>http://pldi17.sigplan.org/getProfileImage/timothybourke/747739f4-e5f1-4d96-957d-a9e98c1ba4f7/small.jpg</picture_url>
      </person>
      <person>
        <role>Committee Member in External Review Committee</role>
        <sort_key>23</sort_key>
        <first_name>Sebastian</first_name>
        <last_name>Burckhardt</last_name>
        <affiliation>Microsoft Research</affiliation>
        <bio>Sebastian Burckhardt was born and raised in Basel, Switzerland, where he studied Mathematics at the local University. During an exchange year at Brandeis University, he discovered his affinity to Computer Science and immigrated to the United States. After a few years of industry experience at IBM, he returned to academia and earned his PhD in Computer Science at the University of Pennsylvania. Since then, he has worked as a researcher at Microsoft Research in Redmond. His general research interest is the study of programming models for of concurrent, parallel, and distributed systems. More specific interests include consistency models, concurrency testing, self-adjusting computation, and the concurrent revisions programming model.</bio>
        <homepage_url>http://research.microsoft.com/en-us/people/sburckha/</homepage_url>
        <picture_url>http://pldi17.sigplan.org/getProfileImage/sebastianburckhardt/726ac702-681a-40f8-94d6-c0465e108867/small.jpg</picture_url>
      </person>
      <person>
        <role>Committee Member in External Review Committee</role>
        <sort_key>24</sort_key>
        <first_name>Michael</first_name>
        <last_name>Carbin</last_name>
        <affiliation>MIT</affiliation>
        <bio>Michael Carbin was a Ph.D. Candidate in Electrical Engineering and Computer Science at MIT. His interests include the design of programming systems that deliver improved performance and resilience by incorporating approximate computing and self-healing. I will be re-joining MIT in January 2016 as an Assistant Professor. In the interim, I will be working at Microsoft Research in Redmond.
His work on program analysis at Stanford University as an undergraduate received an award for Best Computer Science Undergraduate Honors Thesis. As a graduate student, he has received the MIT Lemelson Presidential and Microsoft Research Graduate Fellowships. His recent research on verifying the reliability of programs that execute on unreliable hardware received a best paper award at OOPSLA 2013.</bio>
        <homepage_url>http://people.csail.mit.edu/mcarbin/</homepage_url>
        <picture_url>http://pldi17.sigplan.org/getProfileImage/michaelcarbin/fd0efe40-41d3-4eaf-b227-c8fe1a9f6e96/small.jpg</picture_url>
      </person>
      <person>
        <role>Committee Member in External Review Committee</role>
        <sort_key>25</sort_key>
        <first_name>Aleksandar</first_name>
        <last_name>Chakarov</last_name>
        <affiliation>University of Colorado Boulder</affiliation>
        <bio>My name is Aleksandar Chakarov and I am a recent graduate from the Computer Science PhD Program at the University of Colorado Boulder working with Prof. Sriram Sankaranarayanan. I am a member of the CU Programming Languages and Verification (CUPLV) group and the Verification of Cyber Physical Systems group. My area of focus is the analysis and verification of probabilistic programs. I focus on adopting static analysis and invariant generation techniques to analyze probabilistic systems.</bio>
        <homepage_url>http://www.cs.colorado.edu/~chakarov/</homepage_url>
        <picture_url>http://pldi17.sigplan.org/getProfileImage/aleksandarchakarov/ea46e809-01dd-42eb-90d2-baf36ac02b91/small.jpg</picture_url>
      </person>
      <person>
        <role>Committee Member in Artifact Evaluation Committee</role>
        <sort_key>26</sort_key>
        <first_name>Van</first_name>
        <last_name>Chan Ngo</last_name>
        <affiliation>Carnegie Mellon University</affiliation>
        <bio>Chan received his Engineer degree from Hanoi University of Technology with excellent ranking, his Master degree in Computer Science (under a French government scholarship, Evariste Galois program) from Joseph Fourier University(University of Grenoble 1), and his Doctorate degree from Inria Rennes, France.</bio>
        <homepage_url>http://channgo2203.github.io</homepage_url>
        <picture_url>http://pldi17.sigplan.org/getProfileImage/vanchanngo/97bc8533-94be-4763-b1e0-35b9aa4ec184/small.jpg</picture_url>
      </person>
      <person>
        <role>Committee Member in Program Committee</role>
        <sort_key>27</sort_key>
        <first_name>Bor-Yuh Evan</first_name>
        <last_name>Chang</last_name>
        <affiliation>University of Colorado Boulder</affiliation>
        <bio>undefined</bio>
        <homepage_url>http://www.cs.colorado.edu/~bec/</homepage_url>
        <picture_url>http://pldi17.sigplan.org/getProfileImage/boryuhevanchang/0cbe7e94-aaf8-458b-9670-3892350bc209/small.jpg</picture_url>
      </person>
      <person>
        <role>Committee Member in Program Committee</role>
        <sort_key>28</sort_key>
        <first_name>Swarat</first_name>
        <last_name>Chaudhuri</last_name>
        <affiliation>Rice University</affiliation>
        <bio>Swarat Chaudhuri is an assistant professor of computer science at Rice University. He is an expert on methods for automated reasoning about systems, in particular abstract interpretation and model checking, and the application of such methods in computer-aided programming.
Swarat received a bachelor’s degree in computer science from the Indian Institute of Technology, Kharagpur, in 2001, and a doctoral degree in computer science from the University of Pennsylvania in 2007. From 2008-2011, he was an assistant professor at the Pennsylvania State University, University Park. He is a recipient of the National Science Foundation CAREER award, the ACM SIGPLAN Outstanding Doctoral Dissertation Award, and the Morris and Dorothy Rubinoff Dissertation Award from the University of Pennsylvania.</bio>
        <homepage_url>http://www.cs.rice.edu/~sc40/</homepage_url>
        <picture_url>http://pldi17.sigplan.org/getProfileImage/swaratchaudhuri/380a995e-c23e-4571-9f61-4f948b82c975/small.jpg</picture_url>
      </person>
      <person>
        <role>Committee Member in Program Committee</role>
        <sort_key>29</sort_key>
        <first_name>Alvin</first_name>
        <last_name>Cheung</last_name>
        <affiliation>University of Washington</affiliation>
        <bio>undefined</bio>
        <homepage_url>http://homes.cs.washington.edu/~akcheung</homepage_url>
        <picture_url>http://pldi17.sigplan.org/getProfileImage/alvincheung/8a51cd19-a395-45c9-8b2c-b121ff910c62/small.jpg</picture_url>
      </person>
      <person>
        <role>Committee Member in External Review Committee</role>
        <sort_key>30</sort_key>
        <first_name>Adam</first_name>
        <last_name>Chlipala</last_name>
        <affiliation>MIT</affiliation>
        <bio>undefined</bio>
        <homepage_url>http://adam.chlipala.net/</homepage_url>
        <picture_url>http://pldi17.sigplan.org/getProfileImage/adamchlipala/def72d03-2975-4c5a-a726-e8a944b77dc9/small.jpg</picture_url>
      </person>
      <person>
        <role>Committee Member in External Review Committee</role>
        <sort_key>31</sort_key>
        <first_name>Maria</first_name>
        <last_name>Christakis</last_name>
        <affiliation> University of Kent</affiliation>
        <bio>undefined</bio>
        <homepage_url>https://mariachris.github.io/</homepage_url>
        <picture_url>http://pldi17.sigplan.org/getProfileImage/mariachristakis/b7bf39cc-368b-44aa-bbcb-c83734e1e8fa/small.jpg</picture_url>
      </person>
      <person>
        <role>Committee Member in Artifact Evaluation Committee</role>
        <sort_key>32</sort_key>
        <first_name>Shumo</first_name>
        <last_name>Chu</last_name>
        <affiliation>University of Washington, USA</affiliation>
        <bio>Shumo is a 4th year PhD student at Computer Science &amp;amp; Engineering, University of Washington. He interests in applying formal methods to data management and building data systems in a principled way.</bio>
        <homepage_url>http://shumochu.com/</homepage_url>
        <picture_url>http://pldi17.sigplan.org/getProfileImage/shumochu/da171030-a629-449a-951a-08ea17d308f2/small.jpg</picture_url>
      </person>
      <person>
        <role>Committee Member in Program Committee</role>
        <sort_key>33</sort_key>
        <first_name>Ravi</first_name>
        <last_name>Chugh</last_name>
        <affiliation>University of Chicago</affiliation>
        <bio>I am an Assistant Professor at the University of Chicago. I enjoy developing and deploying programming language technology — type systems, synthesis algorithms, and other program analysis techniques — for applications in software engineering and human-computer interaction.</bio>
        <homepage_url>http://people.cs.uchicago.edu/~rchugh</homepage_url>
        <picture_url>http://pldi17.sigplan.org/getProfileImage/ravichugh/ea931b20-b1e1-4e07-b209-ba0b568e315d/small.jpg</picture_url>
      </person>
      <person>
        <role>Committee Member in Artifact Evaluation Committee</role>
        <sort_key>34</sort_key>
        <first_name>Alexei</first_name>
        <last_name>Colin</last_name>
        <affiliation>Carnegie Mellon University</affiliation>
        <bio>undefined</bio>
      </person>
      <person>
        <role>Committee Member in External Review Committee</role>
        <sort_key>35</sort_key>
        <first_name>Eva</first_name>
        <last_name>Darulova</last_name>
        <affiliation>MPI-SWS</affiliation>
        <bio>undefined</bio>
        <homepage_url>http://mpi-sws.org/~eva/</homepage_url>
        <picture_url>http://pldi17.sigplan.org/getProfileImage/evadarulova/0d98744b-ec94-4a27-b1c0-0d728d54bdb7/small.jpg</picture_url>
      </person>
      <person>
        <role>Committee Member in Program Committee</role>
        <sort_key>36</sort_key>
        <first_name>Joseph</first_name>
        <last_name>Devietti</last_name>
        <affiliation>University of Pennsylvania</affiliation>
        <bio>undefined</bio>
        <homepage_url>http://cis.upenn.edu/~devietti/</homepage_url>
        <picture_url>http://pldi17.sigplan.org/getProfileImage/josephdevietti/62850451-b71a-48b2-8b1b-fad646d36052/small.jpg</picture_url>
      </person>
      <person>
        <role>Committee Member in External Review Committee</role>
        <sort_key>37</sort_key>
        <first_name>Alastair</first_name>
        <last_name>Donaldson</last_name>
        <affiliation>Imperial College London</affiliation>
        <bio>Alastair F. Donaldson is a Senior Lecturer in the Department of Computing at Imperial College London, where he leads the Multicore Programming Group. Prior to joining Imperial, he was a Visting Researcher at Microsoft Research Redmond, a Postdoctoral Research Fellow at the University of Oxford, a Research Engineer at Codeplay Software Ltd., and a PhD student at the University of Glasgow.</bio>
        <homepage_url>http://www.doc.ic.ac.uk/~afd</homepage_url>
        <picture_url>http://pldi17.sigplan.org/getProfileImage/alastairdonaldson/55258969-e1da-48a3-b9b2-8c02297874f0/small.jpg</picture_url>
      </person>
      <person>
        <role>Committee Member in External Review Committee</role>
        <sort_key>38</sort_key>
        <first_name>Dana</first_name>
        <last_name>Drachsler Cohen</last_name>
        <affiliation>Technion</affiliation>
        <bio>undefined</bio>
        <homepage_url>http://ddana.cswp.cs.technion.ac.il/</homepage_url>
        <picture_url>http://pldi17.sigplan.org/getProfileImage/danadrachslercohen/1fe533c9-8cf4-478b-beb8-c8a3408fa227/small.jpg</picture_url>
      </person>
      <person>
        <role>Committee Member in Program Committee</role>
        <sort_key>39</sort_key>
        <first_name>Cezara</first_name>
        <last_name>Drăgoi</last_name>
        <affiliation>INRIA, ENS, CNRS</affiliation>
        <bio>undefined</bio>
        <homepage_url>http://www.di.ens.fr/~cezarad/</homepage_url>
        <picture_url>http://pldi17.sigplan.org/getProfileImage/cezaradragoi/3403e4d3-23e5-41ac-8cf7-48cc033f3d48/small.jpg</picture_url>
      </person>
      <person>
        <role>Committee Member in External Review Committee</role>
        <sort_key>40</sort_key>
        <first_name>John</first_name>
        <last_name>Field</last_name>
        <affiliation>Google</affiliation>
        <bio>undefined</bio>
        <homepage_url>https://research.google.com/pubs/JohnField.html</homepage_url>
        <picture_url>http://pldi17.sigplan.org/getProfileImage/johnfield/75b1c657-e437-4d0d-95a4-62b4419963f5/small.jpg</picture_url>
      </person>
      <person>
        <role>Committee Member in External Review Committee</role>
        <sort_key>41</sort_key>
        <first_name>Bryan</first_name>
        <last_name>Ford</last_name>
        <affiliation>Swiss Federal Institute of Technology Lausanne (EPFL), Switzerland</affiliation>
        <bio>Prof. Bryan Ford leads the Decentralized/Distributed Systems (DEDIS) lab at the Swiss Federal Institute of Technology in Lausanne (EPFL). Ford focuses broadly on building secure decentralized systems, touching on topics including private and anonymous communication technologies, Internet architecture, and secure operating systems. He received the Jay Lepreau Best Paper Award at OSDI, and grants from NSF, DARPA, and ONR, including the NSF CAREER award. His pedagogical achievements include PIOS, the first OS course leading students through the development of a working, native multiprocessor OS kernel. Ford earned his B.S. at the University of Utah and his Ph.D. at MIT, then joined the faculty of Yale University in 2009 before moving to EPFL in 2015.</bio>
        <homepage_url>http://bford.info/</homepage_url>
        <picture_url>http://pldi17.sigplan.org/getProfileImage/bryanford/f049d471-41d0-4909-99f5-228487fbfa7f/small.jpg</picture_url>
      </person>
      <person>
        <role>Committee Member in External Program Committee</role>
        <sort_key>42</sort_key>
        <first_name>Nate</first_name>
        <last_name>Foster</last_name>
        <affiliation>Cornell University</affiliation>
        <bio>Nate Foster is an Associate Professor of Computer Science at Cornell University. The goal of his research is to develop languages and tools that make it easy for programmers to build secure and reliable systems. His current work focuses on the design and implementation of languages for programming software-defined networks. In the past he has also worked on bidirectional languages (also known as “lenses”), database query languages, data provenance, type systems, mechanized proof, and formal semantics. He received a PhD in Computer Science from the University of Pennsylvania, an MPhil in History and Philosophy of Science from Cambridge University, and a BA in Computer Science from Williams College. His awards include a Sloan Research Fellowship, an NSF CAREER Award, a Most Influential POPL Paper Award, a Tien ’72 Teaching Award, a Google Research Award, a Yahoo! Academic Career Enhancement Award, a Cornell Engineering Research Excellence Award, and the Morris and Dorothy Rubinoff Award.</bio>
        <homepage_url>http://www.cs.cornell.edu/~jnfoster/</homepage_url>
        <picture_url>http://pldi17.sigplan.org/getProfileImage/natefoster/fc11e437-6a66-45e4-b6a3-c4b879fa2e7c/small.jpg</picture_url>
      </person>
      <person>
        <role>Committee Member in Program Committee</role>
        <sort_key>43</sort_key>
        <first_name>Jeffrey S.</first_name>
        <last_name>Foster</last_name>
        <affiliation>University of Maryland, College Park</affiliation>
        <bio>undefined</bio>
        <homepage_url>http://www.cs.umd.edu/~jfoster</homepage_url>
        <picture_url>http://pldi17.sigplan.org/getProfileImage/jeffreysfoster/b22ce952-32b0-48bd-be56-12fd87bf3469/small.jpg</picture_url>
      </person>
      <person>
        <role>Committee Member in Program Committee</role>
        <sort_key>44</sort_key>
        <first_name>Franz</first_name>
        <last_name>Franchetti</last_name>
        <affiliation>Carnegie Mellon University</affiliation>
        <bio>undefined</bio>
        <picture_url>http://pldi17.sigplan.org/getProfileImage/franzfranchetti/f3e86e2a-9467-4f82-8de9-563cbf1d0244/small.jpg</picture_url>
      </person>
      <person>
        <role>Committee Member in External Program Committee</role>
        <sort_key>45</sort_key>
        <first_name>Stephen</first_name>
        <last_name>Freund</last_name>
        <affiliation>Williams College</affiliation>
        <bio>undefined</bio>
        <picture_url>http://pldi17.sigplan.org/getProfileImage/stephenfreund/0b468f46-1f87-41c4-bcff-4321da9869c2/small.jpg</picture_url>
      </person>
      <person>
        <role>Committee Member in Artifact Evaluation Committee</role>
        <sort_key>46</sort_key>
        <first_name>Zhoulai</first_name>
        <last_name>Fu</last_name>
        <affiliation>University of California, Davis</affiliation>
        <bio>undefined</bio>
      </person>
      <person>
        <role>Committee Member in External Review Committee</role>
        <sort_key>47</sort_key>
        <first_name>Vijay</first_name>
        <last_name>Ganesh</last_name>
        <affiliation>University of Waterloo</affiliation>
        <bio>Dr. Vijay Ganesh is an assistant professor at the University of Waterloo since 2012. Prior to that he was a research scientist at MIT, and completed his PhD in computer science from Stanford University in 2007.
Vijay’s primary area of research is the theory and practice of automated reasoning aimed at software engineering, formal methods, security, and mathematics. In this context he has led the development of many SAT/SMT solvers, most notably, STP, The Z3 string solver, MapleSAT, and MathCheck. He has also proved several decidability and complexity results in the context of theories over string equations and integers. For his research, he recently won the Early Researcher Award (ERA) in 2016, an IBM Research Faculty Award in 2015, Google Research Faculty Awards in 2013 and 2011, and 7 best paper awards/honors at conferences like CAV, IJCAI, CADE, ISSTA, SAT, SPLC, and DATE (including a Ten-Year Most Influential Award @ DATE 2008). His solvers STP and MapleSAT have won numerous awards at the highly competitive international SMT and SAT solver competitions. Recently he was invited to the first Heidelberg Laureate Forum in 2013, a gathering where young researchers from around the world were selected to meet with Turing, Fields and Abel Laureates.</bio>
        <homepage_url>https://ece.uwaterloo.ca/~vganesh/</homepage_url>
        <picture_url>http://pldi17.sigplan.org/getProfileImage/vijayganesh/565e228f-32a4-4ce0-bf4a-e552db032e18/small.jpg</picture_url>
      </person>
      <person>
        <role>Committee Member in Steering Committee</role>
        <sort_key>48</sort_key>
        <first_name>Jeremy</first_name>
        <last_name>Gibbons</last_name>
        <affiliation>Department of Computer Science, University of Oxford</affiliation>
        <bio>I am Professor of Computing in the Department of Computer Science at the University of Oxford. I am currently Director of the Software Engineering Programme, which offers part-time professional Masters’ degrees in Software Engineering and in Software and Systems Security. I also lead the Algebra of Programming research group. I am Editor-in-Chief of the Journal of Functional Programming, Past Vice Chair of ACM SIGPLAN, Past Chair of IFIP WG2.1. Before taking up this post in 1999, I held lectureships at Oxford Brookes University and the University of Auckland, New Zealand.</bio>
        <homepage_url>http://www.cs.ox.ac.uk/jeremy.gibbons/</homepage_url>
        <picture_url>http://pldi17.sigplan.org/getProfileImage/jeremygibbons/17403e55-a926-41cf-ae21-08abecea187c/small.jpg</picture_url>
      </person>
      <person>
        <role>Committee Member in SRC Panel</role>
        <sort_key>49</sort_key>
        <first_name>Laure</first_name>
        <last_name>Gonnord</last_name>
        <affiliation>University of Lyon &amp; LIP, France</affiliation>
        <bio>Laure Gonnord received her PhD degree in computer science from the University Joseph Fourier (Grenoble, France), in 2007. She currently holds an assistant professor position at University Lyon I/UCBL, France. Her main research interests lie in the design of static analyses, with emphasis on the automatic synthesis of numerical invariants and application in compilation (scheduling) and termination proofs. She belongs to the ROMA team of the LIP laboratory (ENS Lyon).</bio>
        <homepage_url>http://laure.gonnord.org/pro</homepage_url>
        <picture_url>http://pldi17.sigplan.org/getProfileImage/lauregonnord/6b741986-7933-4cba-9205-8e5e8451d8fa/small.jpg</picture_url>
      </person>
      <person>
        <role>Committee Member in External Review Committee</role>
        <sort_key>50</sort_key>
        <first_name>Alexey</first_name>
        <last_name>Gotsman</last_name>
        <affiliation>IMDEA</affiliation>
        <bio>undefined</bio>
        <homepage_url>http://software.imdea.org/~gotsman/</homepage_url>
        <picture_url>http://pldi17.sigplan.org/getProfileImage/alexeygotsman/0e51eef0-a1e5-4159-a063-07cd098bf983/small.jpg</picture_url>
      </person>
      <person>
        <role>Committee Member in SRC Panel, Publicity Chair in Organizing Committee</role>
        <sort_key>51</sort_key>
        <first_name>Tobias</first_name>
        <last_name>Grosser</last_name>
        <affiliation>ETH Zurich</affiliation>
        <bio>undefined</bio>
        <homepage_url>https://www.grosser.es</homepage_url>
        <picture_url>http://pldi17.sigplan.org/getProfileImage/tobiasgrosser/1ee43044-14e9-497e-a230-90f96a8da867/small.jpg</picture_url>
      </person>
      <person>
        <role>Committee Member in Program Committee</role>
        <sort_key>52</sort_key>
        <first_name>Dan</first_name>
        <last_name>Grossman</last_name>
        <affiliation>University of Washington</affiliation>
        <bio>undefined</bio>
        <homepage_url>http://homes.cs.washington.edu/~djg/</homepage_url>
        <picture_url>http://pldi17.sigplan.org/getProfileImage/dangrossman/941e0321-e962-4f03-9027-ba9f0448e7df/small.jpg</picture_url>
      </person>
      <person>
        <role>Committee Member in Steering Committee</role>
        <sort_key>53</sort_key>
        <first_name>David</first_name>
        <last_name>Grove</last_name>
        <affiliation>IBM Research</affiliation>
        <bio>I am a Principal Research Staff Member in the Programming Technologies Department at the IBM T.J. Watson Research Center. I joined IBM Research in 1998 after completing my PhD at the University of Washington.
I am interested in a wide variety of topics in programming language design and implementation including the analysis and optimization of object-oriented languages, virtual machine design and implementation, scalable runtime systems, Just-In-Time compilation, online feedback-directed optimization, and garbage collection. Much of my research is ultimately motivated by a desire to enable programmers to use high-level languages to construct high performance software systems.</bio>
        <homepage_url>http://researcher.watson.ibm.com/researcher/view.php?person=us-groved</homepage_url>
        <picture_url>http://pldi17.sigplan.org/getProfileImage/davidgrove/5524049e-7d0a-4799-ad8c-93e1e76a77ec/small.jpg</picture_url>
      </person>
      <person>
        <role>Committee Member in External Review Committee</role>
        <sort_key>54</sort_key>
        <first_name>Aarti</first_name>
        <last_name>Gupta</last_name>
        <affiliation>Princeton University</affiliation>
        <bio>undefined</bio>
        <homepage_url>http://www.cs.princeton.edu/~aartig/</homepage_url>
        <picture_url>http://pldi17.sigplan.org/getProfileImage/aartigupta/7c2a5663-e856-45a9-a19f-37ac2e4cd0fc/small.jpg</picture_url>
      </person>
      <person>
        <role>Committee Member in Program Committee</role>
        <sort_key>55</sort_key>
        <first_name>Tim</first_name>
        <last_name>Harris</last_name>
        <affiliation>Oracle Labs</affiliation>
        <bio>undefined</bio>
        <homepage_url>http://timharris.co.uk/</homepage_url>
        <picture_url>http://pldi17.sigplan.org/getProfileImage/timharris/7fe7b930-9d7c-4391-8afa-e3629c69cc68/small.jpg</picture_url>
      </person>
      <person>
        <role>Committee Member in Artifact Evaluation Committee, Committee Member in External Review Committee</role>
        <sort_key>56</sort_key>
        <first_name>Stefan</first_name>
        <last_name>Heule</last_name>
        <affiliation>Stanford University</affiliation>
        <bio>undefined</bio>
        <homepage_url>https://stefanheule.com/</homepage_url>
        <picture_url>http://pldi17.sigplan.org/getProfileImage/stefanheule/22f3a465-33d2-4d83-be6f-b7b96a0db792/small.jpg</picture_url>
      </person>
      <person>
        <role>Committee Member in Steering Committee</role>
        <sort_key>57</sort_key>
        <first_name>Michael</first_name>
        <last_name>Hicks</last_name>
        <affiliation>University of Maryland, College Park</affiliation>
        <bio>Michael Hicks is a Professor in the Computer Science department and UMIACS at the University of Maryland, where he co-directs the laboratory for Programming Languages research (PLUM); he is the former Director of the Maryland Cybersecurity Center (MC2). 
His research focuses on using programming languages and analyses to improve the security, reliability, and availability of software. He is perhaps best known for his work exploring dynamic software updating, which is a technique by which software can be updated without shutting it down. He has explored the design of new programming languages and analysis tools for helping programmers find bugs and software vulnerabilities, and for identifying suspicious or incorrect program executions. 
His recent work has combined ideas from PL and cryptography, e.g., to ensure privacy preserving computations. He also leads the development of a new security-oriented programming contest, “build-it, break-it, fix-it,” which has been offered to the public and to students in his Coursera class on software security. He is the co-editor of the Programming Languages Enthusiast blog and Tweets at @michael_w_hicks.</bio>
        <homepage_url>http://www.cs.umd.edu/~mwh/</homepage_url>
        <picture_url>http://pldi17.sigplan.org/getProfileImage/michaelhicks/aa64e3c6-3516-4e13-affe-77bc32c40565/small.jpg</picture_url>
      </person>
      <person>
        <role>Committee Member in External Review Committee</role>
        <sort_key>58</sort_key>
        <first_name>Martin</first_name>
        <last_name>Hirzel</last_name>
        <affiliation>IBM Research</affiliation>
        <bio>undefined</bio>
        <homepage_url>http://hirzels.com/martin/</homepage_url>
        <picture_url>http://pldi17.sigplan.org/getProfileImage/martinhirzel/8ffffeeb-b25c-4f90-b2e3-4949c2871a2a/small.jpg</picture_url>
      </person>
      <person>
        <role>Committee Member in Program Committee</role>
        <sort_key>59</sort_key>
        <first_name>Jan</first_name>
        <last_name>Hoffmann</last_name>
        <affiliation>Carnegie Mellon University</affiliation>
        <bio>I am a Tenure-Track Assistant Professor at Carnegie Mellon’s Computer Science Department, and a member of the Principles of Programming (PoP) group.
My research areas are programming languages and formal methods. I am specifically interested in quantitative verification, type systems, static resource analysis of programs, proof assistants, and system verification.
Before joining Carnegie Mellon, I was an Associate Research Scientist in the Department of Computer Science at Yale. Before that, I was a PhD student at LMU Munich.</bio>
        <homepage_url>http://www.cs.cmu.edu/~janh/</homepage_url>
        <picture_url>http://pldi17.sigplan.org/getProfileImage/janhoffmann/9adae976-6941-4521-9b57-733202e412fd/small.jpg</picture_url>
      </person>
      <person>
        <role>Committee Member in Program Committee</role>
        <sort_key>60</sort_key>
        <first_name>Jeff</first_name>
        <last_name>Huang</last_name>
        <affiliation>Texas A&amp;M University</affiliation>
        <bio>Jeff Huang is currently an Assistant Professor in the Department of Computer Science and Engineering at Texas A&amp;amp;M University. His research focuses on developing techniques and tools for improving software performance and reliability based on fundamental program analyses and programming language theory. His research has won awards including ACM SIGSOFT Outstanding Dissertation Award, SIGPLAN PLDI Distinguished Paper Award, SIGPLAN Research Highlights, Google Faculty Research Award, and NSF CAREER Award.</bio>
        <homepage_url>http://faculty.cse.tamu.edu/jeff/</homepage_url>
        <picture_url>http://pldi17.sigplan.org/getProfileImage/jeffhuang/e833bf85-f6ec-4bf1-8179-44f02b762831/small.jpg</picture_url>
      </person>
      <person>
        <role>Committee Member in Artifact Evaluation Committee</role>
        <sort_key>61</sort_key>
        <first_name>Shachar</first_name>
        <last_name>Itzhaky</last_name>
        <affiliation>MIT CSAIL</affiliation>
        <bio>undefined</bio>
        <picture_url>http://pldi17.sigplan.org/getProfileImage/shacharitzhaky/649d5921-4057-4ac3-8fc7-75471ee8527b/small.jpg</picture_url>
      </person>
      <person>
        <role>Committee Member in External Program Committee</role>
        <sort_key>62</sort_key>
        <first_name>Suresh</first_name>
        <last_name>Jagannathan</last_name>
        <affiliation>Purdue University</affiliation>
        <bio>undefined</bio>
        <homepage_url>https://www.cs.purdue.edu/homes/suresh/</homepage_url>
        <picture_url>http://pldi17.sigplan.org/getProfileImage/sureshjagannathan/70e51299-573f-4211-a895-b2028c19c585/small.jpg</picture_url>
      </person>
      <person>
        <role>Committee Member in External Review Committee</role>
        <sort_key>63</sort_key>
        <first_name>Ranjit</first_name>
        <last_name>Jhala</last_name>
        <affiliation>UC San Diego</affiliation>
        <bio>Nom nom. Chomp. Burp.</bio>
        <homepage_url>http://ranjitjhala.github.io</homepage_url>
        <picture_url>http://pldi17.sigplan.org/getProfileImage/ranjitjhala/afbdab69-ed23-4022-b7a4-2c57128f20ec/small.jpg</picture_url>
      </person>
      <person>
        <role>Committee Member in Artifact Evaluation Committee</role>
        <sort_key>64</sort_key>
        <first_name>Gowtham</first_name>
        <last_name>Kaki</last_name>
        <affiliation>Purdue University</affiliation>
        <bio>undefined</bio>
        <picture_url>http://pldi17.sigplan.org/getProfileImage/gowthamkaki/0ecc1c76-4bab-4b2b-bbf8-20104d29c38d/small.jpg</picture_url>
      </person>
      <person>
        <role>Committee Member in Artifact Evaluation Committee</role>
        <sort_key>65</sort_key>
        <first_name>Saurabh</first_name>
        <last_name>Kalikar</last_name>
        <affiliation>Indian Institute of Technology, Madras</affiliation>
        <bio>undefined</bio>
        <homepage_url>http://www.cse.iitm.ac.in/~saurabhk/</homepage_url>
        <picture_url>http://pldi17.sigplan.org/getProfileImage/saurabhkalikar/51378e60-6523-4a33-af2c-f8228d282929/small.jpg</picture_url>
      </person>
      <person>
        <role>Committee Member in Program Committee</role>
        <sort_key>66</sort_key>
        <first_name>Zachary</first_name>
        <last_name>Kincaid</last_name>
        <affiliation>Princeton University</affiliation>
        <bio>undefined</bio>
        <homepage_url>http://www.cs.princeton.edu/~zkincaid</homepage_url>
        <picture_url>http://pldi17.sigplan.org/getProfileImage/zacharykincaid/a26b486e-94a5-45f1-a8b3-9a2221495ff7/small.jpg</picture_url>
      </person>
      <person>
        <role>Committee Member in SRC Panel</role>
        <sort_key>67</sort_key>
        <first_name>Martin</first_name>
        <last_name>Kong</last_name>
        <affiliation>Rice University</affiliation>
        <bio>undefined</bio>
        <picture_url>http://pldi17.sigplan.org/getProfileImage/martinkong1/46b2941d-7ca9-41bf-93f5-0aa369f729da/small.jpg</picture_url>
      </person>
      <person>
        <role>Committee Member in Steering Committee</role>
        <sort_key>68</sort_key>
        <first_name>Chandra</first_name>
        <last_name>Krintz</last_name>
        <affiliation>UC Santa Barbara</affiliation>
        <bio>Chandra Krintz is a Professor of Computer Science at the University of California, Santa Barbara (UCSB) and co-founder and Chief Scientist of AppScale Systems, Inc. She joined the UCSB faculty in 2001 after receiving her M.S. and Ph.D. degrees in Computer Science from the University of California, San Diego (UCSD). Chandra has led a number of different research projects that have advanced the state-of-the-art in programming systems in ways that improve performance and energy consumption, and that ease development and deployment of software. Recently, her work has focused on the intersection of IoT, cloud computing, and data analytics with applications in farming and ranching (SmartFarm) and health management (Vigilance). Chandra has advised over 60 undergraduate and graduate students, has published numerous research articles regarding the implementation of programming languages in venues that include ASPLOS, ECOOP, HotCloud, IEEE Cloud, PLDI, OOPSLA and others, participates in efforts to broaden participation in computing, and is the progenitor of the AppScale project. Chandra’s efforts have been recognized with a NSF CAREER award, the CRA-W Anita Borg Early Career Award (BECA), the UCSB Academic Senate Distinguished Teaching Award, and as the 2015 UCSB Sustainability Champion.</bio>
        <homepage_url>http://www.cs.ucsb.edu/~ckrintz</homepage_url>
        <picture_url>http://pldi17.sigplan.org/getProfileImage/chandrakrintz/f48a52e3-3e8a-43c6-84b0-17a1c4e49d84/small.jpg</picture_url>
      </person>
      <person>
        <role>Committee Member in Program Committee</role>
        <sort_key>69</sort_key>
        <first_name>Milind</first_name>
        <last_name>Kulkarni</last_name>
        <affiliation>Purdue University</affiliation>
        <bio>I am an associate professor with the School of Electrical and Computer Engineering at Purdue University.
My research area is Programming Languages and Compilers, and my interests lie specifically in developing languages, compilers and runtimes that support efficient programming and high performance on emerging complex architectures.
I graduated in 2002 with a B.S. in both Computer Science and Computer Engineering from North Carolina State University. I received my Ph.D. in Computer Science from Cornell University. My advisor was Keshav Pingali. While pursuing my Ph.D., I was supported by a Department of Energy High Performance Computer Science (HPCS) Fellowship. After receiving my Ph.D., I joined the Institute for Computational Sciences and Engineering at the University of Texas at Austin as a postdoc, where I worked with the Intelligent Software Systems (ISS) group. Since the fall of 2009, I have been in the School of Electrical and Computer Engineering at Purdue University.</bio>
        <homepage_url>https://engineering.purdue.edu/~milind/</homepage_url>
        <picture_url>http://pldi17.sigplan.org/getProfileImage/milindkulkarni/879b2ea0-ca46-4c89-82d2-fdc7efd15943/small.jpg</picture_url>
      </person>
      <person>
        <role>Committee Member in Artifact Evaluation Committee</role>
        <sort_key>70</sort_key>
        <first_name>Sulekha</first_name>
        <last_name>Kulkarni</last_name>
        <affiliation>University of Pennsylvania</affiliation>
        <bio>undefined</bio>
        <picture_url>http://pldi17.sigplan.org/getProfileImage/sulekhakulkarni/d76c709e-5546-4041-b82e-1d3d82f5a3af/small.jpg</picture_url>
      </person>
      <person>
        <role>Committee Member in Artifact Evaluation Committee</role>
        <sort_key>71</sort_key>
        <first_name>Snehasish</first_name>
        <last_name>Kumar</last_name>
        <affiliation>Simon Fraser University</affiliation>
        <bio>undefined</bio>
        <homepage_url>http://snehasish.net</homepage_url>
      </person>
      <person>
        <role>Committee Member in Artifact Evaluation Committee</role>
        <sort_key>72</sort_key>
        <first_name>Ivan</first_name>
        <last_name>Kuraj</last_name>
        <affiliation>MIT CSAIL, USA</affiliation>
        <bio>undefined</bio>
        <picture_url>http://pldi17.sigplan.org/getProfileImage/ivankuraj/6a79beec-4cad-43a2-8ab0-2d344476a0dc/small.jpg</picture_url>
      </person>
      <person>
        <role>Committee Member in External Review Committee</role>
        <sort_key>73</sort_key>
        <first_name>Patrick</first_name>
        <last_name>Lam</last_name>
        <affiliation>University of Waterloo</affiliation>
        <bio>undefined</bio>
        <homepage_url>http://patricklam.ca</homepage_url>
        <picture_url>http://pldi17.sigplan.org/getProfileImage/patricklam/d94f6246-8d4e-4896-a263-379eb20a9b24/small.jpg</picture_url>
      </person>
      <person>
        <role>Committee Member in Artifact Evaluation Committee</role>
        <sort_key>74</sort_key>
        <first_name>Andrei</first_name>
        <last_name>Lascu</last_name>
        <affiliation>Imperial College London</affiliation>
        <bio>undefined</bio>
      </person>
      <person>
        <role>Committee Member in External Program Committee</role>
        <sort_key>75</sort_key>
        <first_name>Sorin</first_name>
        <last_name>Lerner</last_name>
        <affiliation>University of California, San Diego</affiliation>
        <bio>undefined</bio>
        <homepage_url>http://cseweb.ucsd.edu/users/lerner/</homepage_url>
        <picture_url>http://pldi17.sigplan.org/getProfileImage/sorinlerner/3d3b1a70-e2f8-4d3a-a1bc-9c4e17dad80b/small.jpg</picture_url>
      </person>
      <person>
        <role>Committee Member in External Program Committee</role>
        <sort_key>76</sort_key>
        <first_name>Ondřej</first_name>
        <last_name>Lhoták</last_name>
        <affiliation>University of Waterloo, Canada</affiliation>
        <bio>undefined</bio>
        <homepage_url>http://plg.uwaterloo.ca/~olhotak/</homepage_url>
        <picture_url>http://pldi17.sigplan.org/getProfileImage/ondrejlhotak/5eff0fbe-ccf6-4901-88b8-25b68df221a3/small.jpg</picture_url>
      </person>
      <person>
        <role>Committee Member in Program Committee</role>
        <sort_key>77</sort_key>
        <first_name>Francesco</first_name>
        <last_name>Logozzo</last_name>
        <affiliation>Facebook</affiliation>
        <bio>I love static static program analysis. I’ve been designing and implementing widely used static analysis tools. I published papers in the most important research conferences and gave talks at main research and industrial conferences as e.g., Build.</bio>
        <picture_url>http://pldi17.sigplan.org/getProfileImage/francescologozzo/c8fcced3-bf41-4a41-986e-62005184dfe6/small.jpg</picture_url>
      </person>
      <person>
        <role>Committee Member in Program Committee</role>
        <sort_key>78</sort_key>
        <first_name>Shan</first_name>
        <last_name>Lu</last_name>
        <affiliation>University of Chicago</affiliation>
        <bio>undefined</bio>
        <homepage_url>http://people.cs.uchicago.edu/~shanlu/</homepage_url>
        <picture_url>http://pldi17.sigplan.org/getProfileImage/shanlu/ff4a1ab8-c007-457e-9a06-6740135b2289/small.jpg</picture_url>
      </person>
      <person>
        <role>Committee Member in External Review Committee</role>
        <sort_key>79</sort_key>
        <first_name>Ravichandhran</first_name>
        <last_name>Madhavan</last_name>
        <affiliation>EPFL</affiliation>
        <bio>undefined</bio>
        <homepage_url>http://lara.epfl.ch/~kandhada</homepage_url>
        <picture_url>http://pldi17.sigplan.org/getProfileImage/ravichandhranmadhavan/6ae9aa98-39e7-4f8b-a6be-21a7df02d148/small.jpg</picture_url>
      </person>
      <person>
        <role>Committee Member in External Program Committee</role>
        <sort_key>80</sort_key>
        <first_name>P.</first_name>
        <last_name>Madhusudan</last_name>
        <affiliation>University of Illinois at Urbana-Champaign</affiliation>
        <bio>undefined</bio>
        <homepage_url>http://madhu.cs.illinois.edu</homepage_url>
        <picture_url>http://pldi17.sigplan.org/getProfileImage/pmadhusudan/3775a90b-eb5d-4825-86d8-2a91a1e68fdf/small.jpg</picture_url>
      </person>
      <person>
        <role>Committee Member in Program Committee</role>
        <sort_key>81</sort_key>
        <first_name>Vikash</first_name>
        <last_name>Mansinghka</last_name>
        <affiliation>Massachusetts Institute of Technology</affiliation>
        <bio>undefined</bio>
        <homepage_url>http://probcomp.csail.mit.edu/people/vkm.html</homepage_url>
        <picture_url>http://pldi17.sigplan.org/getProfileImage/vikashmansinghka/e679c7d0-e65f-4ba2-b6a9-e77da2d52b9e/small.jpg</picture_url>
      </person>
      <person>
        <role>Committee Member in External Review Committee</role>
        <sort_key>82</sort_key>
        <first_name>Stephen</first_name>
        <last_name>McCamant</last_name>
        <affiliation>University of Minnesota</affiliation>
        <bio>As of the fall semester of 2012 I’m an assistant professor here at the University of Minnesota. For the 2008-2012 academic years I was a postdoc and project scientist at the University of California, Berkeley. I got my M.S. and Ph.D. at MIT, working with Michael Ernst (now at the University of Washington) and the Program Analysis Group. During this time I also spent the summer of 2005 at Microsoft Research in Redmond, working with Trishul Chilimbi on using dynamically-collected points-to sets to improve the efficiency of software model checking. Prior to that I got my undergraduate B.A. in computer science at the University of California, Berkeley; while there, I worked with the Harmonia research group and helped out at the Open Computing Facility, among other things.</bio>
        <homepage_url>http://www-users.cs.umn.edu/~mccamant/</homepage_url>
        <picture_url>http://pldi17.sigplan.org/getProfileImage/stephenmccamant/279a1a47-3065-46b4-99a6-92fa225fc5cc/small.jpg</picture_url>
      </person>
      <person>
        <role>Committee Member in Artifact Evaluation Committee</role>
        <sort_key>83</sort_key>
        <first_name>Gianluca</first_name>
        <last_name>Mezzetti</last_name>
        <affiliation>Aarhus University, Denmark</affiliation>
        <bio>undefined</bio>
        <homepage_url>http://gmezzetti.name</homepage_url>
        <picture_url>http://pldi17.sigplan.org/getProfileImage/gianlucamezzetti/dc3fa478-afb4-44b1-9946-e05669f5346d/small.jpg</picture_url>
      </person>
      <person>
        <role>Committee Member in External Program Committee</role>
        <sort_key>84</sort_key>
        <first_name>Todd</first_name>
        <last_name>Millstein</last_name>
        <affiliation>University of California, Los Angeles</affiliation>
        <bio>I am a Professor in the Computer Science Department at the University of California, Los Angeles (UCLA).
I was the Program Chair for OOPSLA 2014.</bio>
        <homepage_url>http://www.cs.ucla.edu/~todd/</homepage_url>
        <picture_url>http://pldi17.sigplan.org/getProfileImage/toddmillstein/03692d64-e4ad-4fb1-a2b0-9271ce27715c/small.jpg</picture_url>
      </person>
      <person>
        <role>Committee Member in Artifact Evaluation Committee</role>
        <sort_key>85</sort_key>
        <first_name>Anders</first_name>
        <last_name>Miltner</last_name>
        <affiliation>Princeton University</affiliation>
        <bio>undefined</bio>
        <homepage_url>http://www.cs.princeton.edu/~amiltner/</homepage_url>
      </person>
      <person>
        <role>Committee Member in Program Committee</role>
        <sort_key>86</sort_key>
        <first_name>Sasa</first_name>
        <last_name>Misailovic</last_name>
        <affiliation>University of Illinois at Urbana-Champaign</affiliation>
        <bio>undefined</bio>
        <homepage_url>http://misailo.web.engr.illinois.edu/</homepage_url>
        <picture_url>http://pldi17.sigplan.org/getProfileImage/sasamisailovic/f21df008-72c6-4d75-a875-cbb430664d9c/small.jpg</picture_url>
      </person>
      <person>
        <role>Committee Member in Artifact Evaluation Committee</role>
        <sort_key>87</sort_key>
        <first_name>Rashmi</first_name>
        <last_name>Mudduluru</last_name>
        <affiliation>Microsoft Research India</affiliation>
        <bio>undefined</bio>
        <picture_url>http://pldi17.sigplan.org/getProfileImage/rashmimudduluru/61211426-6812-49f4-8bde-7db3c007ca33/small.jpg</picture_url>
      </person>
      <person>
        <role>Committee Member in Program Committee</role>
        <sort_key>88</sort_key>
        <first_name>Madan</first_name>
        <last_name>Musuvathi</last_name>
        <affiliation>Microsoft Research</affiliation>
        <bio>undefined</bio>
        <homepage_url>http://research.microsoft.com/en-us/people/madanm/</homepage_url>
        <picture_url>http://pldi17.sigplan.org/getProfileImage/madanmusuvathi/03a998f8-9b95-465d-acc2-a35967c0319f/small.jpg</picture_url>
      </person>
      <person>
        <role>Committee Member in Program Committee</role>
        <sort_key>89</sort_key>
        <first_name>Onur</first_name>
        <last_name>Mutlu</last_name>
        <affiliation>ETH Zurich</affiliation>
        <bio>Onur Mutlu is a Full Professor of Computer Science at ETH Zurich. He previously held the William D. and Nancy W. Strecker Early Career Professorship at Carnegie Mellon University, and is also a faculty member there. His current broader research interests are in computer architecture, systems, and bioinformatics. He is especially interested in interactions across domains and between applications, system software, compilers, and microarchitecture, with a major current focus on memory and storage systems. He obtained his PhD and MS in ECE from the University of Texas at Austin and BS degrees in Computer Engineering and Psychology from the University of Michigan, Ann Arbor. His industrial experience spans starting the Computer Architecture Group at Microsoft Research (2006-2009), and various product and research positions at Intel Corporation, Advanced Micro Devices, and VMware. He received the inaugural IEEE Computer Society Young Computer Architect Award, the inaugural Intel Early Career Faculty Award, faculty partnership awards from various companies, and a healthy number of best paper or “Top Pick” paper recognitions at various computer systems and architecture venues. His computer architecture course lectures and materials are freely available on YouTube, and his research group makes software artifacts freely available online. For more information, please see his webpage at http://www.ece.cmu.edu/~omutlu.</bio>
        <homepage_url>https://users.ece.cmu.edu/~omutlu</homepage_url>
        <picture_url>http://pldi17.sigplan.org/getProfileImage/onurmutlu1/6640245e-25f0-41da-a278-12fbc2327d1d/small.jpg</picture_url>
      </person>
      <person>
        <role>Committee Member in Program Committee</role>
        <sort_key>90</sort_key>
        <first_name>Anders</first_name>
        <last_name>Møller</last_name>
        <affiliation>Aarhus University</affiliation>
        <bio>Professor at Department of Computer Science, Aarhus University, Denmark</bio>
        <homepage_url>https://cs.au.dk/~amoeller/</homepage_url>
        <picture_url>http://pldi17.sigplan.org/getProfileImage/andersmoller/a6b971e9-27d8-44ed-84d2-5ce2d53ff5e4/small.jpg</picture_url>
      </person>
      <person>
        <role>Committee Member in External Review Committee</role>
        <sort_key>91</sort_key>
        <first_name>Santosh</first_name>
        <last_name>Nagarakatte</last_name>
        <affiliation>Rutgers University, USA</affiliation>
        <bio>undefined</bio>
        <homepage_url>http://www.cs.rutgers.edu/~santosh.nagarakatte/</homepage_url>
        <picture_url>http://pldi17.sigplan.org/getProfileImage/santoshnagarakatte/a3ea2016-e7d9-4e30-9b59-c61dd7270ea1/small.jpg</picture_url>
      </person>
      <person>
        <role>Committee Member in Program Committee</role>
        <sort_key>92</sort_key>
        <first_name>Mayur</first_name>
        <last_name>Naik</last_name>
        <affiliation>Georgia Tech</affiliation>
        <bio>undefined</bio>
        <homepage_url>http://cc.gatech.edu/~naik/</homepage_url>
        <picture_url>http://pldi17.sigplan.org/getProfileImage/mayurnaik/681e8d43-e5b6-4a09-a8a5-11053f830db6/small.jpg</picture_url>
      </person>
      <person>
        <role>Committee Member in External Review Committee</role>
        <sort_key>93</sort_key>
        <first_name>Ryan R.</first_name>
        <last_name>Newton</last_name>
        <affiliation>Indiana University</affiliation>
        <bio>From South Florida. Ph.D. 2009 at MIT.</bio>
        <homepage_url>http://cs.indiana.edu/~rrnewton</homepage_url>
        <picture_url>http://pldi17.sigplan.org/getProfileImage/ryanrnewton/4dff7d06-8ca4-46f3-981b-52049bc71c54/small.jpg</picture_url>
      </person>
      <person>
        <role>Committee Member in Steering Committee</role>
        <sort_key>94</sort_key>
        <first_name>Michael</first_name>
        <last_name>O'Boyle</last_name>
        <affiliation>University of Edinburgh</affiliation>
        <bio>undefined</bio>
        <homepage_url>http://www.dcs.ed.ac.uk/home/mob/</homepage_url>
        <picture_url>http://pldi17.sigplan.org/getProfileImage/michaeloboyle/5f122bb6-da4b-4655-be8f-15331d4d16e3/small.jpg</picture_url>
      </person>
      <person>
        <role>Organizing Chair in Organizing Committee</role>
        <sort_key>95</sort_key>
        <first_name>Fernando</first_name>
        <last_name>Orejas</last_name>
        <affiliation>Universitat Politècnica de Catalunya, Spain</affiliation>
        <bio>undefined</bio>
        <homepage_url>https://www.cs.upc.edu/~orejas/</homepage_url>
        <picture_url>http://pldi17.sigplan.org/getProfileImage/fernandoorejas/4f33bc25-77b8-438b-b13c-f92f8c92162a/small.jpg</picture_url>
      </person>
      <person>
        <role>Committee Member in External Review Committee</role>
        <sort_key>96</sort_key>
        <first_name>Peter-Michael</first_name>
        <last_name>Osera</last_name>
        <affiliation>Grinnell College</affiliation>
        <bio>undefined</bio>
        <homepage_url>http://www.cs.grinnell.edu/~osera</homepage_url>
        <picture_url>http://pldi17.sigplan.org/getProfileImage/petermichaelosera/e150f329-fb7d-4641-80e6-a3e97bbe9e11/small.jpg</picture_url>
      </person>
      <person>
        <role>Committee Member in Artifact Evaluation Committee</role>
        <sort_key>97</sort_key>
        <first_name>Leo</first_name>
        <last_name>Osvald</last_name>
        <affiliation>Purdue University, USA</affiliation>
        <bio>undefined</bio>
        <homepage_url>http://losvald.github.io/</homepage_url>
        <picture_url>http://pldi17.sigplan.org/getProfileImage/leoosvald/c3133578-a5cb-4a62-b264-f5f112cacb7a/small.jpg</picture_url>
      </person>
      <person>
        <role>Committee Member in Artifact Evaluation Committee</role>
        <sort_key>98</sort_key>
        <first_name>Sreepathi</first_name>
        <last_name>Pai</last_name>
        <affiliation>University of Texas, Austin</affiliation>
        <bio>undefined</bio>
        <homepage_url>http://users.ices.utexas.edu/~sreepai/</homepage_url>
      </person>
      <person>
        <role>Committee Member in External Program Committee</role>
        <sort_key>99</sort_key>
        <first_name>Jens</first_name>
        <last_name>Palsberg</last_name>
        <affiliation>University of California, Los Angeles</affiliation>
        <bio>undefined</bio>
        <homepage_url>http://www.cs.ucla.edu/~palsberg</homepage_url>
        <picture_url>http://pldi17.sigplan.org/getProfileImage/jenspalsberg/9e470c6a-532d-472c-9fea-253b7fa22c7c/small.jpg</picture_url>
      </person>
      <person>
        <role>Committee Member in External Review Committee</role>
        <sort_key>100</sort_key>
        <first_name>Hannes</first_name>
        <last_name>Payer</last_name>
        <affiliation>Google</affiliation>
        <bio>undefined</bio>
        <homepage_url>http://research.google.com/pubs/HannesPayer.html</homepage_url>
        <picture_url>http://pldi17.sigplan.org/getProfileImage/hannespayer/78040631-dcb2-434d-b80a-f095f1bf5e22/small.jpg</picture_url>
      </person>
      <person>
        <role>Committee Member in External Program Committee</role>
        <sort_key>101</sort_key>
        <first_name>Erez</first_name>
        <last_name>Petrank</last_name>
        <affiliation>Technion</affiliation>
        <bio>undefined</bio>
        <homepage_url>http://www.cs.technion.ac.il/~erez/</homepage_url>
        <picture_url>http://pldi17.sigplan.org/getProfileImage/erezpetrank/3702f320-691f-4615-b91b-617aedb2334b/small.jpg</picture_url>
      </person>
      <person>
        <role>Committee Member in Steering Committee</role>
        <sort_key>102</sort_key>
        <first_name>Keshav</first_name>
        <last_name>Pingali</last_name>
        <affiliation>University of Texas, Austin</affiliation>
        <bio>Keshav Pingali is the W.A.“Tex” Moncrief Chair of Computing in the Computer Sciences department at the University of Texas, Austin. He was on the faculty of the Department of Computer Science at Cornell University from 1986 to 2006, where he held the India Chair of Computer Science.
Pingali’s research has focused on programming languages and compiler technology for program understanding, restructuring, and optimization. His group is known for its contributions to memory-hierarchy optimization; some of these have been patented. Algorithms and tools developed by his projects are used in many commercial products such as Intel’s IA-64 compiler, SGI’s MIPSPro compiler, and HP’s PA-RISC compiler. His current research is focused on programming languages and tools for multicore processors. 
Pingali is a Fellow of the IEEE, Fellow of the American Association for the Advancement of Science, and is the Editor-in-chief of the ACM Transactions on Programming Languages and Systems. He also serves on the NSF CISE Advisory Committee (2009-2011).</bio>
        <homepage_url>http://www.cs.utexas.edu/~pingali/</homepage_url>
        <picture_url>http://pldi17.sigplan.org/getProfileImage/keshavpingali/c7016cfb-7564-4d57-af35-447cec77fafd/small.jpg</picture_url>
      </person>
      <person>
        <role>Committee Member in Program Committee</role>
        <sort_key>103</sort_key>
        <first_name>Marco</first_name>
        <last_name>Pistoia</last_name>
        <affiliation>IBM Research</affiliation>
        <bio>Marco Pistoia, Ph.D. has worked for IBM Corporation since January 1996 and is currently an IBM Distinguished Researcher and Senior Manager at the IBM Thomas J. Watson Research Center in New York, where he manages the Mobile Enterprise Software research group. In January 2010, he was one of 38 IBM employees worldwide to be bestowed the title of IBM Master Inventor. In June 2016, he was nominated the Chair of the Mobile Computing Professional Interest Community at IBM Research. He is the inventor of 115 patents granted by the United States Patent and Trademark Office, and 171 patent applications. Dr. Pistoia has designed and implemented numerous analysis components and contributed large amounts of code to several IBM products. Dr. Pistoia has lectured at 22 top universities in 9 countries worldwide. He has written 10 books and published numerous papers and journal articles on various aspects of Program Analysis, Language-Based Security and Mobile Computing. In the course of his career, Dr. Pistoia received three ACM Distinguished Paper Awards (2007, 2011 and 2014). In September 2007, the Italian Ministry of Education, University and Research, the National Committee of the Italian Presidents of Faculties of Sciences and Technologies, and Confindustria, Italy’s leading organization representing all the Italian manufacturing and service companies, presented Pistoia as one of the 70 most successful Italian mathematicians who graduated from an Italian university between the years 1980 and 2000. His biography was published in the book “Matematici al Lavoro”.</bio>
        <homepage_url>http://researcher.watson.ibm.com/researcher/view.php?person=us-pistoia</homepage_url>
        <picture_url>http://pldi17.sigplan.org/getProfileImage/marcopistoia/d620373b-14a7-4f04-90a8-285c72a6c4cb/small.jpg</picture_url>
      </person>
      <person>
        <role>Committee Member in External Review Committee</role>
        <sort_key>104</sort_key>
        <first_name>Andreas</first_name>
        <last_name>Podelski</last_name>
        <affiliation>University of Freiburg, Germany</affiliation>
        <bio>Max Planck Institute for Computer Science, 1995-2006.
DEC PRL (Digital Paris Research Laboratory), 1992-94.
University of Paris 7, LITP, 1989-92
University of California at Berkeley, 1988-89
PhD, University of Paris 7. Supervisor Maurice Nivat.
Diplom, University of M&amp;uuml;nster. Supervisor Dieter R&amp;ouml;dding.</bio>
        <homepage_url>http://swt.informatik.uni-freiburg.de/staff/podelski</homepage_url>
        <picture_url>http://pldi17.sigplan.org/getProfileImage/andreaspodelski/f1a42650-d2d4-4ce6-b4cb-49a2b8ab8023/small.jpg</picture_url>
      </person>
      <person>
        <role>Committee Member in Artifact Evaluation Committee</role>
        <sort_key>105</sort_key>
        <first_name>Bobby</first_name>
        <last_name>Powers</last_name>
        <affiliation>University of Massachusetts, Amherst</affiliation>
        <bio>undefined</bio>
        <homepage_url>https://bpowers.net/</homepage_url>
        <picture_url>http://pldi17.sigplan.org/getProfileImage/bobbypowers/457669c1-00bb-4376-8892-ea5c934ff729/small.jpg</picture_url>
      </person>
      <person>
        <role>Committee Member in Program Committee</role>
        <sort_key>106</sort_key>
        <first_name>Michael</first_name>
        <last_name>Pradel</last_name>
        <affiliation>TU Darmstadt</affiliation>
        <bio>undefined</bio>
        <homepage_url>http://mp.binaervarianz.de/</homepage_url>
        <picture_url>http://pldi17.sigplan.org/getProfileImage/michaelpradel/06ef7ed7-0982-404f-8261-5188acacd15f/small.jpg</picture_url>
      </person>
      <person>
        <role>Committee Member in External Review Committee</role>
        <sort_key>107</sort_key>
        <first_name>Zvonimir</first_name>
        <last_name>Rakamaric</last_name>
        <affiliation>University of Utah</affiliation>
        <bio>Zvonimir Rakamaric is an assistant professor in the School of Computing at the University of Utah. Prior to this, he was a postdoctoral fellow at Carnegie Mellon University in Silicon Valley, where he worked closely with researchers from the Robust Software Engineering Group at NASA Ames Research Center to improve the coverage of testing of NASA’s flight critical systems. Zvonimir received his bachelor’s degree in Computer Science from the University of Zagreb, Croatia; he obtained his M.Sc. and Ph.D. from the Department of Computer Science at the University of British Columbia, Canada.
Zvonimir’s research mission is to improve the reliability and resilience of complex software systems by empowering developers with practical tools and techniques for analysis of their artifacts. He is a recipient of the NSF CAREER Award 2016, Microsoft Research Software Engineering Innovation Foundation (SEIF) Award 2012, Microsoft Research Graduate Fellowship 2008-2010, Silver Medal in the ACM Student Research Competition at the 32nd International Conference on Software Engineering (ICSE) 2010, and the Outstanding Student Paper Award at the 13th International Conference on Tools and Algorithms for the Construction and Analysis of Systems (TACAS) 2007.</bio>
        <homepage_url>http://www.zvonimir.info/</homepage_url>
        <picture_url>http://pldi17.sigplan.org/getProfileImage/zvonimirrakamaric/0138077c-8a38-4c25-a7b6-ae4fc90444d3/small.jpg</picture_url>
      </person>
      <person>
        <role>Committee Member in External Review Committee</role>
        <sort_key>108</sort_key>
        <first_name>Veselin</first_name>
        <last_name>Raychev</last_name>
        <affiliation>ETH Zurich</affiliation>
        <bio>undefined</bio>
        <picture_url>http://pldi17.sigplan.org/getProfileImage/veselinraychev/db97087e-99af-4eb1-a335-2123d93f0e70/small.jpg</picture_url>
      </person>
      <person>
        <role>Committee Member in External Review Committee</role>
        <sort_key>109</sort_key>
        <first_name>Mariana</first_name>
        <last_name>Raykova</last_name>
        <affiliation>Yale University</affiliation>
        <bio>undefined</bio>
        <homepage_url>http://www.cs.yale.edu/homes/raykova-mariana/</homepage_url>
        <picture_url>http://pldi17.sigplan.org/getProfileImage/marianaraykova/e21ffd32-011b-4fbb-b22a-3ecd8d508057/small.jpg</picture_url>
      </person>
      <person>
        <role>Committee Member in External Program Committee</role>
        <sort_key>110</sort_key>
        <first_name>John</first_name>
        <last_name>Regehr</last_name>
        <affiliation>University of Utah</affiliation>
        <bio>undefined</bio>
        <homepage_url>http://www.cs.utah.edu/~regehr/</homepage_url>
        <picture_url>http://pldi17.sigplan.org/getProfileImage/johnregehr/2cb23ab0-042a-487a-a859-cbd3147a46a7/small.jpg</picture_url>
      </person>
      <person>
        <role>Committee Member in External Review Committee</role>
        <sort_key>111</sort_key>
        <first_name>Noam</first_name>
        <last_name>Rinetzky</last_name>
        <affiliation>Tel Aviv University</affiliation>
        <bio>undefined</bio>
        <homepage_url>http://www.cs.tau.ac.il/~maon/</homepage_url>
        <picture_url>http://pldi17.sigplan.org/getProfileImage/noamrinetzky/1ea9bd0d-bd16-4b15-bb66-a8a576ffaa40/small.jpg</picture_url>
      </person>
      <person>
        <role>Committee Member in External Review Committee</role>
        <sort_key>112</sort_key>
        <first_name>Cindy</first_name>
        <last_name>Rubio-Gonzalez</last_name>
        <affiliation>University of California, Davis</affiliation>
        <bio>undefined</bio>
        <homepage_url>http://web.cs.ucdavis.edu/~rubio/</homepage_url>
        <picture_url>http://pldi17.sigplan.org/getProfileImage/cindyrubiogonzalez/e24a64f1-93fa-44d5-9dc3-31a3b132da7a/small.jpg</picture_url>
      </person>
      <person>
        <role>Committee Member in Program Committee</role>
        <sort_key>113</sort_key>
        <first_name>Andrey</first_name>
        <last_name>Rybalchenko</last_name>
        <affiliation>Microsoft Research</affiliation>
        <bio>undefined</bio>
        <homepage_url>http://research.microsoft.com/en-us/people/rybal/</homepage_url>
        <picture_url>http://pldi17.sigplan.org/getProfileImage/andreyrybalchenko/6a82d181-045a-4268-b923-13bdd175f20a/small.jpg</picture_url>
      </person>
      <person>
        <role>Committee Member in Artifact Evaluation Committee</role>
        <sort_key>114</sort_key>
        <first_name>Malavika</first_name>
        <last_name>Samak</last_name>
        <affiliation>Indian Institute of Science, Bangalore</affiliation>
        <bio>undefined</bio>
        <homepage_url>https://sites.google.com/site/malavikasamak/</homepage_url>
        <picture_url>http://pldi17.sigplan.org/getProfileImage/malavikasamak/d626d9b8-666d-4576-8a77-a70480fbd62c/small.jpg</picture_url>
      </person>
      <person>
        <role>Committee Member in External Program Committee</role>
        <sort_key>115</sort_key>
        <first_name>Vivek</first_name>
        <last_name>Sarkar</last_name>
        <affiliation>Rice University, USA</affiliation>
        <bio>undefined</bio>
        <picture_url>http://pldi17.sigplan.org/getProfileImage/viveksarkar/265f6790-2dd2-44b7-939e-07ebfc095e59/small.jpg</picture_url>
      </person>
      <person>
        <role>Treasurer &amp; Conference Manager in Organizing Committee</role>
        <sort_key>116</sort_key>
        <first_name>Annabel</first_name>
        <last_name>Satin</last_name>
        <affiliation>P.C.K.</affiliation>
        <bio>undefined</bio>
        <picture_url>http://pldi17.sigplan.org/getProfileImage/annabelsatin/55d26f61-6953-4847-b1a2-b237a7b429c4/small.jpg</picture_url>
      </person>
      <person>
        <role>Committee Member in SRC Panel</role>
        <sort_key>117</sort_key>
        <first_name>Cole</first_name>
        <last_name>Schlesinger</last_name>
        <affiliation>Samsung Research America</affiliation>
        <bio>I am a research engineer with the Advanced Programming Tools team at Samsung Research America. My research focuses on linguistic modeling and verification of software systems and networks.
Prior to joining SRA, I received a Ph.D. from Princeton University, advised by David Walker.
For past and ongoing projects, please visit: http://www.schlesinger.tech</bio>
        <homepage_url>http://www.schlesinger.tech</homepage_url>
        <picture_url>http://pldi17.sigplan.org/getProfileImage/coleschlesinger/026cdfa4-a4e7-40fc-8218-4b61c3a8e12c/small.jpg</picture_url>
      </person>
      <person>
        <role>Committee Member in External Program Committee</role>
        <sort_key>118</sort_key>
        <first_name>Koushik</first_name>
        <last_name>Sen</last_name>
        <affiliation>University of California, Berkeley</affiliation>
        <bio>Koushik Sen is an associate professor in the Department of Electrical Engineering and Computer Sciences at the University of California, Berkeley. His research interest lies in Software Engineering, Programming Languages, and Formal methods. He is interested in developing software tools and methodologies that improve programmer productivity and software quality. He is best known for his work on “DART: Directed Automated Random Testing” and concolic testing. He has received a NSF CAREER Award in 2008, a Haifa Verification Conference (HVC) Award in 2009, a IFIP TC2 Manfred Paul Award for Excellence in Software: Theory and Practice in 2010, a Sloan Foundation Fellowship in 2011, a Professor R. Narasimhan Lecture Award in 2014, and an Okawa Foundation Research Grant in 2015. He has won several ACM SIGSOFT Distinguished Paper Awards. He received the C.L. and Jane W-S. Liu Award in 2004, the C. W. Gear Outstanding Graduate Award in 2005, and the David J. Kuck Outstanding Ph.D. Thesis Award in 2007, and a Distinguished Alumni Educator Award in 2014 from the UIUC Department of Computer Science. He holds a B.Tech from Indian Institute of Technology, Kanpur, and M.S. and Ph.D. in CS from University of Illinois at Urbana-Champaign.</bio>
        <homepage_url>https://people.eecs.berkeley.edu/~ksen/</homepage_url>
        <picture_url>http://pldi17.sigplan.org/getProfileImage/koushiksen/9f417f8a-40b9-40a7-866c-9c44cd81859a/small.jpg</picture_url>
      </person>
      <person>
        <role>Committee Member in External Program Committee</role>
        <sort_key>119</sort_key>
        <first_name>Peter</first_name>
        <last_name>Sewell</last_name>
        <affiliation>University of Cambridge</affiliation>
        <bio>undefined</bio>
        <homepage_url>http://www.cl.cam.ac.uk/~pes20/</homepage_url>
        <picture_url>http://pldi17.sigplan.org/getProfileImage/petersewell/ba28b120-f5b2-42d2-90b8-0559f144abee/small.jpg</picture_url>
      </person>
      <person>
        <role>Committee Member in Artifact Evaluation Committee</role>
        <sort_key>120</sort_key>
        <first_name>Rian</first_name>
        <last_name>Shambaugh</last_name>
        <affiliation>University of Massachusetts Amherst</affiliation>
        <bio>undefined</bio>
        <homepage_url>https://people.cs.umass.edu/~rian/</homepage_url>
        <picture_url>http://pldi17.sigplan.org/getProfileImage/rianshambaugh/3d585082-7388-4e46-ba33-915979830a60/small.jpg</picture_url>
      </person>
      <person>
        <role>Committee Member in External Program Committee</role>
        <sort_key>121</sort_key>
        <first_name>Zhong</first_name>
        <last_name>Shao</last_name>
        <affiliation>Yale University</affiliation>
        <bio>undefined</bio>
        <homepage_url>http://www.cs.yale.edu/homes/shao/</homepage_url>
        <picture_url>http://pldi17.sigplan.org/getProfileImage/zhongshao/18a2973a-020f-46ed-9073-85bd70626116/small.jpg</picture_url>
      </person>
      <person>
        <role>Committee Member in External Review Committee</role>
        <sort_key>122</sort_key>
        <first_name>Rahul</first_name>
        <last_name>Sharma</last_name>
        <affiliation>Microsoft Research</affiliation>
        <bio>Rahul Sharma is a researcher at Microsoft Research India. He received a Ph.D. in Computer Science from Stanford University, where he was advised by Prof. Alex Aiken. Before Stanford, he graduated with a B.Tech. from IIT Delhi. His research interests include program analysis, compilers, machine learning, and secure cloud computing.</bio>
        <homepage_url>http://cs.stanford.edu/people/sharmar</homepage_url>
        <picture_url>http://pldi17.sigplan.org/getProfileImage/rahulsharma/6d60eca8-356f-4141-af5d-4c6af0fadcd8/small.jpg</picture_url>
      </person>
      <person>
        <role>Committee Member in Artifact Evaluation Committee</role>
        <sort_key>123</sort_key>
        <first_name>August</first_name>
        <last_name>Shi</last_name>
        <affiliation>University of Illinois at Urbana-Champaign</affiliation>
        <bio>undefined</bio>
        <homepage_url>http://mir.cs.illinois.edu/awshi2/</homepage_url>
      </person>
      <person>
        <role>Committee Member in Program Committee</role>
        <sort_key>124</sort_key>
        <first_name>Sharon</first_name>
        <last_name>Shoham</last_name>
        <affiliation>Tel Aviv university</affiliation>
        <bio>undefined</bio>
        <homepage_url>http://www.tau.ac.il/~sharonshoham/</homepage_url>
        <picture_url>http://pldi17.sigplan.org/getProfileImage/sharonshoham/52ca243a-805e-43b9-9f5a-bd1bae25fccb/small.jpg</picture_url>
      </person>
      <person>
        <role>Committee Member in Program Committee</role>
        <sort_key>125</sort_key>
        <first_name>Alexandra</first_name>
        <last_name>Silva</last_name>
        <affiliation>University College London</affiliation>
        <bio>undefined</bio>
        <homepage_url>http://www.alexandrasilva.org/</homepage_url>
        <picture_url>http://pldi17.sigplan.org/getProfileImage/alexandrasilva/4b4137d3-8abf-423d-89b7-64b1a17139a5/small.jpg</picture_url>
      </person>
      <person>
        <role>Committee Member in Program Committee</role>
        <sort_key>126</sort_key>
        <first_name>Rishabh</first_name>
        <last_name>Singh</last_name>
        <affiliation>Microsoft Research</affiliation>
        <bio>Rishabh Singh is a researcher at Microsoft Research, Redmond. His research interests span the areas of programming languages, formal methods, and machine learning. His recent work has focused on building systems based on program synthesis for making programming accessible to end-users and students. He obtained his PhD in Computer Science from MIT in 2014, and was awarded the MIT’s George M. Sprowls Award for Best PhD Dissertation in Computer Science. He was a Microsoft Research PhD fellow and winner of MIT’s William A. Martin Outstanding Master’s thesis Award. He obtained his BTech in Computer Science from IIT Kharagpur in 2008, where he was awarded the Institute Silver Medal and Bigyan Sinha Memorial Award.</bio>
        <homepage_url>http://people.csail.mit.edu/rishabh/website/</homepage_url>
        <picture_url>http://pldi17.sigplan.org/getProfileImage/rishabhsingh/4a1b1d69-0e64-4fe5-bce3-055fdeb94b32/small.jpg</picture_url>
      </person>
      <person>
        <role>Committee Member in External Program Committee</role>
        <sort_key>127</sort_key>
        <first_name>Armando</first_name>
        <last_name>Solar-Lezama</last_name>
        <affiliation>MIT CSAIL</affiliation>
        <bio>undefined</bio>
        <picture_url>http://pldi17.sigplan.org/getProfileImage/armandosolarlezama/7befe52d-6968-4786-9841-408800f80c71/small.jpg</picture_url>
      </person>
      <person>
        <role>Committee Member in External Review Committee</role>
        <sort_key>128</sort_key>
        <first_name>Manu</first_name>
        <last_name>Sridharan</last_name>
        <affiliation>Uber</affiliation>
        <bio>undefined</bio>
        <homepage_url>http://manu.sridharan.net</homepage_url>
        <picture_url>http://pldi17.sigplan.org/getProfileImage/manusridharan/00859147-2155-45a9-9a48-7565ce5356ac/small.jpg</picture_url>
      </person>
      <person>
        <role>Committee Member in External Program Committee</role>
        <sort_key>129</sort_key>
        <first_name>Guy L.</first_name>
        <last_name>Steele Jr.</last_name>
        <affiliation>Oracle Labs</affiliation>
        <bio>Guy L. Steele Jr. (A.B., 1975, Harvard College; S.M., 1977, and Ph.D., 1980, MIT) is a Software Architect at Oracle Labs. He has taught at Carnegie-Mellon University, and worked for Tartan Laboratories, Thinking Machines Corporation, and Sun Microsystems.
He is author or co-author of five books: Common Lisp: The Language, C: A Reference Manual, The Hacker’s Dictionary, The High Performance Fortran Handbook, and The Java Language Specification. He has published more than two dozen papers on the subject of the Lisp language and Lisp implementation, including a series with Gerald Jay Sussman that defined the Scheme dialect of Lisp. His paper “Data Parallel Algorithms” with W. Daniel Hillis (December 1986) has been cited more than 1100 times.
He has been given the Grace Murray Hopper Award (1988), the ACM SIGPLAN Programming Languages Achievement Award (1996), and the Harry H. Goode Memorial Award (2007). He is an ACM Fellow, IEEE Fellow, Fellow of the American Academy of Arts and Sciences, and a Member of the National Academy of Engineering of the United States of America.
He has served on accredited standards committees X3J11 (C language) and X3J3 (Fortran), and served as chairman of X3J13 (Common Lisp). He was also a member of the IEEE committee that produced the IEEE Standard for the Scheme Programming Language, IEEE Std 1178-1990. At Thinking Machines Corporation he co-developed the languages Connection Machine Lisp, C*, and Connection Machine Fortran. At Sun Microsystems (and now at Oracle) he has advised the evolution of the Java programming language; he also led the design of Fortress, an object-oriented mathematical language intended to support high-performance computing. He designed the original EMACS command set and was the first person to port TeX.
He is a member of Tech Squares, the Plus-level Modern Western Square Dance club at MIT, and a square dance caller (currently Mainstream through C3A). At SPLASH 2011 he gave a presentation and demonstration on the structure of square-dance singing calls.
At Oracle labs, he is responsible for research in language design and implementation strategies, and architectural and software support for programming languages.</bio>
        <homepage_url>https://labs.oracle.com/pls/apex/f?p=labs:bio:0:120</homepage_url>
        <picture_url>http://pldi17.sigplan.org/getProfileImage/guylsteelejr/9c36bdda-9de1-43c9-a239-3143cf32ae57/small.jpg</picture_url>
      </person>
      <person>
        <role>Committee Member in Artifact Evaluation Committee</role>
        <sort_key>130</sort_key>
        <first_name>Chengnian</first_name>
        <last_name>Sun</last_name>
        <affiliation>University of California, Davis</affiliation>
        <bio>undefined</bio>
        <homepage_url>http://chengniansun.bitbucket.org/</homepage_url>
        <picture_url>http://pldi17.sigplan.org/getProfileImage/chengniansun/c172ce7d-3932-4fba-979d-8526fa38562d/small.jpg</picture_url>
      </person>
      <person>
        <role>Committee Member in Program Committee</role>
        <sort_key>131</sort_key>
        <first_name>Charles</first_name>
        <last_name>Sutton</last_name>
        <affiliation>University of Edinburgh</affiliation>
        <bio>Charles Sutton is a Reader (equivalent to Associate Professor: http://bit.ly/1W9UhqT) in Machine Learning at the University of Edinburgh. He is interested in a broad range of applications of probabilistic machine learning, including NLP, analysis of computer systems, software engineering, sustainable energy, and exploratory data analysis. His work in software engineering has won an ACM Distinguished Paper Award. His PhD is from the University of Massachusetts Amherst, and he has done postdoctoral work at the University of California Berkeley. He is currently Director of the EPSRC Centre for Doctoral Training in Data Science at the University of Edinburgh, and a Faculty Fellow of the Alan Turing Institute.</bio>
        <homepage_url>http://homepages.inf.ed.ac.uk/csutton/</homepage_url>
        <picture_url>http://pldi17.sigplan.org/getProfileImage/charlessutton/989c5bc2-7291-4058-9b50-518b6e04d87b/small.jpg</picture_url>
      </person>
      <person>
        <role>Committee Member in External Review Committee</role>
        <sort_key>132</sort_key>
        <first_name>Daniel</first_name>
        <last_name>Tarlow</last_name>
        <affiliation>Microsoft Research</affiliation>
        <bio>undefined</bio>
        <homepage_url>http://www.cs.toronto.edu/~dtarlow</homepage_url>
        <picture_url>http://pldi17.sigplan.org/getProfileImage/danieltarlow/b3bc10ac-bad9-4749-a468-45b729d808c0/small.jpg</picture_url>
      </person>
      <person>
        <role>Committee Member in Steering Committee</role>
        <sort_key>133</sort_key>
        <first_name>Peter</first_name>
        <last_name>Thiemann</last_name>
        <affiliation>University of Freiburg</affiliation>
        <bio>undefined</bio>
        <homepage_url>http://www2.informatik.uni-freiburg.de/~thiemann/</homepage_url>
        <picture_url>http://pldi17.sigplan.org/getProfileImage/peterthiemann/394bf793-130b-4bb2-916d-e7409f4e7101/small.jpg</picture_url>
      </person>
      <person>
        <role>Committee Member in External Review Committee</role>
        <sort_key>134</sort_key>
        <first_name>Petar</first_name>
        <last_name>Tsankov</last_name>
        <affiliation>ETH Zurich</affiliation>
        <bio>undefined</bio>
        <homepage_url>http://www.ptsankov.com</homepage_url>
        <picture_url>http://pldi17.sigplan.org/getProfileImage/petartsankov/51619f3f-cdb0-4030-b07f-5ba4727b5800/small.jpg</picture_url>
      </person>
      <person>
        <role>Committee Member in External Review Committee</role>
        <sort_key>135</sort_key>
        <first_name>Laurent</first_name>
        <last_name>Vanbever</last_name>
        <affiliation>ETH Zürich</affiliation>
        <bio>Assistant Professor @ETH Z&amp;uuml;rich</bio>
        <homepage_url>http://www.vanbever.eu</homepage_url>
        <picture_url>http://pldi17.sigplan.org/getProfileImage/laurentvanbever/63273a1c-d37d-4f95-9c45-e0b9999fcda8/small.jpg</picture_url>
      </person>
      <person>
        <role>Committee Member in External Review Committee</role>
        <sort_key>136</sort_key>
        <first_name>John</first_name>
        <last_name>Vilk</last_name>
        <affiliation>University of Massachusetts, Amherst</affiliation>
        <bio>undefined</bio>
        <homepage_url>https://jvilk.com</homepage_url>
        <picture_url>http://pldi17.sigplan.org/getProfileImage/johnvilk/35178945-535d-47c1-99cc-9dcc7f03ed60/small.jpg</picture_url>
      </person>
      <person>
        <role>Committee Member in Steering Committee</role>
        <sort_key>137</sort_key>
        <first_name>Jan</first_name>
        <last_name>Vitek</last_name>
        <affiliation>Northeastern University</affiliation>
        <bio>Jan Vitek is a Professor of Computer Science at Northeastern University. Dr. Vitek was born in Czechoslovakia and educated in Switzerland. Over the years, he worked on topics related to programming languages, their design, use, and implementation. With Noble and Potter, he proposed the notion of flexible alias control which became know as Ownership Types. He led the Ovm project which produced the first real-time Java virtual machine to be flight tested on a ScanEagle drone (he claims no one was harmed). Outcomes of this project include the Schism real-time garbage collector and the FijiVM – a production VM for embedded systems. More recently, he worked on dynamic languages, trying to make sense of JavaScript and to design a new language called, Thorn. Nowadays, he spends his time with statisticians and data scientists. Jan believes that his 2012 election as Chair of SIGPLAN was an accident; since has been busy trying to rock the boat to ensure this does not happen again. In his spare time, Jan enjoys organizing conferences and sitting on PCs (over 25 in the last decade). He founded the MOS (mobile objects), IWACO (alias control), STOP (gradual typing), and TRANSACT (transactional memory) workshop series. He was the first program chair of VEE and chaired ESOP, ECOOP, Coordination and TOOLS. He was the general chair of PLDI (in Beijing!), ISMM and LCTES. He may still be sitting on the steering committees of ECOOP, JTRES, ICFP, OOPLSA, POPL, PLDI, LCTES, ESOP.</bio>
        <homepage_url>http://janvitek.org</homepage_url>
        <picture_url>http://pldi17.sigplan.org/getProfileImage/janvitek/2abf0813-573d-4e7b-9f74-b96e912694a0/small.jpg</picture_url>
      </person>
      <person>
        <role>Committee Member in Steering Committee</role>
        <sort_key>138</sort_key>
        <first_name>Philip</first_name>
        <last_name>Wadler</last_name>
        <affiliation>University of Edinburgh</affiliation>
        <bio>Philip Wadler is Professor of Theoretical Computer Science at the University of Edinburgh. He is an ACM Fellow and a Fellow of the Royal Society of Edinburgh, past chair of ACM SIGPLAN, past holder of a Royal Society-Wolfson Research Merit Fellowship, winner of the SIGPLAN Distinguished Service Award, and a winner of the POPL Most Influential Paper Award. Previously, he worked or studied at Stanford, Xerox Parc, CMU, Oxford, Chalmers, Glasgow, Bell Labs, and Avaya Labs, and visited as a guest professor in Copenhagen, Sydney, and Paris. He has an h-index of 60, with more than 20,000 citations to his work according to Google Scholar. He contributed to the designs of Haskell, Java, and XQuery, and is a co-author of Introduction to Functional Programming (Prentice Hall, 1988), XQuery from the Experts (Addison Wesley, 2004) and Generics and Collections in Java (O’Reilly, 2006). He has delivered invited talks in locations ranging from Aizu to Zurich.</bio>
        <homepage_url>http://homepages.inf.ed.ac.uk/wadler/</homepage_url>
        <picture_url>http://pldi17.sigplan.org/getProfileImage/philipwadler/55a9683e-908b-4052-9d49-20fb795c74cf/small.jpg</picture_url>
      </person>
      <person>
        <role>Committee Member in External Review Committee</role>
        <sort_key>139</sort_key>
        <first_name>David</first_name>
        <last_name>Walker</last_name>
        <affiliation>Princeton University</affiliation>
        <bio>undefined</bio>
        <homepage_url>http://www.cs.princeton.edu/~dpw/</homepage_url>
        <picture_url>http://pldi17.sigplan.org/getProfileImage/davidwalker/8763137a-03a5-4963-8639-e9f2a3cc8ac9/small.jpg</picture_url>
      </person>
      <person>
        <role>Committee Member in Program Committee</role>
        <sort_key>140</sort_key>
        <first_name>Eran</first_name>
        <last_name>Yahav</last_name>
        <affiliation>Technion</affiliation>
        <bio>undefined</bio>
        <homepage_url>http://www.cs.technion.ac.il/~yahave/</homepage_url>
        <picture_url>http://pldi17.sigplan.org/getProfileImage/eranyahav/e77d8b4b-d267-4659-969c-6542a0d385b3/small.jpg</picture_url>
      </person>
      <person>
        <role>Committee Member in External Program Committee</role>
        <sort_key>141</sort_key>
        <first_name>Hongseok</first_name>
        <last_name>Yang</last_name>
        <affiliation>University of Oxford</affiliation>
        <bio>undefined</bio>
        <homepage_url>http://www.cs.ox.ac.uk/people/hongseok.yang/Public/Home.html</homepage_url>
        <picture_url>http://pldi17.sigplan.org/getProfileImage/hongseokyang/852e33b1-6c2a-41bf-9e12-cccadbf70d70/small.jpg</picture_url>
      </person>
      <person>
        <role>Committee Member in Program Committee</role>
        <sort_key>142</sort_key>
        <first_name>Junfeng</first_name>
        <last_name>Yang</last_name>
        <affiliation>Columbia University</affiliation>
        <bio>undefined</bio>
        <picture_url>http://pldi17.sigplan.org/getProfileImage/junfengyang/85c93971-4dd9-410a-a38a-1d875b941a8a/small.jpg</picture_url>
      </person>
      <person>
        <role>Committee Member in Artifact Evaluation Committee</role>
        <sort_key>143</sort_key>
        <first_name>Qiuping</first_name>
        <last_name>Yi</last_name>
        <affiliation>Texas A&amp;M University</affiliation>
        <bio>undefined</bio>
        <homepage_url>https://sites.google.com/site/yiqiuping/home</homepage_url>
        <picture_url>http://pldi17.sigplan.org/getProfileImage/qiupingyi/0ecb13cb-e404-49d5-980b-b1db9ba8367d/small.jpg</picture_url>
      </person>
      <person>
        <role>Committee Member in External Review Committee</role>
        <sort_key>144</sort_key>
        <first_name>Jaeheon</first_name>
        <last_name>Yi</last_name>
        <affiliation>Google</affiliation>
        <bio>undefined</bio>
        <picture_url>http://pldi17.sigplan.org/getProfileImage/jaeheonyi/ed75dcd8-3055-4727-8f33-2f9b9b5fb737/small.jpg</picture_url>
      </person>
      <person>
        <role>Committee Member in External Review Committee</role>
        <sort_key>145</sort_key>
        <first_name>Kwangkeun</first_name>
        <last_name>Yi</last_name>
        <affiliation>Seoul National University</affiliation>
        <bio>undefined</bio>
        <homepage_url>http://kwangkeunyi.snu.ac.kr</homepage_url>
        <picture_url>http://pldi17.sigplan.org/getProfileImage/kwangkeunyi/cf1603f7-9a87-4f8c-8403-50164aaf72b5/small.jpg</picture_url>
      </person>
      <person>
        <role>Committee Member in Artifact Evaluation Committee</role>
        <sort_key>146</sort_key>
        <first_name>Adarsh</first_name>
        <last_name>Yoga</last_name>
        <affiliation>Rutgers University, USA</affiliation>
        <bio>undefined</bio>
        <homepage_url>http://paul.rutgers.edu/~ay195/</homepage_url>
      </person>
      <person>
        <role>Committee Member in External Review Committee</role>
        <sort_key>147</sort_key>
        <first_name>Ayal</first_name>
        <last_name>Zaks</last_name>
        <affiliation>Intel and Technion, Israel</affiliation>
        <bio>undefined</bio>
        <homepage_url>http://azaks.eew.technion.ac.il/</homepage_url>
        <picture_url>http://pldi17.sigplan.org/getProfileImage/ayalzaks/471b94d3-b3f6-435a-b6b2-fabee88b9b46/small.jpg</picture_url>
      </person>
      <person>
        <role>Committee Member in External Program Committee</role>
        <sort_key>148</sort_key>
        <first_name>Steve</first_name>
        <last_name>Zdancewic</last_name>
        <affiliation>University of Pennsylvania</affiliation>
        <bio>undefined</bio>
        <homepage_url>http://www.cis.upenn.edu/~stevez</homepage_url>
        <picture_url>http://pldi17.sigplan.org/getProfileImage/stevezdancewic/41b883c6-4689-4ae3-b6f1-6b7a24622e99/small.jpg</picture_url>
      </person>
      <person>
        <role>Committee Member in Program Committee</role>
        <sort_key>149</sort_key>
        <first_name>Andreas</first_name>
        <last_name>Zeller</last_name>
        <affiliation>Saarland University</affiliation>
        <bio>Andreas Zeller is a full professor for Software Engineering at Saarland University in Saarbr&amp;uuml;cken, Germany. His research concerns the analysis of complex software systems, their security properties, and their development process. His students are funded by companies like Google, Microsoft, or SAP. In 2010, Zeller was inducted as Fellow of the ACM for his contributions to automated debugging and mining software archives. In 2011, he received an ERC Advanced Grant, Europe’s highest and most prestigious individual research grant, for work on specification mining and test case generation. In 2013, he co-founded Testfabrik AG, a start-up for automatic testing of Web applications.</bio>
        <homepage_url>https://www.st.cs.uni-saarland.de/zeller/</homepage_url>
        <picture_url>http://pldi17.sigplan.org/getProfileImage/andreaszeller/97477051-71fe-40c4-8571-c2b68cee3129/small.jpg</picture_url>
      </person>
      <person>
        <role>Committee Member in Artifact Evaluation Committee</role>
        <sort_key>150</sort_key>
        <first_name>Minjia</first_name>
        <last_name>Zhang</last_name>
        <affiliation>Microsoft Research</affiliation>
        <bio>undefined</bio>
        <homepage_url>http://zhangminjia.me</homepage_url>
        <picture_url>http://pldi17.sigplan.org/getProfileImage/minjiazhang1/e1a7348e-3480-439b-a1b5-28f6a3d2cffd/small.jpg</picture_url>
      </person>
      <person>
        <role>Committee Member in Artifact Evaluation Committee</role>
        <sort_key>151</sort_key>
        <first_name>Qirun</first_name>
        <last_name>Zhang</last_name>
        <affiliation>University of California, Davis</affiliation>
        <bio>undefined</bio>
        <homepage_url>http://helloqirun.github.io/</homepage_url>
      </person>
      <person>
        <role>Committee Member in External Review Committee</role>
        <sort_key>152</sort_key>
        <first_name>Xin</first_name>
        <last_name>Zhang</last_name>
        <affiliation>Georgia Tech</affiliation>
        <bio>undefined</bio>
        <homepage_url>http://www.cc.gatech.edu/~xzhang36/</homepage_url>
        <picture_url>http://pldi17.sigplan.org/getProfileImage/xinzhang/a4dbba61-3d43-4702-818f-94cad593fbec/small.jpg</picture_url>
      </person>
      <person>
        <role>Committee Member in External Review Committee</role>
        <sort_key>153</sort_key>
        <first_name>Xiangyu</first_name>
        <last_name>Zhang</last_name>
        <affiliation>Purdue University</affiliation>
        <bio>undefined</bio>
        <homepage_url>https://www.cs.purdue.edu/homes/xyzhang/</homepage_url>
        <picture_url>http://pldi17.sigplan.org/getProfileImage/xiangyuzhang/57d4d88e-c02e-41fc-836c-0e22cdf6b3b8/small.jpg</picture_url>
      </person>
      <person>
        <role>Publicity Chair in Organizing Committee</role>
        <sort_key>154</sort_key>
        <first_name>Adrian</first_name>
        <last_name>Sampson</last_name>
        <affiliation>Cornell University</affiliation>
        <bio>undefined</bio>
        <homepage_url>http://adriansampson.net/</homepage_url>
        <picture_url>http://pldi17.sigplan.org/getProfileImage/adriansampson/adaa9202-3352-4410-b03a-1eb4718543d5/small.jpg</picture_url>
      </person>
      <person>
        <role>Web Chair in Organizing Committee</role>
        <sort_key>155</sort_key>
        <first_name>Oleksandr</first_name>
        <last_name>Zinenko</last_name>
        <affiliation>Inria</affiliation>
        <bio>undefined</bio>
        <homepage_url>https://www.ozinenko.com</homepage_url>
        <picture_url>http://pldi17.sigplan.org/getProfileImage/oleksandrzinenko/fad5d61a-12cc-433b-b8bb-4fd43bac8ff0/small.jpg</picture_url>
      </person>
      <person>
        <role>Financial Chair in Organizing Committee</role>
        <sort_key>156</sort_key>
        <first_name>Louis-Noel</first_name>
        <last_name>Pouchet</last_name>
        <affiliation>Colorado State University</affiliation>
        <bio>Dr. Louis-Noel Pouchet is an Assistant Professor at Colorado State University. He is working on pattern-specific languages and compilers for scientific computing, and has designed numerous approaches using optimizing compilation to effectively map applications to CPUs, FPGAs and SoCs. His work spans a variety of domains, including compiler optimization, hardware synthesis, machine learning, programming languages, and distributed computing. His research is currently funded by the National Science Foundation, the Department of Energy, and Intel. Previously he has been a Visiting Assistant Professor (2012-2014) at the University of California Los Angeles, where he was a member of the NSF Center for Domain-Specific Computing, working on both software and hardware customization. He is the author of the PolyOpt and PoCC compilers, and of the PolyBench benchmarking suite.</bio>
        <picture_url>http://pldi17.sigplan.org/getProfileImage/louisnoelpouchet/f188f02e-a0a8-47b7-ac85-dc77315466db/small.jpg</picture_url>
      </person>
      <person>
        <role>1' of Fame Chair in Organizing Committee</role>
        <sort_key>157</sort_key>
        <first_name>Zheng</first_name>
        <last_name>Wang</last_name>
        <affiliation>Lancaster University</affiliation>
        <bio>undefined</bio>
        <homepage_url>http://www.lancaster.ac.uk/staff/wangz3/</homepage_url>
        <picture_url>http://pldi17.sigplan.org/getProfileImage/zhengwang/9f51ef64-4f51-41e2-8d62-4a954783d991/small.jpg</picture_url>
      </person>
      <person>
        <role>Workshops and Tutorials Chair in Organizing Committee</role>
        <sort_key>158</sort_key>
        <first_name>Aaron</first_name>
        <last_name>Smith</last_name>
        <affiliation>undefined</affiliation>
        <bio>undefined</bio>
      </person>
      <person>
        <role>Video Chair in Organizing Committee</role>
        <sort_key>159</sort_key>
        <first_name>David</first_name>
        <last_name>Darais</last_name>
        <affiliation>University of Maryland</affiliation>
        <bio>undefined</bio>
        <homepage_url>http://david.darais.com</homepage_url>
        <picture_url>http://pldi17.sigplan.org/getProfileImage/daviddarais/84b89731-ca3c-4d97-9540-4ce4db09d1d1/small.jpg</picture_url>
      </person>
      <person>
        <role>Student Travel Co-Chair in Organizing Committee</role>
        <sort_key>160</sort_key>
        <first_name>Ronald</first_name>
        <last_name>Mak</last_name>
        <affiliation>San Jose State University</affiliation>
        <bio>undefined</bio>
        <picture_url>http://pldi17.sigplan.org/getProfileImage/ronaldmak/a66c649a-deb8-4018-9b4e-a4dd77011191/small.jpg</picture_url>
      </person>
      <person>
        <role>Publications Chair in Organizing Committee</role>
        <sort_key>161</sort_key>
        <first_name>Philippe</first_name>
        <last_name>Suter</last_name>
        <affiliation>Two Sigma</affiliation>
        <bio>undefined</bio>
        <homepage_url>https://psuter.net/</homepage_url>
        <picture_url>http://pldi17.sigplan.org/getProfileImage/philippesuter/6fb6d5c9-8681-4d6a-8fa5-0c273b10910b/small.jpg</picture_url>
      </person>
      <person>
        <role>Student Volunteer Co-Chair in Organizing Committee</role>
        <sort_key>162</sort_key>
        <first_name>Robert</first_name>
        <last_name>Clarisó</last_name>
        <affiliation>Universitat Oberta de Catalunya</affiliation>
        <bio>BSc in Computer Science from UPC-Barcelona Tech (2000) as the top of his class. Special mention in the Spanish National University Degree Awards (Premios Nacionales de Fin de Carrera de Educaci&amp;oacute;n Universitaria, 2000).
PhD in Computer Science from UPC-Barcelona Tech (2005). His PhD thesis, titled “ Abstract Interpretation Techniques for the Verification of Timed Systems”, was directed by Dr. Jordi Cortadella Fortuny.
Between 2000 and 2002, he worked as a researcher at UPC in a project financed by the company Cadence Design Systems. In 2011, he worked in a 3-month research internship at Cadence Berkeley Labs (Berkeley, California). Between 2002 and 2005, he continued his research with an predoctoral grant from the Spanish Ministry of Science (FPU, Formaci&amp;oacute;n de Profesorado Universitario).
In 2005, he joined Universitat Oberta de Catalunya as a lecturer. In 2006 he worked as a part-time associate professor at UPC-Barcelona Tech and, between 2006 and 2011, at the Universitat Aut&amp;ograve;noma de Barcelona. His lectures focus on the following topics: automata theory, compilers, algorithms and data structures, graph theory and undergraduate thesis. Regarding research, he continues his research on formal methods applied to software engineering, first as the coordinator of the Research Group on Software Engineering at UOC (GRES-UOC, 2008-2015) and currently as a member of the SOM Research Lab.
Since 2008, he coordinated undergraduate thesis at the bachelor level in the IT, Multimedia and Telecommunication Department. Between 2008 and 2011, he was the Academic Director of postgraduate courses in this Department. Since 2011, he is the Academic Director of the Official Master in Computing Engineering.</bio>
        <homepage_url>http://w.uoc.edu/robert-clariso/EN</homepage_url>
        <picture_url>http://pldi17.sigplan.org/getProfileImage/robertclariso/d4e7ba7d-c4d3-44c6-af9e-17032cea8244/small.jpg</picture_url>
      </person>
      <person>
        <role>Student Volunteer Co-Chair in Organizing Committee</role>
        <sort_key>163</sort_key>
        <first_name>Olivier</first_name>
        <last_name>Fluckiger</last_name>
        <affiliation>Northeastern University</affiliation>
        <bio>undefined</bio>
      </person>
      <person>
        <role>Student Volunteer Co-Chair in Organizing Committee</role>
        <sort_key>164</sort_key>
        <first_name>Elvira</first_name>
        <last_name>Pino</last_name>
        <affiliation>Dept. of Computer Science UPC</affiliation>
        <bio>undefined</bio>
        <picture_url>http://pldi17.sigplan.org/getProfileImage/elvirapino/19ee18f9-7f87-4ea2-ae01-49ce4d84f6ea/small.jpg</picture_url>
      </person>
    </persons>
  </event_details>
  <subevent>
    <subevent_id>efddfc13-7e0f-442f-96e0-cf197216e4f4</subevent_id>
    <title>WCIRE 2017: WCIRE</title>
    <subevent_type type="regular"/>
    <room>PLDI-C</room>
    <date>2017/06/23</date>
    <url>http://pldi17.sigplan.org/track/WCIRE-2017-2-papers</url>
    <url_link_display>WCIRE 2017</url_link_display>
    <tracks>
      <track>WCIRE 2017</track>
    </tracks>
    <timeslot>
      <slot_id>8794142e-7c71-4d2c-a37f-a0e02326d3db</slot_id>
      <title>Peeking into a polyhedral compiler through the Periscop toolkit</title>
      <room>PLDI-C</room>
      <date>2017/06/23</date>
      <start_time>11:20</start_time>
      <end_time>12:10</end_time>
      <description>Optimizing compilers often operate as black-boxes offering little control over the optimization process. This is largely due to the complexity of the program modifications required to achieve decent performance. The polyhedral model—the core of advanced loop-level transformations—is notoriously complex: it operates on an abstract mathematical representation of the program rather than on a syntactic one. The Periscop toolkit[1] enables interaction with a polyhedral compiler using syntactic rather than polyhedral terms. It decomposes automatically computed transformations into sequences of well-understood syntactic steps. These sequences can be analyzed, reused or modified on demand while the polyhedral engine generates the final code and ensures semantics preservation. The Periscop toolkit features a collection of tools for program transformation and analysis that use only the basic Unix compiler technology and therefore is easily adaptable. Its applications span from new language constructs[2] to visual tools[3,4] for analyzing and explaining polyhedral constructs.
[1] https://periscop.github.io [2] https://team.inria.fr/camus/ibb/ [3] https://ozinenko.com/clint [4] http://playground.pollylabs.org</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Oleksandr</first_name>
          <last_name>Zinenko</last_name>
          <affiliation>Inria</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.ozinenko.com</homepage_url>
          <picture_url>http://pldi17.sigplan.org/getProfileImage/oleksandrzinenko/fad5d61a-12cc-433b-b8bb-4fd43bac8ff0/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>WCIRE 2017</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>93fba4f9-8844-4391-b09f-f537badee074</slot_id>
      <title>Opening Remarks</title>
      <room>PLDI-C</room>
      <date>2017/06/23</date>
      <start_time>09:00</start_time>
      <end_time>09:10</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Louis-Noel</first_name>
          <last_name>Pouchet</last_name>
          <affiliation>Colorado State University</affiliation>
          <bio>Dr. Louis-Noel Pouchet is an Assistant Professor at Colorado State University. He is working on pattern-specific languages and compilers for scientific computing, and has designed numerous approaches using optimizing compilation to effectively map applications to CPUs, FPGAs and SoCs. His work spans a variety of domains, including compiler optimization, hardware synthesis, machine learning, programming languages, and distributed computing. His research is currently funded by the National Science Foundation, the Department of Energy, and Intel. Previously he has been a Visiting Assistant Professor (2012-2014) at the University of California Los Angeles, where he was a member of the NSF Center for Domain-Specific Computing, working on both software and hardware customization. He is the author of the PolyOpt and PoCC compilers, and of the PolyBench benchmarking suite.</bio>
          <picture_url>http://pldi17.sigplan.org/getProfileImage/louisnoelpouchet/f188f02e-a0a8-47b7-ac85-dc77315466db/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Milind</first_name>
          <last_name>Kulkarni</last_name>
          <affiliation>Purdue University</affiliation>
          <bio>I am an associate professor with the School of Electrical and Computer Engineering at Purdue University.
My research area is Programming Languages and Compilers, and my interests lie specifically in developing languages, compilers and runtimes that support efficient programming and high performance on emerging complex architectures.
I graduated in 2002 with a B.S. in both Computer Science and Computer Engineering from North Carolina State University. I received my Ph.D. in Computer Science from Cornell University. My advisor was Keshav Pingali. While pursuing my Ph.D., I was supported by a Department of Energy High Performance Computer Science (HPCS) Fellowship. After receiving my Ph.D., I joined the Institute for Computational Sciences and Engineering at the University of Texas at Austin as a postdoc, where I worked with the Intelligent Software Systems (ISS) group. Since the fall of 2009, I have been in the School of Electrical and Computer Engineering at Purdue University.</bio>
          <homepage_url>https://engineering.purdue.edu/~milind/</homepage_url>
          <picture_url>http://pldi17.sigplan.org/getProfileImage/milindkulkarni/879b2ea0-ca46-4c89-82d2-fdc7efd15943/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Samuel</first_name>
          <last_name>Midkiff</last_name>
          <affiliation>School of Electrical and Computer Engineering, Purdue University</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>WCIRE 2017</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>bf652e74-551b-4d86-aee2-fa9010265498</slot_id>
      <title>Open Discussion: Building Infrastructure for Research and Education</title>
      <room>PLDI-C</room>
      <date>2017/06/23</date>
      <start_time>15:50</start_time>
      <end_time>16:30</end_time>
      <description>Open discussion on developing compiler infrastructure for use in research and education.</description>
      <persons>
        <person>
          <role>Moderator</role>
          <sort_key>1</sort_key>
          <first_name>Milind</first_name>
          <last_name>Kulkarni</last_name>
          <affiliation>Purdue University</affiliation>
          <bio>I am an associate professor with the School of Electrical and Computer Engineering at Purdue University.
My research area is Programming Languages and Compilers, and my interests lie specifically in developing languages, compilers and runtimes that support efficient programming and high performance on emerging complex architectures.
I graduated in 2002 with a B.S. in both Computer Science and Computer Engineering from North Carolina State University. I received my Ph.D. in Computer Science from Cornell University. My advisor was Keshav Pingali. While pursuing my Ph.D., I was supported by a Department of Energy High Performance Computer Science (HPCS) Fellowship. After receiving my Ph.D., I joined the Institute for Computational Sciences and Engineering at the University of Texas at Austin as a postdoc, where I worked with the Intelligent Software Systems (ISS) group. Since the fall of 2009, I have been in the School of Electrical and Computer Engineering at Purdue University.</bio>
          <homepage_url>https://engineering.purdue.edu/~milind/</homepage_url>
          <picture_url>http://pldi17.sigplan.org/getProfileImage/milindkulkarni/879b2ea0-ca46-4c89-82d2-fdc7efd15943/small.jpg</picture_url>
        </person>
        <person>
          <role>Moderator</role>
          <sort_key>2</sort_key>
          <first_name>Samuel</first_name>
          <last_name>Midkiff</last_name>
          <affiliation>School of Electrical and Computer Engineering, Purdue University</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Moderator</role>
          <sort_key>3</sort_key>
          <first_name>Louis-Noel</first_name>
          <last_name>Pouchet</last_name>
          <affiliation>Colorado State University</affiliation>
          <bio>Dr. Louis-Noel Pouchet is an Assistant Professor at Colorado State University. He is working on pattern-specific languages and compilers for scientific computing, and has designed numerous approaches using optimizing compilation to effectively map applications to CPUs, FPGAs and SoCs. His work spans a variety of domains, including compiler optimization, hardware synthesis, machine learning, programming languages, and distributed computing. His research is currently funded by the National Science Foundation, the Department of Energy, and Intel. Previously he has been a Visiting Assistant Professor (2012-2014) at the University of California Los Angeles, where he was a member of the NSF Center for Domain-Specific Computing, working on both software and hardware customization. He is the author of the PolyOpt and PoCC compilers, and of the PolyBench benchmarking suite.</bio>
          <picture_url>http://pldi17.sigplan.org/getProfileImage/louisnoelpouchet/f188f02e-a0a8-47b7-ac85-dc77315466db/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>WCIRE 2017</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>daf259da-2d16-4f4d-b554-458ce15b0586</slot_id>
      <title>Polyhedral Compilation and Accelerator Programming with PENCIL and PPCG</title>
      <room>PLDI-C</room>
      <date>2017/06/23</date>
      <start_time>14:30</start_time>
      <end_time>15:20</end_time>
      <description>Programming accelerators such as GPUs with low-level APIs and languages such as OpenCL and CUDA is difficult, error-prone, and not performance portable. Automatic parallelization and domain-specific languages (DSLs) have been proposed to hide complexity and regain performance portability. We present PENCIL, a platform-neutral intermediate language for accelerator programming and PPCG, a PENCIL-to-OpenCL/CUDA compiler using state-of-the-art polyhedral techniques. PENCIL is a rigorously-defined subset of GNU C99, enriched with additional language constructs, that enables compilers to exploit parallelism and produce highly optimized code when targeting accelerators. PENCIL aims to serve both as a portable implementation language for libraries, and as a target language for DSL compilers. PPCG is a source-to-source polyhedral compiler that extracts a highly efficient data parallel kernel for accelerators from a sequential PENCIL specification. The polyhedral compiler is extended to handle data-dependent control flow, non-affine array accesses, and interprocedural control flow. We present our experience of using PENCIL as an intermediate language for several DSLs including VOBLA (a DSL for basic linear algebra), SpearDE (a DSL for signal processing radar applications) as well as porting several large benchmarks such as SLAMBench, SHOC, Rodinia to PENCIL.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Chandan</first_name>
          <last_name>Reddy</last_name>
          <affiliation>INRIA</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>WCIRE 2017</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>eecc0f44-867b-4ee0-8568-170c70b9c7b8</slot_id>
      <title>The Spoofax Language Workbench</title>
      <room>PLDI-C</room>
      <date>2017/06/23</date>
      <start_time>10:30</start_time>
      <end_time>11:20</end_time>
      <description>TBD</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Eelco</first_name>
          <last_name>Visser</last_name>
          <affiliation>Delft University of Technology</affiliation>
          <bio>Eelco Visser is Antoni van Leeuwenhoek Professor of Computer Science at Delft University of Technology. He received a master’s and doctorate in computer science from the University of Amsterdam in 1993 and 1997, respectively. Previously he served as postdoc at the Oregon Graduate Institute, as Assistant Professor at Utrecht University, and as Associate Professor at TU Delft.
His research interests include programming languages, software language engineering, domain-specific programming languages, program transformation, software security, and interaction design. With his students he has designed and implemented the Spoofax language workbench, as well as many domain-specific languages, including DSLs for syntax definition (SDF2, SDF3), program transformation (Stratego), name binding (NaBL), dynamic semantics (DynSem), software deployment (Nix), web application development (WebDSL), and mobile phone applications (mobl). In the language designer’s workbench project he is pursuing high-level declarative language definition that serves for language implementation and verification.</bio>
          <homepage_url>http://eelcovisser.org</homepage_url>
          <picture_url>http://pldi17.sigplan.org/getProfileImage/eelcovisser/86691a18-0123-41d4-9bb6-433bb52aeed7/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>WCIRE 2017</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>eef74aaf-ce0c-4433-a266-54d46f1cbb2e</slot_id>
      <title>MPS</title>
      <room>PLDI-C</room>
      <date>2017/06/23</date>
      <start_time>13:40</start_time>
      <end_time>14:30</end_time>
      <description>MPS talk from JetBrains
https://www.jetbrains.com/mps/</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Oscar</first_name>
          <last_name>Rodriguez</last_name>
          <affiliation>JetBrains</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>WCIRE 2017</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>fa3b6af1-3640-4001-ac7a-630717c2cdf8</slot_id>
      <title>The ROSE Compiler Framework</title>
      <room>PLDI-C</room>
      <date>2017/06/23</date>
      <start_time>09:10</start_time>
      <end_time>10:00</end_time>
      <description>TBD</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Louis-Noel</first_name>
          <last_name>Pouchet</last_name>
          <affiliation>Colorado State University</affiliation>
          <bio>Dr. Louis-Noel Pouchet is an Assistant Professor at Colorado State University. He is working on pattern-specific languages and compilers for scientific computing, and has designed numerous approaches using optimizing compilation to effectively map applications to CPUs, FPGAs and SoCs. His work spans a variety of domains, including compiler optimization, hardware synthesis, machine learning, programming languages, and distributed computing. His research is currently funded by the National Science Foundation, the Department of Energy, and Intel. Previously he has been a Visiting Assistant Professor (2012-2014) at the University of California Los Angeles, where he was a member of the NSF Center for Domain-Specific Computing, working on both software and hardware customization. He is the author of the PolyOpt and PoCC compilers, and of the PolyBench benchmarking suite.</bio>
          <picture_url>http://pldi17.sigplan.org/getProfileImage/louisnoelpouchet/f188f02e-a0a8-47b7-ac85-dc77315466db/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>WCIRE 2017</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>d8e3cc09-2a01-4734-898e-2d86600fefcd</subevent_id>
    <title>Catering: Coffee Break</title>
    <subevent_type type="regular"/>
    <room>ISMM-CoffeeBreaks</room>
    <date>2017/06/18</date>
    <url>http://pldi17.sigplan.org/track/ismm-2017-catering</url>
    <url_link_display>Catering</url_link_display>
    <tracks>
      <track>Catering</track>
    </tracks>
    <timeslot>
      <slot_id>47082f39-b74e-4735-883b-e1841ae53a85</slot_id>
      <title>Break</title>
      <room>ISMM-CoffeeBreaks</room>
      <date>2017/06/18</date>
      <start_time>10:30</start_time>
      <end_time>11:00</end_time>
      <description>Break</description>
      <tracks>
        <track>Catering</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>14069fe0-ec02-4f73-bc03-30ba865819c0</subevent_id>
    <title>Catering: Coffee Break</title>
    <subevent_type type="regular"/>
    <room>ISMM-CoffeeBreaks</room>
    <date>2017/06/18</date>
    <url>http://pldi17.sigplan.org/track/ismm-2017-catering</url>
    <url_link_display>Catering</url_link_display>
    <tracks>
      <track>Catering</track>
    </tracks>
    <timeslot>
      <slot_id>81e8970b-74bc-4aa3-9ccf-e8611aa2e1ab</slot_id>
      <title>Break</title>
      <room>ISMM-CoffeeBreaks</room>
      <date>2017/06/18</date>
      <start_time>15:30</start_time>
      <end_time>16:00</end_time>
      <description>Break</description>
      <tracks>
        <track>Catering</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>10fe7654-b7ae-4bc1-b9f9-5fd90b59a2f4</subevent_id>
    <title>Catering: Lunch</title>
    <subevent_type type="regular"/>
    <room>ISMM-CoffeeBreaks</room>
    <date>2017/06/18</date>
    <url>http://pldi17.sigplan.org/track/ismm-2017-catering</url>
    <url_link_display>Catering</url_link_display>
    <tracks>
      <track>Catering</track>
    </tracks>
    <timeslot>
      <slot_id>7e0d6411-b4ea-4038-a83b-59c2009a447f</slot_id>
      <title>Lunch</title>
      <room>ISMM-CoffeeBreaks</room>
      <date>2017/06/18</date>
      <start_time>12:30</start_time>
      <end_time>14:00</end_time>
      <description>Lunch</description>
      <tracks>
        <track>Catering</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>69455f98-0cb7-49a6-b4bf-2b41843acee5</subevent_id>
    <title>DSW 2017: Academic hypervisor project; closing discussion</title>
    <subevent_type type="regular"/>
    <room>PLDI-C</room>
    <date>2017/06/22</date>
    <url>http://pldi17.sigplan.org/track/dsw-2017-papers</url>
    <url_link_display>Deep Specifications in the Wild 2017</url_link_display>
    <tracks>
      <track>Deep Specifications in the Wild 2017</track>
    </tracks>
    <timeslot>
      <slot_id>227dbdd7-724e-4c7a-bbb5-77696130c548</slot_id>
      <title>Closing discussion</title>
      <room>PLDI-C</room>
      <date>2017/06/22</date>
      <start_time>16:15</start_time>
      <end_time>17:00</end_time>
      <description>Details TBD</description>
      <tracks>
        <track>Deep Specifications in the Wild 2017</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>936449f0-c267-4923-b595-2ffc3db8f678</slot_id>
      <title>CertiKOS: A Breakthrough toward Hacker-Resistant Operating Systems</title>
      <room>PLDI-C</room>
      <date>2017/06/22</date>
      <start_time>15:30</start_time>
      <end_time>16:15</end_time>
      <description>Building certifiably hacker-resistant operating systems is widely considered a grand challenge. Many people believe that the combination of concurrency and an OS kernel’s functional complexity makes formal verification of functional correctness intractable, and even if it is possible, its cost would be prohibitive. In this talk, we present a novel compositional approach for building certified system software. We advocate abstraction over a particularly rich class of specification (called deep specification) and present new methodologies and tools for formally specifying, programming, verifying, and composing abstraction layers. Using these new technologies, we have successfully developed the CertiKOS certified OS kernel and verified its contextual functional correctness in the Coq proof assistant. CertiKOS is written in 6500 lines of C and x86 assembly and runs on stock x86 multicore machines. This is the world’s first proof of functional correctness of a complete, general-purpose concurrent OS kernel with fine-grained locking.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Zhong</first_name>
          <last_name>Shao</last_name>
          <affiliation>Yale University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.yale.edu/homes/shao/</homepage_url>
          <picture_url>http://pldi17.sigplan.org/getProfileImage/zhongshao/18a2973a-020f-46ed-9073-85bd70626116/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Deep Specifications in the Wild 2017</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>31738bb6-c2ae-49bc-8204-476c0fea7cbe</subevent_id>
    <title>DSW 2017: Academic crypto projects; industry perspective on formal-methods integration</title>
    <subevent_type type="regular"/>
    <room>PLDI-C</room>
    <date>2017/06/22</date>
    <url>http://pldi17.sigplan.org/track/dsw-2017-papers</url>
    <url_link_display>Deep Specifications in the Wild 2017</url_link_display>
    <tracks>
      <track>Deep Specifications in the Wild 2017</track>
    </tracks>
    <timeslot>
      <slot_id>9089d22b-0615-443a-80ad-3a4f295cd8fd</slot_id>
      <title>Introduction to verification using the VST</title>
      <room>PLDI-C</room>
      <date>2017/06/22</date>
      <start_time>11:00</start_time>
      <end_time>11:30</end_time>
      <description>The Verified Software Toolchain is a higher-order impredicative concurrent separation logic for C, proven sound in Coq w.r.t. CompCert Clight. The Floyd proof automation is a collection of definitions and proof tactics to support concrete program verification using forward symbolic execution. The talk will present a user-oriented introduction to the system, including outlines of a number of illustrative examples and case studies.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Lennart</first_name>
          <last_name>Beringer</last_name>
          <affiliation>Princeton University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.princeton.edu/~eberinge</homepage_url>
          <picture_url>http://pldi17.sigplan.org/getProfileImage/lennartberinger/8d7941ba-0ebb-43e7-a71e-11f1c3b01754/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Deep Specifications in the Wild 2017</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>bb06b7eb-3edd-4277-a7d0-2a5ae792459c</slot_id>
      <title>Using formal tools to develop high-assurance software for autonomous ground vehicles</title>
      <room>PLDI-C</room>
      <date>2017/06/22</date>
      <start_time>11:30</start_time>
      <end_time>12:10</end_time>
      <description>It is well understood that many cyber-physical systems incorporate software that is getting increasingly complex, hard to manage, and therefore often quite fragile. We will present our recent work on addressing this challenge using formal methods based tools and techniques for creation of software for cyber-physical systems that provide strong assurances that the resulting software would be secure, safe, and reliable. 
These include - the use of a formally verified operating system; - the use of a toolchain where proofs of controller safety properties in a theorem prover for hybrid systems are used for synthesis of high assurance high performance control code implementations; - leveraging general-purpose formal tools to create automated synthesizers for high assurance message handling code that comes with proofs of correctness (which imply absence of misbehaviors due to e.g. malformed messages); and - tools for producing high assurance and medium assurance glue code that links different modules in a secure safe and resilient manner.
This talk will primarily present a tool user perspective – outlining how we applied these tools and describing both successes and challenges of this effort.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Aleksey</first_name>
          <last_name>Nogin</last_name>
          <affiliation>HRL Laboratories, LLC</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://nogin.org/</homepage_url>
          <picture_url>http://pldi17.sigplan.org/getProfileImage/alekseynogin/c169663a-1225-4842-b0bf-a7a9e79b9bd2/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Deep Specifications in the Wild 2017</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>fd289685-06d9-40c0-9b1a-94ff6c0bee1d</slot_id>
      <title>Correct-by-Construction Generation of Fast Code for Elliptic Curves</title>
      <room>PLDI-C</room>
      <date>2017/06/22</date>
      <start_time>10:30</start_time>
      <end_time>11:00</end_time>
      <description>Elliptic curve cryptography (ECC) is at the heart of some of the workhorse algorithms in TLS 1.3 and other important protocols. You may be shocked to hear that, for the modular big-integer arithmetic behind this kind of algorithm, expert implementers often write new assembly code from scratch for each new large prime modulus! The constant-factor performance win is so big that it makes sense to invest in that kind of specialization, compared to using, say, a standard bignum library based on dynamic allocation. But could we do the specialization automatically and save human engineers the trouble?
I will present Fiat Cryptography, a work-in-progress Coq library that can generate fast ECC code automatically from short descriptions of implementation strategies. While a particular run may spit out thousands of lines of low-level code, we also generate proofs of equivalence to the uncontroversial whiteboard-level math behind elliptic curves. The library’s architecture combines traditional manual proofs of data abstraction, generation of specialized code via partial evaluation, and some compiler verification. For curve 25519, the “hello world” of elliptic curves with a conveniently straightforward prime modulus, we are able to get within about 20% of the performance of the best known C implementation.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Adam</first_name>
          <last_name>Chlipala</last_name>
          <affiliation>MIT</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://adam.chlipala.net/</homepage_url>
          <picture_url>http://pldi17.sigplan.org/getProfileImage/adamchlipala/def72d03-2975-4c5a-a726-e8a944b77dc9/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Deep Specifications in the Wild 2017</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>4df8f1e9-be39-406f-9781-831df508b370</subevent_id>
    <title>DSW 2017: Intro &amp; industry perspective on crypto</title>
    <subevent_type type="regular"/>
    <room>PLDI-C</room>
    <date>2017/06/22</date>
    <url>http://pldi17.sigplan.org/track/dsw-2017-papers</url>
    <url_link_display>Deep Specifications in the Wild 2017</url_link_display>
    <tracks>
      <track>Deep Specifications in the Wild 2017</track>
    </tracks>
    <timeslot>
      <slot_id>2d9ca61e-8283-4e70-96a5-dafd8185f0f0</slot_id>
      <title>Building Faith in Experts: Applying Formal Verification to Cryptography</title>
      <room>PLDI-C</room>
      <date>2017/06/22</date>
      <start_time>09:15</start_time>
      <end_time>10:00</end_time>
      <description>Large commercial organizations have good reason to take the correctness of their cryptography seriously. The largest even employ “cryptography wizards”, experts in the field who are qualified to roll their own heavily optimized implementations. As skilled as these experts are, their work rarely comes with a formal, mathematical proof of implementation correctness.
I’ll discuss Google’s interest in formally verified implementations of cryptography and our experiences with an internship that focused on ECC curve P256. This project successfully verified modular arithmetic on the curve down to the specific machine representation – the register level – for an idealized bignum processor known as “Fancy Machine”. 
We were able to use this experience with a different type of expert, one skilled in the art of formal verification, to build greater certainty in a prior implementation of the same curve. This is the story of the cryptography experts who told us what to prove and the formal verification experts who told us how to go about doing so.</description>
      <persons>
        <person>
          <role>invited speaker</role>
          <sort_key>1</sort_key>
          <first_name>Dominic</first_name>
          <last_name>Rizzo</last_name>
          <affiliation>Google</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>Deep Specifications in the Wild 2017</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>bea40f1b-cb1f-4666-9437-4d752534c4f1</slot_id>
      <title>Introduction to DeepSpec</title>
      <room>PLDI-C</room>
      <date>2017/06/22</date>
      <start_time>09:00</start_time>
      <end_time>09:15</end_time>
      <description>Welcome to the workshop! We’ll start with a brief overview of the DeepSpec project and our goals for the day.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Lennart</first_name>
          <last_name>Beringer</last_name>
          <affiliation>Princeton University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.princeton.edu/~eberinge</homepage_url>
          <picture_url>http://pldi17.sigplan.org/getProfileImage/lennartberinger/8d7941ba-0ebb-43e7-a71e-11f1c3b01754/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Adam</first_name>
          <last_name>Chlipala</last_name>
          <affiliation>MIT</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://adam.chlipala.net/</homepage_url>
          <picture_url>http://pldi17.sigplan.org/getProfileImage/adamchlipala/def72d03-2975-4c5a-a726-e8a944b77dc9/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Deep Specifications in the Wild 2017</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>5b8ebbb7-3797-4758-a1ff-299a68442c7f</subevent_id>
    <title>DSW 2017: Academic C-verification project; industry perspective on hypervisors</title>
    <subevent_type type="regular"/>
    <room>PLDI-C</room>
    <date>2017/06/22</date>
    <url>http://pldi17.sigplan.org/track/dsw-2017-papers</url>
    <url_link_display>Deep Specifications in the Wild 2017</url_link_display>
    <tracks>
      <track>Deep Specifications in the Wild 2017</track>
    </tracks>
    <timeslot>
      <slot_id>1991969a-dde3-4e91-a646-5bb00fdd3e9e</slot_id>
      <title>Challenges in Analysing Virtualisation Stacks</title>
      <room>PLDI-C</room>
      <date>2017/06/22</date>
      <start_time>14:10</start_time>
      <end_time>15:00</end_time>
      <description>Virtual machines are an integral part of public-cloud offerings. In this setting, customers rely on the provider to ensure a secure and reliable operating platform. Isolation from other – possibly malicious – guests is of utmost importance. The core components are hypervisors and device emulation on top of a Linux kernel. In this talk I will discuss the challenges in performing software analysis for such a stack, and how automated static analysis ranging from data-flow analysis to model checking helps to identify and resolve issues.</description>
      <persons>
        <person>
          <role>invited speaker</role>
          <sort_key>1</sort_key>
          <first_name>Michael</first_name>
          <last_name>Tautschnig</last_name>
          <affiliation>Amazon Web Services</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.tautschnig.net/</homepage_url>
        </person>
      </persons>
      <tracks>
        <track>Deep Specifications in the Wild 2017</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>7831d66f-d931-4f69-a0d1-48d1422a20c4</slot_id>
      <title>Verifying concurrent C programs with the Verified Software Toolchain</title>
      <room>PLDI-C</room>
      <date>2017/06/22</date>
      <start_time>13:40</start_time>
      <end_time>14:10</end_time>
      <description>VST’s program logic, Verifiable C, is a concurrent separation logic. You can use it to verify the functional correctness (not just safety!) of shared-memory C programs (in the Pthreads style). Of course, most shared-memory programs have lots of sequential programming too. I’ll demonstrate how Verifiable C supports the interactive verification of both sequential and parallel code.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Andrew</first_name>
          <last_name>Appel</last_name>
          <affiliation>Princeton</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.Princeton.EDU/~appel</homepage_url>
        </person>
      </persons>
      <tracks>
        <track>Deep Specifications in the Wild 2017</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>88a5a4e9-65ed-4fc4-a9d2-cd9c7c38c660</subevent_id>
    <title>Student Research Competition: Reception and SRC posters (finger food provided)</title>
    <subevent_type type="regular"/>
    <room>PLDI-CoffeeBreaks</room>
    <date>2017/06/20</date>
    <url>http://pldi17.sigplan.org/track/pldi-2017-student-research-competition</url>
    <url_link_display>Student Research Competition (SRC)</url_link_display>
    <tracks>
      <track>Student Research Competition (SRC)</track>
    </tracks>
    <timeslot>
      <slot_id>94a9e7e8-850a-401f-9402-c9530444f811</slot_id>
      <title>Reception and SRC posters</title>
      <room>PLDI-CoffeeBreaks</room>
      <date>2017/06/20</date>
      <start_time>17:30</start_time>
      <end_time>20:00</end_time>
      <description>undefined</description>
      <tracks>
        <track>Student Research Competition (SRC)</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>a7891770-8326-48df-bd84-b5442084eb36</subevent_id>
    <title>Student Research Competition: SRC presentations</title>
    <subevent_type type="regular"/>
    <room>PLDI-MainTrack-B</room>
    <date>2017/06/21</date>
    <url>http://pldi17.sigplan.org/track/pldi-2017-student-research-competition</url>
    <url_link_display>Student Research Competition (SRC)</url_link_display>
    <tracks>
      <track>Student Research Competition (SRC)</track>
    </tracks>
    <timeslot>
      <slot_id>766281eb-bbc1-4dc9-bcee-9ccef0f33043</slot_id>
      <title>SRC presentations</title>
      <room>PLDI-MainTrack-B</room>
      <date>2017/06/21</date>
      <start_time>10:20</start_time>
      <end_time>12:00</end_time>
      <description>undefined</description>
      <tracks>
        <track>Student Research Competition (SRC)</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>bc6ad9e2-b0b9-4c65-8b4a-b7ef78daa5ed</subevent_id>
    <title>Catering: Lunch</title>
    <subevent_type type="regular"/>
    <room>LCTES-CoffeeBreaks</room>
    <date>2017/06/22</date>
    <url>http://pldi17.sigplan.org/track/LCTES-2017-catering</url>
    <url_link_display>Catering</url_link_display>
    <tracks>
      <track>Catering</track>
    </tracks>
    <timeslot>
      <slot_id>557161d6-c156-4b86-8c87-1625b75e065d</slot_id>
      <title>Lunch</title>
      <room>LCTES-CoffeeBreaks</room>
      <date>2017/06/22</date>
      <start_time>12:10</start_time>
      <end_time>13:40</end_time>
      <description>Lunch</description>
      <tracks>
        <track>Catering</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>9bd2826b-4ff8-4848-bf00-e5d64633d911</subevent_id>
    <title>Catering: Coffee Break</title>
    <subevent_type type="regular"/>
    <room>LCTES-CoffeeBreaks</room>
    <date>2017/06/21</date>
    <url>http://pldi17.sigplan.org/track/LCTES-2017-catering</url>
    <url_link_display>Catering</url_link_display>
    <tracks>
      <track>Catering</track>
    </tracks>
    <timeslot>
      <slot_id>5cc2bb73-8e80-41ef-be24-32b9a50f7e99</slot_id>
      <title>Break</title>
      <room>LCTES-CoffeeBreaks</room>
      <date>2017/06/21</date>
      <start_time>10:15</start_time>
      <end_time>10:50</end_time>
      <description>Break</description>
      <tracks>
        <track>Catering</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>f9167c03-b79d-4192-ad6b-2b22d973e6f8</subevent_id>
    <title>Catering: Coffee Break</title>
    <subevent_type type="regular"/>
    <room>LCTES-CoffeeBreaks</room>
    <date>2017/06/22</date>
    <url>http://pldi17.sigplan.org/track/LCTES-2017-catering</url>
    <url_link_display>Catering</url_link_display>
    <tracks>
      <track>Catering</track>
    </tracks>
    <timeslot>
      <slot_id>ec7d25b9-3318-4126-af5a-42dc19ed5709</slot_id>
      <title>Break</title>
      <room>LCTES-CoffeeBreaks</room>
      <date>2017/06/22</date>
      <start_time>10:00</start_time>
      <end_time>10:30</end_time>
      <description>Break</description>
      <tracks>
        <track>Catering</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>eb71f75e-488b-4026-8b27-ce7b4cd75a07</subevent_id>
    <title>Catering: Coffee Break</title>
    <subevent_type type="regular"/>
    <room>LCTES-CoffeeBreaks</room>
    <date>2017/06/21</date>
    <url>http://pldi17.sigplan.org/track/LCTES-2017-catering</url>
    <url_link_display>Catering</url_link_display>
    <tracks>
      <track>Catering</track>
    </tracks>
    <timeslot>
      <slot_id>e9358814-4d03-4763-9544-7c410574765c</slot_id>
      <title>Break</title>
      <room>LCTES-CoffeeBreaks</room>
      <date>2017/06/21</date>
      <start_time>15:00</start_time>
      <end_time>15:30</end_time>
      <description>Break</description>
      <tracks>
        <track>Catering</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>460fab09-ac5f-4ca0-af86-ee3ccea5d14a</subevent_id>
    <title>Catering: Lunch</title>
    <subevent_type type="regular"/>
    <room>LCTES-CoffeeBreaks</room>
    <date>2017/06/21</date>
    <url>http://pldi17.sigplan.org/track/LCTES-2017-catering</url>
    <url_link_display>Catering</url_link_display>
    <tracks>
      <track>Catering</track>
    </tracks>
    <timeslot>
      <slot_id>443989a8-48b9-403a-b4c3-880d537f1ac7</slot_id>
      <title>Lunch</title>
      <room>LCTES-CoffeeBreaks</room>
      <date>2017/06/21</date>
      <start_time>12:30</start_time>
      <end_time>14:00</end_time>
      <description>Lunch</description>
      <tracks>
        <track>Catering</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>65968774-fb90-4ff7-8d80-e70d40bf2e2b</subevent_id>
    <title>ARRAY 2017: Invited talk</title>
    <subevent_type type="regular"/>
    <room>PLDI-B</room>
    <date>2017/06/18</date>
    <url>http://pldi17.sigplan.org/track/array-2017</url>
    <url_link_display>ARRAY 2017</url_link_display>
    <tracks>
      <track>ARRAY 2017</track>
    </tracks>
    <timeslot>
      <slot_id>2e206b25-18b3-4706-8938-d6a45998f827</slot_id>
      <title>Invited talk: APLicative Programming with Naperian Functors</title>
      <room>PLDI-B</room>
      <date>2017/06/18</date>
      <start_time>14:00</start_time>
      <end_time>15:00</end_time>
      <description>Much of the expressive power of array-oriented languages such as Iverson’s APL and J comes from their implicit lifting of scalar operations to act on higher-ranked data, for example to add a value to each element of a vector, or to add two compatible matrices pointwise. It is considered a shape error to attempt to combine arguments of incompatible shape, such as a 3-vector with a 4-vector. APL and J are dynamically typed, so such shape errors are caught only at run-time. Recent work by Slepak et al develops a custom type system for an array-oriented language, statically ruling out such errors. I will show that such a custom language design is unnecessary: the requisite compatibility checks can already be captured in modern expressive type systems, as found for example in Haskell; moreover, generative type-driven programming can exploit that static type information constructively to automatically induce the appropriate liftings. I will also show that the structure of multi-dimensional data is inherently a matter of traversable Naperian applicative functors (and I will explain what this means).</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Jeremy</first_name>
          <last_name>Gibbons</last_name>
          <affiliation>Department of Computer Science, University of Oxford</affiliation>
          <bio>I am Professor of Computing in the Department of Computer Science at the University of Oxford. I am currently Director of the Software Engineering Programme, which offers part-time professional Masters’ degrees in Software Engineering and in Software and Systems Security. I also lead the Algebra of Programming research group. I am Editor-in-Chief of the Journal of Functional Programming, Past Vice Chair of ACM SIGPLAN, Past Chair of IFIP WG2.1. Before taking up this post in 1999, I held lectureships at Oxford Brookes University and the University of Auckland, New Zealand.</bio>
          <homepage_url>http://www.cs.ox.ac.uk/jeremy.gibbons/</homepage_url>
          <picture_url>http://pldi17.sigplan.org/getProfileImage/jeremygibbons/17403e55-a926-41cf-ae21-08abecea187c/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>ARRAY 2017</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>7bcc83c2-6721-4d6e-be22-0c2422bc33e5</subevent_id>
    <title>ARRAY 2017: Morning talks 1</title>
    <subevent_type type="regular"/>
    <room>PLDI-B</room>
    <date>2017/06/18</date>
    <url>http://pldi17.sigplan.org/track/array-2017</url>
    <url_link_display>ARRAY 2017</url_link_display>
    <tracks>
      <track>ARRAY 2017</track>
    </tracks>
    <timeslot>
      <slot_id>7e883c5b-810b-402d-bc20-8572f92d24f7</slot_id>
      <title>Quad Ropes -- Immutable, Declarative Arrays with Parallelizable Operations</title>
      <room>PLDI-B</room>
      <date>2017/06/18</date>
      <start_time>10:00</start_time>
      <end_time>10:30</end_time>
      <description>We describe the quad rope data structure, a representation of immutable two-dimensional arrays that avoids many of the performance pitfalls of plain C-style two-dimensional arrays. Our motivation is that, for end-user development in high-level declarative programming languages, it is impractical to let users choose between different array-like data structures. Instead, one should use the same, somewhat performance-robust, representation for every programming task.
Quad ropes roughly retain array efficiency, as long as programmers express their programs using high-level constructs. Moreover, they allow for fast concatenation and dynamic task-based parallelism and are well suited to represent sparse arrays. We describe their operational semantics and evaluate the performance of individual functions on quad ropes as well as declarative algorithms that use our quad rope implementation.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Florian</first_name>
          <last_name>Biermann</last_name>
          <affiliation>IT University of Copenhagen</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://fbie.github.io</homepage_url>
          <picture_url>http://pldi17.sigplan.org/getProfileImage/florianbiermann/6c94347d-bbb9-4a85-a47f-e45883563da2/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Peter</first_name>
          <last_name>Sestoft</last_name>
          <affiliation>IT University of Copenhagen</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.itu.dk/people/sestoft/</homepage_url>
        </person>
      </persons>
      <tracks>
        <track>ARRAY 2017</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>7decb44f-71fb-4314-9562-624d497ece61</subevent_id>
    <title>ARRAY 2017: Keynote</title>
    <subevent_type type="regular"/>
    <room>PLDI-B</room>
    <date>2017/06/18</date>
    <url>http://pldi17.sigplan.org/track/array-2017</url>
    <url_link_display>ARRAY 2017</url_link_display>
    <tracks>
      <track>ARRAY 2017</track>
    </tracks>
    <timeslot>
      <slot_id>2310eb07-2bb6-4478-88cd-3b959d8887f7</slot_id>
      <title>Keynote: Towards achieving high performance, productivity, and portability for matrix/tensor computations in machine learning and data analytics</title>
      <room>PLDI-B</room>
      <date>2017/06/18</date>
      <start_time>09:00</start_time>
      <end_time>10:00</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>P. (Saday)</first_name>
          <last_name>Sadayappan</last_name>
          <affiliation>Ohio State University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://web.cse.ohio-state.edu/~saday/</homepage_url>
        </person>
      </persons>
      <tracks>
        <track>ARRAY 2017</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>b56aefa2-81b2-4260-acd2-66642b461c9d</subevent_id>
    <title>LCTES 2017: Keynote 1</title>
    <subevent_type type="regular"/>
    <room>LCTES-MainTrack</room>
    <date>2017/06/21</date>
    <url>http://pldi17.sigplan.org/track/LCTES-2017-papers</url>
    <url_link_display>- The 18th Annual ACM SIGPLAN / SIGBED Conference on Languages, Compilers, and Tools for Embedded Systems</url_link_display>
    <tracks>
      <track>- The 18th Annual ACM SIGPLAN / SIGBED Conference on Languages, Compilers, and Tools for Embedded Systems</track>
    </tracks>
    <timeslot>
      <slot_id>edeb4337-c41e-4bcd-b44f-9431ecaea057</slot_id>
      <title>Static Analysis for Improving Software Performance, Safety and Security</title>
      <room>LCTES-MainTrack</room>
      <date>2017/06/21</date>
      <start_time>09:15</start_time>
      <end_time>10:15</end_time>
      <description>Static program analysis is increasingly recognized as a fundamental tool for compiler optimization, bug detection and security analysis (among others). Pointer analysis is the foundation, on which virtually all other analyses are based. In this talk, I will introduce a number of pointer analysis techniques developed in my research group, together with their applications for improving software performance, safety and security. I will conclude my talk by discussing some challenges and opportunities faced in developing practical pointer analyses for real-world applications.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Jingling</first_name>
          <last_name>Xue</last_name>
          <affiliation>UNSW Australia</affiliation>
          <bio>Jingling Xue received his BSc and MSc degrees in Computer Science and Engineering from Tsinghua University in 1984 and 1987, respectively, and his PhD degree in Computer Science and Engineering from Edinburgh University in 1992. He is currently a Scientia Professor in the School of Computer Science and Engineering, University of New South Wales, Australia, where he leads the Programming Languages and Compilers Group. 
Jingling Xue’s main research interest has been programming languages and compilers for over 25 years. He is currently supervising a group of postdocs and PhD students on a number of topics including programming and compiler techniques for multi-core processors and embedded systems, concurrent programming models, static and dynamic program analysis for bugs and security vulnerabilities, security analysis of Android apps, and automatic parallelization of programs for parallel and distributed systems. His research has been supported by Intel, Sun Microsystems, Oracle, Huawei and Australian Research Council.
Jingling Xue is interested in sharing the outcomes of his research projects in the form of open-source tools (http://www.cse.unsw.edu.au/~jingling/tools.html). 
Jingling Xue is an Associate Editor for several journals, including IEEE Transactions on Computers (2011 – 2015), Software: Practice and Experience, and Journal of Computer Science and Technology. He has served as a program committee member in numerous conferences in his field.</bio>
          <homepage_url>http://www.cse.unsw.edu.au/~jingling/</homepage_url>
          <picture_url>http://pldi17.sigplan.org/getProfileImage/jinglingxue/cc011767-23b5-466f-9501-72b57243ae4d/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>- The 18th Annual ACM SIGPLAN / SIGBED Conference on Languages, Compilers, and Tools for Embedded Systems</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>5ee131ad-e0e9-4ffc-a8fd-760d904d0d84</subevent_id>
    <title>LCTES 2017: Opening</title>
    <subevent_type type="regular"/>
    <room>LCTES-MainTrack</room>
    <date>2017/06/21</date>
    <url>http://pldi17.sigplan.org/track/LCTES-2017-papers</url>
    <url_link_display>- The 18th Annual ACM SIGPLAN / SIGBED Conference on Languages, Compilers, and Tools for Embedded Systems</url_link_display>
    <tracks>
      <track>- The 18th Annual ACM SIGPLAN / SIGBED Conference on Languages, Compilers, and Tools for Embedded Systems</track>
    </tracks>
    <timeslot>
      <slot_id>4bb83792-255a-4941-812e-71c2906de1cf</slot_id>
      <title>Opening</title>
      <room>LCTES-MainTrack</room>
      <date>2017/06/21</date>
      <start_time>09:00</start_time>
      <end_time>09:15</end_time>
      <description>undefined</description>
      <tracks>
        <track>- The 18th Annual ACM SIGPLAN / SIGBED Conference on Languages, Compilers, and Tools for Embedded Systems</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>0f83fa8a-6c27-4153-92b0-caebcc968e1c</subevent_id>
    <title>ARRAY 2017: Closing / Discussion</title>
    <subevent_type type="regular"/>
    <room>PLDI-B</room>
    <date>2017/06/18</date>
    <url>http://pldi17.sigplan.org/track/array-2017</url>
    <url_link_display>ARRAY 2017</url_link_display>
    <tracks>
      <track>ARRAY 2017</track>
    </tracks>
    <timeslot>
      <slot_id>7d926cd1-1f9a-42e6-a05f-5a0cf25d88e6</slot_id>
      <title>Closing / Discussion</title>
      <room>PLDI-B</room>
      <date>2017/06/18</date>
      <start_time>17:30</start_time>
      <end_time>18:00</end_time>
      <description>undefined</description>
      <tracks>
        <track>ARRAY 2017</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>165d93b3-7149-4d11-bfea-379bf46b752a</subevent_id>
    <title>LCTES 2017: Poster Session</title>
    <subevent_type type="regular"/>
    <room>LCTES-MainTrack</room>
    <date>2017/06/21</date>
    <url>http://pldi17.sigplan.org/track/LCTES-2017-papers</url>
    <url_link_display>- The 18th Annual ACM SIGPLAN / SIGBED Conference on Languages, Compilers, and Tools for Embedded Systems</url_link_display>
    <tracks>
      <track>- The 18th Annual ACM SIGPLAN / SIGBED Conference on Languages, Compilers, and Tools for Embedded Systems</track>
    </tracks>
    <timeslot>
      <slot_id>1ab55e1d-593f-4d86-9497-7185211a01c6</slot_id>
      <title>[Poster] Understanding the Performance of Dynamic Binary Modification on ARM Using MAMBO</title>
      <room>LCTES-MainTrack</room>
      <date>2017/06/21</date>
      <start_time>14:00</start_time>
      <end_time>15:00</end_time>
      <description>Dynamic Binary Modification (DBM) is a technique for modifying applications transparently while they are executed, working at the level of native code. However, DBM introduces a performance overhead, which in some cases can dominate execution time, making many uses impractical.
The ARM hardware ecosystem poses unique challenges for high performance DBM systems because of the large number and wide range of capabilities of the commercially available implementations: from single issue, in order cores up to 6-issue out-of-order cores and including less traditional implementations. These variations raise the question of whether it is possible to develop DBM optimisations which either improve or, at the very least, do not affect performance on all available systems and microarchitectures. To answer this question, the performance of three new optimisations for the MAMBO DBM system has been evaluated on three systems using different microarchitectures. For comparison, the overhead of DynamoRIO, a high performance DBM system which was recently ported to the ARM architecture, is also evaluated.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Cosmin</first_name>
          <last_name>Gorgovan</last_name>
          <affiliation>University of Manchester</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Amanieu</first_name>
          <last_name>d'Antras</last_name>
          <affiliation>University of Manchester</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Mikel</first_name>
          <last_name>Luján</last_name>
          <affiliation>University of Manchester</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>- The 18th Annual ACM SIGPLAN / SIGBED Conference on Languages, Compilers, and Tools for Embedded Systems</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>2d1887bd-dec6-4a2f-9c95-dd771845923c</slot_id>
      <title>A Lightweight Progress Maximization Scheduler for Non-Volatile Processor Under Unstable Energy Harvesting</title>
      <room>LCTES-MainTrack</room>
      <date>2017/06/21</date>
      <start_time>14:00</start_time>
      <end_time>15:00</end_time>
      <description>Energy harvesting techniques become increasingly popular as power supplies for embedded systems. However, the harvested energy is intrinsically unstable. Thus, the program execution may be interrupted frequently. Although the development of non-volatile processors (NVP) can save and restore execution states, both hardware and software challenges exist for energy harvesting powered embedded systems. On the hardware side, existing power detector only signals the ``poor’’ quality of the harvested power based on a preset threshold voltage. The inappropriate setting of this threshold will make the NVP system suffer from either unnecessary checkpointings or checkpointing failures. On the software side, not all tasks can be checkpointed. Once the power is off, these tasks will have to restart from the beginning. In this paper, a task scheduler is proposed to maximize task progress by prioritizing uncheckpointable tasks if power is weak so that they can finish before the power failure. To assist task scheduling, three additional modules including voltage monitor, checkpointing handler, and routine handler, are proposed. Experimental results show increased overall task progress and reduced energy consumption.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Chen</first_name>
          <last_name>Pan</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Mimi</first_name>
          <last_name>Xie</last_name>
          <affiliation>Oklahoma State University</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Yongpan</first_name>
          <last_name>Liu</last_name>
          <affiliation>Tsinghua University</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Yanzhi</first_name>
          <last_name>Wang</last_name>
          <affiliation>Syracuse University</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Jason</first_name>
          <last_name>Xue</last_name>
          <affiliation>City University of Hong Kong, China</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.cityu.edu.hk/~jasonxue/</homepage_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Yiran</first_name>
          <last_name>Chen</last_name>
          <affiliation>University of Pittsburgh</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>7</sort_key>
          <first_name>Jingtong</first_name>
          <last_name>Hu</last_name>
          <affiliation>Oklahoma State University</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>- The 18th Annual ACM SIGPLAN / SIGBED Conference on Languages, Compilers, and Tools for Embedded Systems</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>555f9bcd-8e1e-4adc-a859-25e2f8fc5b62</slot_id>
      <title>Efficient SMT-based LTL Model Checking of Clock Constraint Specification Language for Real-Time and Embedded Systems</title>
      <room>LCTES-MainTrack</room>
      <date>2017/06/21</date>
      <start_time>14:00</start_time>
      <end_time>15:00</end_time>
      <description>MARTE (abbreviated for Modeling and Analysis of Real-Time and Embedded systems) is a UML profile, used to facilitate the design and analysis of real-time and embedded systems. The Clock Constraint Specification Language (CCSL) is a formal language companion to MARTE, which is proposed to specify the constraint of the occurrences of events in systems. However, the language lacks efficient verification support to the formal analysis of temporal properties which are important to real-time and embedded systems. In this paper, we propose an SMT-based approach to model checking of the temporal properties specified in Linear Temporal Logic (LTL) for CCSL. We implement a prototype tool for the proposed approach and use the state-of-the-art tool Z3 as the underlying SMT solver. We model two practical cases including a traffic light controller and a power window system in CCSL, and verify LTL properties of the two systems using the proposed approach. Experimental results demonstrate the effectiveness of our approach.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Min</first_name>
          <last_name>Zhang</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Yunhui</first_name>
          <last_name>Ying</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>- The 18th Annual ACM SIGPLAN / SIGBED Conference on Languages, Compilers, and Tools for Embedded Systems</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>5d38dd08-165f-4a4f-80d7-f39b70e6ab20</slot_id>
      <title>Optimal Functional Unit Assignment and Voltage Selection for Pipelined MPSoC with Guaranteed Probability on Time Performance</title>
      <room>LCTES-MainTrack</room>
      <date>2017/06/21</date>
      <start_time>14:00</start_time>
      <end_time>15:00</end_time>
      <description>Pipelined heterogeneous multiprocessor system-on-chip (MPSoC) can provide high throughput for streaming applications. In the design of such systems, time performance and system cost are the most concerning issues. By analyzing runtime behaviors of benchmarks in real-world platforms, we find that execution times of tasks are not fixed but spread with probabilities. In terms of this feature, we model execution times of tasks as random variables. In this paper, we study how to design high-performance and low-cost MPSoC systems to execute a set of such tasks with data dependencies in a pipelined fashion. Our objective is to obtain the optimal functional unit assignment and voltage selection for the pipelined MPSoC systems, such that the system cost is minimized while timing constraints can be met with a given guaranteed probability. For each required probability, our proposed algorithm can efficiently obtain the optimal solution. Experiments show that other existing algorithms cannot find feasible solutions in most cases, but ours can. Even for those solutions that other algorithms can obtain, ours can reach 30% reductions in total cost compared with others.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Weiwen</first_name>
          <last_name>Jiang</last_name>
          <affiliation>Chongqing University</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Edwin</first_name>
          <last_name>Sha</last_name>
          <affiliation>Chongqing University</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Qingfeng</first_name>
          <last_name>Zhuge</last_name>
          <affiliation>Chongqing University, China</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.cqu.edu.cn/en/supervisors</homepage_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Hailiang</first_name>
          <last_name>Dong</last_name>
          <affiliation>Chongqing University</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Xianzhang</first_name>
          <last_name>Chen</last_name>
          <affiliation>Chongqing University</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>- The 18th Annual ACM SIGPLAN / SIGBED Conference on Languages, Compilers, and Tools for Embedded Systems</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>5ffc1a46-f086-4876-a09c-e2a3f7b53f2b</slot_id>
      <title>Adaptive Optimization for OpenCL Programs on Embedded Heterogeneous Systems</title>
      <room>LCTES-MainTrack</room>
      <date>2017/06/21</date>
      <start_time>14:00</start_time>
      <end_time>15:00</end_time>
      <description>Heterogeneous multi-core architectures consisting of CPUs and GPUs are commonplace in today’s embedded systems. These architectures offer potential for energy efficient computing if the application task is mapped to the right core. Realizing such potential is challenging due to the complex and evolving natural of hardware and applications. This paper presents an automatic approach to map OpenCL kernels onto heterogeneous multi-cores for a given optimization criterion – whether it is faster runtime, lower energy consumption or a trade-off between them. This is achieved by developing a machine learning based approach to predict which processor to use to run the OpenCL kernel and the host program, and at what frequency the processor should operate. Instead of hand-tuning a model for each optimization metric, we use machine learning to develop a unified framework that first automatically learns the optimization heuristic for each metric off-line, and then uses the learned knowledge to schedule OpenCL kernels at runtime based on code and runtime information of the program. We apply our approach to a set of representative \OpenCL benchmarks and evaluate it on an ARM big.LITTLE mobile platform. Our approach achieves over 93% of the performance delivered by an oracle predictor. We obtain, on average, 1.2x, 1.6x, and 1.8x improvement respectively for runtime, energy consumption and the energy delay product, when compared to a state-of-the-art heterogeneous-aware OpenCL task mapping scheme.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Ben</first_name>
          <last_name>Taylor</last_name>
          <affiliation>Lancaster University, UK</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Vicent Sanz</first_name>
          <last_name>Marco</last_name>
          <affiliation>Lancaster University</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Zheng</first_name>
          <last_name>Wang</last_name>
          <affiliation>Lancaster University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.lancaster.ac.uk/staff/wangz3/</homepage_url>
          <picture_url>http://pldi17.sigplan.org/getProfileImage/zhengwang/9f51ef64-4f51-41e2-8d62-4a954783d991/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>- The 18th Annual ACM SIGPLAN / SIGBED Conference on Languages, Compilers, and Tools for Embedded Systems</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>68817834-cb2d-4aef-92f2-13f2dc603d4f</slot_id>
      <title>[Poster] Benchmarking OpenMP for Real-Time Scheduling: From Modeling to Applications</title>
      <room>LCTES-MainTrack</room>
      <date>2017/06/21</date>
      <start_time>14:00</start_time>
      <end_time>15:00</end_time>
      <description>Real-time systems are shifting from single-core to multi-core processors. Software must be parallelized to fully utilize the computation power of multi-core architecture. OpenMP is a popular parallel programming framework in general and high-performance computing, and recently has drawn a lot of interests in embedded and real-time computing. Much recent work has been done on real-time scheduling of OpenMP-based parallel workload. However, these studies conduct evaluations with randomly generated task systems, which cannot well represent the structure features of OpenMP workload. This paper presents a benchmark suite, ompTGB, to support research on real-time scheduling of OpenMP-based parallel tasks. ompTGB does not only collect realistic OpenMP programs, but also models them into task graphs so that the real-time scheduling researchers can easily understand and use them. We also present a new response time bound for a subset of OpenMP programs and use it to demonstrate the usage of ompTGB.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Sun</first_name>
          <last_name>Jinghao</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Nan</first_name>
          <last_name>Guan</last_name>
          <affiliation>Hong Kong Polytechnic University, China</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www4.comp.polyu.edu.hk/~csguannan/index.html</homepage_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Yang</first_name>
          <last_name>Wang</last_name>
          <affiliation>Northeastern University</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Yang</first_name>
          <last_name>Wang</last_name>
          <affiliation>University of New Brunswick</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Mingsong</first_name>
          <last_name>Lv</last_name>
          <affiliation>Northeastern University</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Wang</first_name>
          <last_name>Yi</last_name>
          <affiliation>Uppsala University, Sweden</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://user.it.uu.se/~yi/</homepage_url>
        </person>
      </persons>
      <tracks>
        <track>- The 18th Annual ACM SIGPLAN / SIGBED Conference on Languages, Compilers, and Tools for Embedded Systems</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>7de14567-3a2b-40a7-9baf-b6d057dd9173</slot_id>
      <title>[Poster] Checkpointing-aware Loop Tiling for Energy Harvesting Powered Non-Volatile Processors</title>
      <room>LCTES-MainTrack</room>
      <date>2017/06/21</date>
      <start_time>14:00</start_time>
      <end_time>15:00</end_time>
      <description>In this paper, we present a checkpointing-aware loop tiling method for energy harvesting powered non-volatile processors. As power failures of energy harvesting system happen naturally, checkpointing is needed during the program execution. We observe that checkpointing is implemented with high overhead in applications with loops. We are motivated to reduce the amount of checkpointing data by analyzing data locality and shortening data lifetime in loops. This paper proposes checkpointing-aware loop tiling techniques which target to reduce the checkpointing and recovering overheads for loops. First, we analyze the optimal tile size for the nest loops considering checkpointing distance. Then, checkpointing and recovery schemes for tiling loops are proposed. Finally, the experiments are implemented to evaluate the effectiveness. The experimental results show that compared to the most related work, the proposed method reduce the checkpointing and recovering overheads significantly.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Fuyang</first_name>
          <last_name>Li</last_name>
          <affiliation>Department of Computer Science, City University of Hong Kong, Hong Kong</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Keni</first_name>
          <last_name>Qiu</last_name>
          <affiliation>Capital Normal University, Beijing, China</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Qingan</first_name>
          <last_name>Li</last_name>
          <affiliation>State Key Laboratory of Software Engineering, Wuhan University, China</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Mengying</first_name>
          <last_name>Zhao</last_name>
          <affiliation>Shandong University</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Jingtong</first_name>
          <last_name>Hu</last_name>
          <affiliation>Oklahoma State University</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Yongpan</first_name>
          <last_name>Liu</last_name>
          <affiliation>Tsinghua University</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>7</sort_key>
          <first_name>Jason</first_name>
          <last_name>Xue</last_name>
          <affiliation>City University of Hong Kong, China</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.cityu.edu.hk/~jasonxue/</homepage_url>
        </person>
      </persons>
      <tracks>
        <track>- The 18th Annual ACM SIGPLAN / SIGBED Conference on Languages, Compilers, and Tools for Embedded Systems</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>846f44e0-04fa-4bfc-bce8-958f6c83590f</slot_id>
      <title>Auto-Vectorization for Image Processing DSLs</title>
      <room>LCTES-MainTrack</room>
      <date>2017/06/21</date>
      <start_time>14:00</start_time>
      <end_time>15:00</end_time>
      <description>The parallelization of programs and distributing their workloads to multiple threads can be a challenging task. In addition to multi- threading, harnessing vector units in CPUs proves highly desirable. However, employing vector units to speed up programs can be quite tedious. Either a program developer solely relies on the auto-vectorization capabilities of the compiler or he manually applies vector intrinsics, which is extremely error-prone, difficult to maintain, and not portable at all. Based on whole-function vectorization, a method to replace con- trol flow with data flow, we propose auto-vectorization techniques for image processing DSLs in the context of source-to-source com- pilation. The approach does not require the input to be available in SSA form. Moreover, we formulate constraints under which the vectorization analysis and code transformations may be greatly sim- plified in the context of image processing DSLs. As part of our methodology, we present control flow to data flow transformation as a source-to-source translation. Moreover, we propose a method to efficiently analyze algorithms with mixed bit-width data types to determine the optimal SIMD width, independently of the target instruction set. The techniques are integrated into an open source DSL framework. Subsequently, the vectorization capabilities are compared to a variety of existing state-of-the-art C/C ++ compilers. Speedups of up to 7.4 are observed for benchmarks taken from ISPC and image processing, compared to non-vectorized executions.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Oliver</first_name>
          <last_name>Reiche</last_name>
          <affiliation>Friedrich-Alexander-Universität Erlangen-Nürnberg (FAU)</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www12.cs.fau.de/people/reiche/</homepage_url>
          <picture_url>http://pldi17.sigplan.org/getProfileImage/oliverreiche/866f2dfe-ced2-4bf6-adaf-530acc81fa16/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Christof</first_name>
          <last_name>Kobylko</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Frank</first_name>
          <last_name>Hannig</last_name>
          <affiliation>Friedrich-Alexander University Erlangen-Nürnberg (FAU)</affiliation>
          <bio>Frank Hannig leads the Architecture and Compiler Design Group in the CS Department at Friedrich-Alexander University Erlangen-N&amp;uuml;rnberg (FAU), Germany, since 2004. He received a diploma degree in an interdisciplinary course of study in EE and CS from the University of Paderborn, Germany in 2000 and a Ph.D. degree (Dr.-Ing.) in CS from FAU in 2009. His main research interests are the design of massively parallel architectures, ranging from dedicated hardware to multi-core architectures, mapping methodologies for domain-specific computing, and architecture/compiler co-design. Frank has authored or coauthored more than 120 peer-reviewed publications. He serves on the program committees of several international conferences (ARC, ASAP, CODES+ISSS, DATE, DASIP, SAC). Frank is a senior member of the IEEE.</bio>
          <homepage_url>https://www12.cs.fau.de/people/hannig/</homepage_url>
          <picture_url>http://pldi17.sigplan.org/getProfileImage/frankhannig/cd43fb9e-78a0-4928-ab52-27b847d9ebcc/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Jürgen</first_name>
          <last_name>Teich</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>- The 18th Annual ACM SIGPLAN / SIGBED Conference on Languages, Compilers, and Tools for Embedded Systems</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>b775f37a-89eb-415b-b483-8d1055235a70</slot_id>
      <title>Dynamic Translation of Structured Loads/Stores and Register Mapping for Architectures with SIMD Extensions</title>
      <room>LCTES-MainTrack</room>
      <date>2017/06/21</date>
      <start_time>14:00</start_time>
      <end_time>15:00</end_time>
      <description>More and more modern processors have been supporting non-contiguous SIMD data accesses. However, translating such instructions has been overlooked in the Dynamic Binary Translation (DBT) area. For example, in the popular QEMU dynamic binary translator, guest memory instructions with strides are emulated by a sequence of scalar instructions, leaving a significant room for performance improvement when the host machines have SIMD instructions available. Structured loads/stores, such as VLDn/VSTn in ARM NEON, are one type of strided SIMD data access instructions. They are widely used in signal processing, multimedia, mathematical and 2D matrix transposition applications. Efficient translation of such structured loads/stores is a critical issue when migrating ARM executables to other ISAs. However, it is quite challenging since not only the translation of structured loads/stores is not trivial, but also the difference between guest and host register configurations must be taken into consideration. In this work, we present the design and implementation of translating structured loads/stores in DBT, including target code generation as well as efficient SIMD register mapping. Our proposed register mapping mechanisms are not limited to handling structured load/stores, they can be extended to deal with normal SIMD instructions. On a set of OpenCV benchmarks, our QEMU-based system has achieved a maximum speedup of 5.41x, with an average improvement of 2.93x. On a set of BLAS benchmarks, our system has also obtained a maximum speedup of 2.19x and an average improvement of 1.63x.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Sheng-Yu</first_name>
          <last_name>Fu</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Ding-Yong</first_name>
          <last_name>Hong</last_name>
          <affiliation>Institute of Information Science, Academia Sinica</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Yu-Ping</first_name>
          <last_name>Liu</last_name>
          <affiliation>Department of Computer Science and Information Engineering, National Taiwan University</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Jan-Jan</first_name>
          <last_name>Wu</last_name>
          <affiliation>Institute of Information Science, Academia Sinica</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Wei-Chung</first_name>
          <last_name>Hsu</last_name>
          <affiliation>Dept. Computer Science &amp; Information Engineering, National Taiwan University</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>- The 18th Annual ACM SIGPLAN / SIGBED Conference on Languages, Compilers, and Tools for Embedded Systems</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>bbc0a7e9-6f62-4c8e-a508-27412b997f83</slot_id>
      <title>Unified nvTCAM and sTCAM Architecture for Improving Packet Matching Performance</title>
      <room>LCTES-MainTrack</room>
      <date>2017/06/21</date>
      <start_time>14:00</start_time>
      <end_time>15:00</end_time>
      <description>Software-Defined Networking (SDN) allows control applications to install fine-grained forwarding policies in the underlying switches. Ternary Content Addressable Memory (TCAM) enables fast lookups in hardware switches with flexible wildcard rule patterns. However, the performance of packet processing is severely constrained by the capacity of TCAM, aggravating the processing burden and latency issues. In this paper, we propose a hybrid TCAM architecture which consists of NVM-based TCAM (nvTCAM) and SRAM-based TCAM (sTCAM), utilizing nvTCAM to cache the most popular rules to improve cache-hit-ratio while relying on a very small-size sTCAM to handle cache-miss traffic to effectively decrease update latency. Considering the special rule dependency, we present a Rule Migration Replacement Algorithm to effectively make full utilization of both nvTCAM and sTCAM to obtain better performance. Experimental results show our proposed architecture outperforms current TCAM architectures.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Xianzhong</first_name>
          <last_name>Ding</last_name>
          <affiliation>Shandong  University</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Zhiyong</first_name>
          <last_name>Zhang</last_name>
          <affiliation>Shandong University</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Zhiping</first_name>
          <last_name>Jia</last_name>
          <affiliation>Shandong University</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Lei</first_name>
          <last_name>Ju</last_name>
          <affiliation>Shandong  University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.es.sdu.edu.cn/~julei/index_en.jsp</homepage_url>
          <picture_url>http://pldi17.sigplan.org/getProfileImage/julei/a60289aa-6246-41f8-a2a4-26522c0b0a16/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Mengying</first_name>
          <last_name>Zhao</last_name>
          <affiliation>Shandong University</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Huawei</first_name>
          <last_name>Huang</last_name>
          <affiliation>The University of Aizu</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>- The 18th Annual ACM SIGPLAN / SIGBED Conference on Languages, Compilers, and Tools for Embedded Systems</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>cb68e204-3a7a-4ff7-8071-40c58cbcfaa3</slot_id>
      <title>OSEK-V: Application-Specific RTOS Instantiation in Hardware</title>
      <room>LCTES-MainTrack</room>
      <date>2017/06/21</date>
      <start_time>14:00</start_time>
      <end_time>15:00</end_time>
      <description>The employment of a real-time operating system (RTOS) in an embedded control systems is often an all-or-nothing decision: While the RTOS-abstractions provide for easier software composition and development, the price in terms of event latencies and memory costs are high. Especially in HW/SW codesign settings, system developers try to avoid the employment of a full-blown RTOS as far as possible. In OSEK-V, we mitigate this trade-off by a very aggressive tailoring of the concrete RTOS instance into the hardware. Instead of implementing generic OS components as custom hardware devices, we capture the actually possible application–kernel interactions as a finite-state machine and integrate the tailored RTOS semantics directly into the processor pipeline. In our experimental results with an OSEK-based implementation of a quadrotor flight controller into the Rocket/RISC-V softcore, we thereby can significantly reduce event latencies, interrupt lock times, and memory footprint at moderate costs in terms of FPGA resources.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Christian</first_name>
          <last_name>Dietrich</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Daniel</first_name>
          <last_name>Lohmann</last_name>
          <affiliation>Friedrich-Alexander-Universität, Germany</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www4.cs.fau.de/~lohmann</homepage_url>
        </person>
      </persons>
      <tracks>
        <track>- The 18th Annual ACM SIGPLAN / SIGBED Conference on Languages, Compilers, and Tools for Embedded Systems</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>cedf2c8f-0d1e-4237-8246-03a2b773df67</slot_id>
      <title>Integrated IoT Programming with Selective Abstraction</title>
      <room>LCTES-MainTrack</room>
      <date>2017/06/21</date>
      <start_time>14:00</start_time>
      <end_time>15:00</end_time>
      <description>The explosion of networked devices has driven a new computing environment called the Internet of Things (IoT), enabling various services such as home automation and health monitoring. Despite the promising applicability of the IoT, developing an IoT service is challenging for programmers, because the programmers should integrate multiple programmable devices and heterogeneous third-party devices. Recent works have proposed integrated programming platforms, but they either require device-specific implementation for third-party devices without any device abstraction, or abstract all the devices to the standard interfaces requiring unnecessary abstraction of programmable devices. To integrate IoT devices with selective abstraction, this work revisits the object oriented programming (OOP) model, and proposes a new language extension and its compiler-runtime framework, called Esperanto. With three annotations that map each object to its corresponding IoT device, the Esperanto language allows programmers to integrate multiple programmable devices into one OOP program and to abstract similar third-party devices into their common ancestor classes. Given the annotations, the Esperanto compiler automatically partitions the integrated program into multiple sub-programs for each programmable IoT device, and inserts communication and synchronization code. Moreover, for the ancestor classes, the Esperanto runtime dynamically identifies connected third-party devices, and links their corresponding descendent objects. Compared to an existing approach on the integrated IoT programming, Esperanto requires 33.3% fewer lines of code to implement 5 IoT services, and reduces their response time by 44.8% on average.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Gyeongmin</first_name>
          <last_name>Lee</last_name>
          <affiliation>POSTECH</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Seonyeong</first_name>
          <last_name>Heo</last_name>
          <affiliation>POSTECH</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Bongjun</first_name>
          <last_name>Kim</last_name>
          <affiliation>POSTECH</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Jong</first_name>
          <last_name>Kim</last_name>
          <affiliation>POSTECH</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Hanjun</first_name>
          <last_name>Kim</last_name>
          <affiliation>POSTECH</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>- The 18th Annual ACM SIGPLAN / SIGBED Conference on Languages, Compilers, and Tools for Embedded Systems</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>d9ad2706-d224-47fe-bf7f-cb9c2e36dc00</slot_id>
      <title>AOT Vs. JIT: Impact of Profile Data on Code Quality</title>
      <room>LCTES-MainTrack</room>
      <date>2017/06/21</date>
      <start_time>14:00</start_time>
      <end_time>15:00</end_time>
      <description>Just-in-time (JIT) compilation during program execution and ahead-of-time (AOT) compilation during software installation are alternate techniques used by managed language virtual machines (VM) to generate optimized native code while simultaneously achieving binary code portability and high execution performance. Profile data collected by JIT compilers at run-time can enable profile-guided optimizations (PGO) to customize the generated native code to different program inputs. AOT compilation removes the speed and energy overhead of online profile collection and dynamic compilation, but may not be able to achieve the quality and performance of customized native code. The goal of this work is to investigate and quantify the implications of the AOT compilation model on the quality of the generated native code for current VMs. 
First, we quantify the quality of native code generated by the two compilation models for a state-of-the-art (HotSpot) Java VM. Second, we determine how the amount of profile data collected affects the quality of generated code. Third, we develop a mechanism to determine the accuracy or similarity for different profile data for a given program run, and investigate how the accuracy of profile data affects its ability to effectively guide PGOs. Finally, we categorize the profile data types in our VM and explore the contribution of each such category to performance.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>April W.</first_name>
          <last_name>Wade</last_name>
          <affiliation>University of Kansas</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Prasad</first_name>
          <last_name>Kulkarni</last_name>
          <affiliation>University of Kansas</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.ittc.ku.edu/~kulkarni/</homepage_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Michael</first_name>
          <last_name>Jantz</last_name>
          <affiliation>University of Tennessee</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>- The 18th Annual ACM SIGPLAN / SIGBED Conference on Languages, Compilers, and Tools for Embedded Systems</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>e736ec4e-5c92-4b81-bb98-51823d4caa15</slot_id>
      <title>Integrating Task Scheduling and Cache Locking for Multicore Real-time Embedded Systems</title>
      <room>LCTES-MainTrack</room>
      <date>2017/06/21</date>
      <start_time>14:00</start_time>
      <end_time>15:00</end_time>
      <description>Modern embedded processors provide hardware support for cache locking, a mechanism used to facilitate the WCET (Worst-Case Execution Time) calculation of a task. We investigate the problem of integrating task scheduling and cache locking for a set of pre-emptible tasks with individual release times and deadlines on a multicore processor with two level caches. We propose a novel integrated approach that schedules the task set and allocates the locked cache contents of each task to the local caches (L1 caches) and the level two cache (L2 cache). Our approach consists of three major components, the task scheduler, the L1 cache allocator, and the L2 cache allocator. The task scheduler aims at minimizing the number of task preemptions. The L1 cache allocator converts the interference graph of all the tasks scheduled on each core into a DAG by considering the preemptions between tasks and allocates L1 cache space to each task. The L2 cache allocator converts the interference graph of all the tasks into a DAG by using a k-longest-path based graph orientation algorithm and allocates L2 cache space to each task. Both cache allocators significantly improve the utilization of all the caches due to the efficient use of the interference graphs of tasks. We have implemented our approach and compared it with the extended version of the preemption tree-based approach and the static analysis approach without cache locking by using a set of benchmarks from the MRTC benchmark suite and SNU real-time benchmarks. Compared to the extended version of the preemption tree-based approach, the maximum WCRT (Worst Case Response Time) improvement of our approach is 15%. Compared to the static analysis approach, the maximum WCRT improvement of our approach is 37%.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Wenguang</first_name>
          <last_name>Zheng</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Hui</first_name>
          <last_name>Wu</last_name>
          <affiliation>University of New South Wales, Australia</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cse.unsw.edu.au/~huiw</homepage_url>
          <picture_url>http://pldi17.sigplan.org/getProfileImage/huiwu/e2ab7008-f775-4583-96c4-2dc092dbe6f1/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Chuanyao</first_name>
          <last_name>Nie</last_name>
          <affiliation>The University of New South Wales</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>- The 18th Annual ACM SIGPLAN / SIGBED Conference on Languages, Compilers, and Tools for Embedded Systems</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>f7445bbe-e8b4-47b7-a21b-64bcf737bb2c</slot_id>
      <title>Towards Memory-Efficient Processing-in-Memory Architecture for Convolutional Neural Networks</title>
      <room>LCTES-MainTrack</room>
      <date>2017/06/21</date>
      <start_time>14:00</start_time>
      <end_time>15:00</end_time>
      <description>Convolutional neural networks (CNNs) are widely adopted in artificial intelligent systems. In contrast to conventional computingcentric applications, the computational and memory resources of CNN applications are mixed together in the network weights. This incurs a significant amount of data movement, especially for highdimensional convolutions. Although recent embedded 3D-stacked Processing-in-Memory (PIM) architecture alleviates this memory bottleneck to provide fast near-data processing, memory is still a limiting factor of the entire system. An unsolved key challenge is how to efficiently allocate convolutions to 3D-stacked PIMto combine the advantages of both neural and computational processing.
This paper presents Memolution, a compiler-based memoryefficient data allocation strategy for convolutional neural networks on PIM architecture. Memolution offers thread-level parallelism that can fully exploit the computational power of PIMarchitecture. The objective is to capture the characteristics of neural network applications and present a hardware-independent design to transparently allocate CNN applications onto the underlining hardware resources provided by PIM. We demonstrate the viability of the proposed technique using a variety of realistic convolutional neural network applications. Our extensive evaluations show that, Memolution significantly improves performance and the cache utilization compared to the baseline scheme.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Yi</first_name>
          <last_name>Wang</last_name>
          <affiliation>Shenzhen University</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Mingxu</first_name>
          <last_name>Zhang</last_name>
          <affiliation>Shenzhen University</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Jing</first_name>
          <last_name>Yang</last_name>
          <affiliation>Harbin Institute of Technology</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>- The 18th Annual ACM SIGPLAN / SIGBED Conference on Languages, Compilers, and Tools for Embedded Systems</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>27e1b94d-9576-4475-a9f8-7fe937579ceb</subevent_id>
    <title>ARRAY 2017: Afternoon talks 1</title>
    <subevent_type type="regular"/>
    <room>PLDI-B</room>
    <date>2017/06/18</date>
    <url>http://pldi17.sigplan.org/track/array-2017</url>
    <url_link_display>ARRAY 2017</url_link_display>
    <tracks>
      <track>ARRAY 2017</track>
    </tracks>
    <timeslot>
      <slot_id>fd816f43-b8bd-4caf-8de4-a66d1fac9bec</slot_id>
      <title>Portable Vectorization and Parallelization of C++ Multi-Dimensional Array Computations</title>
      <room>PLDI-B</room>
      <date>2017/06/18</date>
      <start_time>15:00</start_time>
      <end_time>15:30</end_time>
      <description>This paper presents Legolas++ Arrays, a multi-dimensional array library. Legolas++ Arrays parametrized types enable data layout adaptation for specific Single Instruction Mul- tiple Data (SIMD) core architectures. The mapping of com- plex array-based kernels to regular collections of data is automatically and efficiently vectorized. In addition, Lego- las++ Arrays implementation can combine multi-threaded parallelism with SIMD acceleration. As an example, a direct tridiagonal solver applied to a collection of equally sized problems exhibits a speedup of more than &amp;times;22 on an 8-core SIMD processor.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Laurent</first_name>
          <last_name>Plagne</last_name>
          <affiliation>EDF Lab</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Kavoos</first_name>
          <last_name>Bojnourdi</last_name>
          <affiliation>EDF Lab</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>ARRAY 2017</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>648b94ea-5d7d-4e5b-8076-b149c88f1761</subevent_id>
    <title>LCTES 2017: Keynote 2</title>
    <subevent_type type="regular"/>
    <room>LCTES-MainTrack</room>
    <date>2017/06/22</date>
    <url>http://pldi17.sigplan.org/track/LCTES-2017-papers</url>
    <url_link_display>- The 18th Annual ACM SIGPLAN / SIGBED Conference on Languages, Compilers, and Tools for Embedded Systems</url_link_display>
    <tracks>
      <track>- The 18th Annual ACM SIGPLAN / SIGBED Conference on Languages, Compilers, and Tools for Embedded Systems</track>
    </tracks>
    <timeslot>
      <slot_id>000286ea-5740-441a-90e7-4122735bc4e0</slot_id>
      <title>Design versus Performance: From Giotto via the Embedded Machine to Selfie</title>
      <room>LCTES-MainTrack</room>
      <date>2017/06/22</date>
      <start_time>09:00</start_time>
      <end_time>10:00</end_time>
      <description>Engineering systems software is considered difficult. Performance considerations often dominate the overall development process resulting in significant code complexity. In our experience, however, completely ignoring performance, at least originally, may result in valuable insight and sometimes even more rigorous development methodologies that may still enable high performance designs. We discuss three examples developed over a period of around fifteen years: (1) Giotto, a real-time programming language based on logical execution time (LET), (2) the Embedded Machine, a virtual machine making real-time code portable including compiled Giotto programs, and (3) Selfie, a fully self-contained system of a tiny self-compiling C compiler, a tiny self-executing MIPS emulator targeted by the compiler, and a tiny self-hosting hypervisor virtualizing the emulator. Giotto shows how being slow can be leveraged to avoid non-determinism in real-time code. The Embedded Machine is an interpreter that may be slow but nevertheless makes code portable that appeared to be intrinsically non-portable. Selfie, finally, reveals that an operating system is a simple interpreter until people wanted speed.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Christoph</first_name>
          <last_name>Kirsch</last_name>
          <affiliation>University of Salzburg</affiliation>
          <bio>Christoph Kirsch is Professor at the Department of Computer Sciences of the University of Salzburg, Austria. He received his Dr.Ing. degree from Saarland University, Saarbr&amp;uuml;cken, Germany, in 1999 while at the Max Planck Institute for Computer Science. From 1999 to 2004 he worked as Postdoctoral Researcher at the Department of Electrical Engineering and Computer Sciences of the University of California, Berkeley. He later returned to Berkeley as Visiting Scholar (2008-2013) and Visiting Professor (2014) at the Department of Civil and Environmental Engineering as part of a collaborative research effort in Cyber-Physical Systems. His research interests are in concurrent programming, memory management, virtualization, and automated theorem proving. Dr. Kirsch co-invented embedded programming languages and systems such as Giotto, HTL, and the Embedded Machine, and more recently co-designed high-performance, multicore-scalable concurrent data structures and memory management systems. He co-founded the International Conference on Embedded Software (EMSOFT) and served as ACM SIGBED chair from 2011 until 2013 and ACM TODAES associate editor from 2011 until 2014. He is currently associate editor of IEEE TCAD.</bio>
          <homepage_url>http://cs.uni-salzburg.at/~ck</homepage_url>
          <picture_url>http://pldi17.sigplan.org/getProfileImage/christophkirsch/2adc8995-a32a-49c9-b820-8427e5a1f25a/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>- The 18th Annual ACM SIGPLAN / SIGBED Conference on Languages, Compilers, and Tools for Embedded Systems</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>d089818d-ff70-4cbc-9688-08d0e4a56f4f</subevent_id>
    <title>LCTES 2017: Session 3: Non-Volatile Memory/Processor and RTOS</title>
    <subevent_type type="regular"/>
    <room>LCTES-MainTrack</room>
    <date>2017/06/22</date>
    <url>http://pldi17.sigplan.org/track/LCTES-2017-papers</url>
    <url_link_display>- The 18th Annual ACM SIGPLAN / SIGBED Conference on Languages, Compilers, and Tools for Embedded Systems</url_link_display>
    <tracks>
      <track>- The 18th Annual ACM SIGPLAN / SIGBED Conference on Languages, Compilers, and Tools for Embedded Systems</track>
    </tracks>
    <timeslot>
      <slot_id>036b772f-7389-4cc1-b8ac-4540fe413b30</slot_id>
      <title>Unified nvTCAM and sTCAM Architecture for Improving Packet Matching Performance</title>
      <room>LCTES-MainTrack</room>
      <date>2017/06/22</date>
      <start_time>10:55</start_time>
      <end_time>11:20</end_time>
      <description>Software-Defined Networking (SDN) allows control applications to install fine-grained forwarding policies in the underlying switches. Ternary Content Addressable Memory (TCAM) enables fast lookups in hardware switches with flexible wildcard rule patterns. However, the performance of packet processing is severely constrained by the capacity of TCAM, aggravating the processing burden and latency issues. In this paper, we propose a hybrid TCAM architecture which consists of NVM-based TCAM (nvTCAM) and SRAM-based TCAM (sTCAM), utilizing nvTCAM to cache the most popular rules to improve cache-hit-ratio while relying on a very small-size sTCAM to handle cache-miss traffic to effectively decrease update latency. Considering the special rule dependency, we present a Rule Migration Replacement Algorithm to effectively make full utilization of both nvTCAM and sTCAM to obtain better performance. Experimental results show our proposed architecture outperforms current TCAM architectures.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Xianzhong</first_name>
          <last_name>Ding</last_name>
          <affiliation>Shandong  University</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Zhiyong</first_name>
          <last_name>Zhang</last_name>
          <affiliation>Shandong University</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Zhiping</first_name>
          <last_name>Jia</last_name>
          <affiliation>Shandong University</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Lei</first_name>
          <last_name>Ju</last_name>
          <affiliation>Shandong  University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.es.sdu.edu.cn/~julei/index_en.jsp</homepage_url>
          <picture_url>http://pldi17.sigplan.org/getProfileImage/julei/a60289aa-6246-41f8-a2a4-26522c0b0a16/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Mengying</first_name>
          <last_name>Zhao</last_name>
          <affiliation>Shandong University</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Huawei</first_name>
          <last_name>Huang</last_name>
          <affiliation>The University of Aizu</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>- The 18th Annual ACM SIGPLAN / SIGBED Conference on Languages, Compilers, and Tools for Embedded Systems</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>c00faa06-972f-4cc4-820b-90376fc13973</slot_id>
      <title>Towards Memory-Efficient Processing-in-Memory Architecture for Convolutional Neural Networks</title>
      <room>LCTES-MainTrack</room>
      <date>2017/06/22</date>
      <start_time>10:30</start_time>
      <end_time>10:55</end_time>
      <description>Convolutional neural networks (CNNs) are widely adopted in artificial intelligent systems. In contrast to conventional computingcentric applications, the computational and memory resources of CNN applications are mixed together in the network weights. This incurs a significant amount of data movement, especially for highdimensional convolutions. Although recent embedded 3D-stacked Processing-in-Memory (PIM) architecture alleviates this memory bottleneck to provide fast near-data processing, memory is still a limiting factor of the entire system. An unsolved key challenge is how to efficiently allocate convolutions to 3D-stacked PIMto combine the advantages of both neural and computational processing.
This paper presents Memolution, a compiler-based memoryefficient data allocation strategy for convolutional neural networks on PIM architecture. Memolution offers thread-level parallelism that can fully exploit the computational power of PIMarchitecture. The objective is to capture the characteristics of neural network applications and present a hardware-independent design to transparently allocate CNN applications onto the underlining hardware resources provided by PIM. We demonstrate the viability of the proposed technique using a variety of realistic convolutional neural network applications. Our extensive evaluations show that, Memolution significantly improves performance and the cache utilization compared to the baseline scheme.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Yi</first_name>
          <last_name>Wang</last_name>
          <affiliation>Shenzhen University</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Mingxu</first_name>
          <last_name>Zhang</last_name>
          <affiliation>Shenzhen University</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Jing</first_name>
          <last_name>Yang</last_name>
          <affiliation>Harbin Institute of Technology</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>- The 18th Annual ACM SIGPLAN / SIGBED Conference on Languages, Compilers, and Tools for Embedded Systems</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>de991bfe-ad7c-4107-aeeb-c8675c8715ad</slot_id>
      <title>A Lightweight Progress Maximization Scheduler for Non-Volatile Processor Under Unstable Energy Harvesting</title>
      <room>LCTES-MainTrack</room>
      <date>2017/06/22</date>
      <start_time>11:20</start_time>
      <end_time>11:45</end_time>
      <description>Energy harvesting techniques become increasingly popular as power supplies for embedded systems. However, the harvested energy is intrinsically unstable. Thus, the program execution may be interrupted frequently. Although the development of non-volatile processors (NVP) can save and restore execution states, both hardware and software challenges exist for energy harvesting powered embedded systems. On the hardware side, existing power detector only signals the ``poor’’ quality of the harvested power based on a preset threshold voltage. The inappropriate setting of this threshold will make the NVP system suffer from either unnecessary checkpointings or checkpointing failures. On the software side, not all tasks can be checkpointed. Once the power is off, these tasks will have to restart from the beginning. In this paper, a task scheduler is proposed to maximize task progress by prioritizing uncheckpointable tasks if power is weak so that they can finish before the power failure. To assist task scheduling, three additional modules including voltage monitor, checkpointing handler, and routine handler, are proposed. Experimental results show increased overall task progress and reduced energy consumption.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Chen</first_name>
          <last_name>Pan</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Mimi</first_name>
          <last_name>Xie</last_name>
          <affiliation>Oklahoma State University</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Yongpan</first_name>
          <last_name>Liu</last_name>
          <affiliation>Tsinghua University</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Yanzhi</first_name>
          <last_name>Wang</last_name>
          <affiliation>Syracuse University</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Jason</first_name>
          <last_name>Xue</last_name>
          <affiliation>City University of Hong Kong, China</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.cityu.edu.hk/~jasonxue/</homepage_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Yiran</first_name>
          <last_name>Chen</last_name>
          <affiliation>University of Pittsburgh</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>7</sort_key>
          <first_name>Jingtong</first_name>
          <last_name>Hu</last_name>
          <affiliation>Oklahoma State University</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>- The 18th Annual ACM SIGPLAN / SIGBED Conference on Languages, Compilers, and Tools for Embedded Systems</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>fb76314c-d299-4129-8667-b6d61d774eb8</slot_id>
      <title>OSEK-V: Application-Specific RTOS Instantiation in Hardware</title>
      <room>LCTES-MainTrack</room>
      <date>2017/06/22</date>
      <start_time>11:45</start_time>
      <end_time>12:10</end_time>
      <description>The employment of a real-time operating system (RTOS) in an embedded control systems is often an all-or-nothing decision: While the RTOS-abstractions provide for easier software composition and development, the price in terms of event latencies and memory costs are high. Especially in HW/SW codesign settings, system developers try to avoid the employment of a full-blown RTOS as far as possible. In OSEK-V, we mitigate this trade-off by a very aggressive tailoring of the concrete RTOS instance into the hardware. Instead of implementing generic OS components as custom hardware devices, we capture the actually possible application–kernel interactions as a finite-state machine and integrate the tailored RTOS semantics directly into the processor pipeline. In our experimental results with an OSEK-based implementation of a quadrotor flight controller into the Rocket/RISC-V softcore, we thereby can significantly reduce event latencies, interrupt lock times, and memory footprint at moderate costs in terms of FPGA resources.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Christian</first_name>
          <last_name>Dietrich</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Daniel</first_name>
          <last_name>Lohmann</last_name>
          <affiliation>Friedrich-Alexander-Universität, Germany</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www4.cs.fau.de/~lohmann</homepage_url>
        </person>
      </persons>
      <tracks>
        <track>- The 18th Annual ACM SIGPLAN / SIGBED Conference on Languages, Compilers, and Tools for Embedded Systems</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>9a644e32-c881-4582-a63e-31c48c7a5ff3</subevent_id>
    <title>ARRAY 2017: Afternoon talks 2</title>
    <subevent_type type="regular"/>
    <room>PLDI-B</room>
    <date>2017/06/18</date>
    <url>http://pldi17.sigplan.org/track/array-2017</url>
    <url_link_display>ARRAY 2017</url_link_display>
    <tracks>
      <track>ARRAY 2017</track>
    </tracks>
    <timeslot>
      <slot_id>36139a3c-9c25-47e2-a618-87161b57789f</slot_id>
      <title>HPTT: A High-Performance Tensor Transposition C++ Library</title>
      <room>PLDI-B</room>
      <date>2017/06/18</date>
      <start_time>17:00</start_time>
      <end_time>17:30</end_time>
      <description>Recently we presented TTC, a domain-specific compiler for tensor transpositions. Despite the fact that the performance of the generated code is nearly optimal, due to its offline nature, TTC cannot be utilized in all the application codes in which the tensor sizes and the necessary tensor permutations are determined at runtime. To overcome this limitation, we introduce the open-source C++ library High-Performance Tensor Transposition (HPTT). Similar to TTC, HPTT incorporates optimizations such as blocking, multi-threading, and explicit vectorization; furthermore it decomposes any transposition into multiple loops around a so called micro-kernel. This modular design—inspired by BLIS—makes HPTT easy to port to different architectures, by only replacing the hand-vectorized micro-kernel (e.g., a 4x4 transpose). HPTT also offers an optional autotuning framework—guided by a performance model—that explores a vast search space of implementations at runtime (similar to FFTW). Across a wide range of different tensor transpositions and architectures (e.g., Intel Ivy Bridge, ARMv7, IBM Power7), HPTT attains a bandwidth comparable to that of SAXPY, and yields remarkable speedups over Eigen’s tensor transposition implementation. Most importantly, the integration of HPTT into the Cyclops Tensor Framework (CTF) improves the overall performance of tensor contractions by up to 3.1x.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Paul</first_name>
          <last_name>Springer</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Tong</first_name>
          <last_name>Su</last_name>
          <affiliation>RWTH Aachen</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Paolo</first_name>
          <last_name>Bientinesi</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>ARRAY 2017</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>81456fbf-4cc3-46e6-a5cd-5c3e40b42327</slot_id>
      <title>Efficient Array Slicing on the Intel Xeon Phi Coprocessor</title>
      <room>PLDI-B</room>
      <date>2017/06/18</date>
      <start_time>16:00</start_time>
      <end_time>16:30</end_time>
      <description>Array slicing is an operation which selects a subset of elements from a source array and copies them into a destination array. In this article we present an algorithm for generating code for a subset of Fortran slicing expressions, targeting the Intel Xeon Phi coprocessor. The resulting code outperforms the code produced by Intel’s Fortran compiler by 2.40X on average for a set of slicing expressions, and by 2.23X and 1.13X on average for two slicing expressions relevant for border exchange code.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Benjamin</first_name>
          <last_name>Andreassen</last_name>
          <affiliation>Norwegian University of Science and Technology</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Jan</first_name>
          <last_name>Christian</last_name>
          <affiliation>Norwegian University of Science and Technology</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Lasse</first_name>
          <last_name>Natvig</last_name>
          <affiliation>Norwegian University of Science and Technology</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>ARRAY 2017</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>f3bf857e-3dda-481b-b149-8ffd24114548</slot_id>
      <title>Modular Array-based GPU Computing in a Dynamically-typed Language</title>
      <room>PLDI-B</room>
      <date>2017/06/18</date>
      <start_time>16:30</start_time>
      <end_time>17:00</end_time>
      <description>Nowadays, GPU accelerators are widely used in areas with large data-parallel computations such as scientific computations or neural networks. Programmers can either write code in low-level CUDA/OpenCL code or use a GPU extension for a high-level programming language for better productivity. Most extensions focus on statically-typed languages, but many programmers prefer dynamically-typed languages due to their simplicity and flexibility.
This paper shows how programmers can write high-level modular code in Ikra, a Ruby extension for array-based GPU computing. Programmers can compose GPU programs of multiple reusable parallel sections, which are subsequently fused into a small number of GPU kernels. We propose a seamless syntax for separating code regions that extensively use dynamic language features from those that are compiled for efficent execution. Moreover, we propose symbolic execution and a program analysis for kernel fusion to achieve performance that is close to hand-written CUDA code.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Matthias</first_name>
          <last_name>Springer</last_name>
          <affiliation>Tokyo Institute of Technology</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://m-sp.org</homepage_url>
          <picture_url>http://pldi17.sigplan.org/getProfileImage/matthiasspringer/18e44512-a532-4c0f-8e61-a1cdf818c416/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Peter</first_name>
          <last_name>Wauligmann</last_name>
          <affiliation>Tokyo Institute of Technology</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Hidehiko</first_name>
          <last_name>Masuhara</last_name>
          <affiliation>Tokyo Institute of Technology</affiliation>
          <bio>Hidehiko Masuhara is a Professor of Mathematical and Computing Science, Tokyo Institute of Technology since April 2013. He received his B.S., M.S., and Ph.D. in Computer Science from Department of Information Science, University of Tokyo in 1992, 1994, and 1999, respectively, and served as an assistant professor, lecturer, and associate professor at Graphics and Computer Science, Graduate School of Arts and Sciences, University of Tokyo from 1995 until 2013.</bio>
          <homepage_url>http://prg.is.titech.ac.jp/people/masuhara/</homepage_url>
          <picture_url>http://pldi17.sigplan.org/getProfileImage/hidehikomasuhara/3ea94269-6fb5-4c6d-8d6f-0435717377d6/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>ARRAY 2017</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>409afb52-8b1f-40d4-bd29-6dd3d788d212</subevent_id>
    <title>LCTES 2017: Session 2: Abstraction, Modelling and Scheduling for IoT and Embedded Systems</title>
    <subevent_type type="regular"/>
    <room>LCTES-MainTrack</room>
    <date>2017/06/21</date>
    <url>http://pldi17.sigplan.org/track/LCTES-2017-papers</url>
    <url_link_display>- The 18th Annual ACM SIGPLAN / SIGBED Conference on Languages, Compilers, and Tools for Embedded Systems</url_link_display>
    <tracks>
      <track>- The 18th Annual ACM SIGPLAN / SIGBED Conference on Languages, Compilers, and Tools for Embedded Systems</track>
    </tracks>
    <timeslot>
      <slot_id>03133336-d56a-47a3-b242-4e03a7562ac3</slot_id>
      <title>Efficient SMT-based LTL Model Checking of Clock Constraint Specification Language for Real-Time and Embedded Systems</title>
      <room>LCTES-MainTrack</room>
      <date>2017/06/21</date>
      <start_time>16:20</start_time>
      <end_time>16:45</end_time>
      <description>MARTE (abbreviated for Modeling and Analysis of Real-Time and Embedded systems) is a UML profile, used to facilitate the design and analysis of real-time and embedded systems. The Clock Constraint Specification Language (CCSL) is a formal language companion to MARTE, which is proposed to specify the constraint of the occurrences of events in systems. However, the language lacks efficient verification support to the formal analysis of temporal properties which are important to real-time and embedded systems. In this paper, we propose an SMT-based approach to model checking of the temporal properties specified in Linear Temporal Logic (LTL) for CCSL. We implement a prototype tool for the proposed approach and use the state-of-the-art tool Z3 as the underlying SMT solver. We model two practical cases including a traffic light controller and a power window system in CCSL, and verify LTL properties of the two systems using the proposed approach. Experimental results demonstrate the effectiveness of our approach.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Min</first_name>
          <last_name>Zhang</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Yunhui</first_name>
          <last_name>Ying</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>- The 18th Annual ACM SIGPLAN / SIGBED Conference on Languages, Compilers, and Tools for Embedded Systems</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>22c8d608-7dc6-4cbc-bde4-959d2e59e66e</slot_id>
      <title>Integrated IoT Programming with Selective Abstraction</title>
      <room>LCTES-MainTrack</room>
      <date>2017/06/21</date>
      <start_time>15:55</start_time>
      <end_time>16:20</end_time>
      <description>The explosion of networked devices has driven a new computing environment called the Internet of Things (IoT), enabling various services such as home automation and health monitoring. Despite the promising applicability of the IoT, developing an IoT service is challenging for programmers, because the programmers should integrate multiple programmable devices and heterogeneous third-party devices. Recent works have proposed integrated programming platforms, but they either require device-specific implementation for third-party devices without any device abstraction, or abstract all the devices to the standard interfaces requiring unnecessary abstraction of programmable devices. To integrate IoT devices with selective abstraction, this work revisits the object oriented programming (OOP) model, and proposes a new language extension and its compiler-runtime framework, called Esperanto. With three annotations that map each object to its corresponding IoT device, the Esperanto language allows programmers to integrate multiple programmable devices into one OOP program and to abstract similar third-party devices into their common ancestor classes. Given the annotations, the Esperanto compiler automatically partitions the integrated program into multiple sub-programs for each programmable IoT device, and inserts communication and synchronization code. Moreover, for the ancestor classes, the Esperanto runtime dynamically identifies connected third-party devices, and links their corresponding descendent objects. Compared to an existing approach on the integrated IoT programming, Esperanto requires 33.3% fewer lines of code to implement 5 IoT services, and reduces their response time by 44.8% on average.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Gyeongmin</first_name>
          <last_name>Lee</last_name>
          <affiliation>POSTECH</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Seonyeong</first_name>
          <last_name>Heo</last_name>
          <affiliation>POSTECH</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Bongjun</first_name>
          <last_name>Kim</last_name>
          <affiliation>POSTECH</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Jong</first_name>
          <last_name>Kim</last_name>
          <affiliation>POSTECH</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Hanjun</first_name>
          <last_name>Kim</last_name>
          <affiliation>POSTECH</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>- The 18th Annual ACM SIGPLAN / SIGBED Conference on Languages, Compilers, and Tools for Embedded Systems</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>42b7d3ec-11a6-4b5a-97fd-962b281f75d9</slot_id>
      <title>Optimal Functional Unit Assignment and Voltage Selection for Pipelined MPSoC with Guaranteed Probability on Time Performance</title>
      <room>LCTES-MainTrack</room>
      <date>2017/06/21</date>
      <start_time>15:30</start_time>
      <end_time>15:55</end_time>
      <description>Pipelined heterogeneous multiprocessor system-on-chip (MPSoC) can provide high throughput for streaming applications. In the design of such systems, time performance and system cost are the most concerning issues. By analyzing runtime behaviors of benchmarks in real-world platforms, we find that execution times of tasks are not fixed but spread with probabilities. In terms of this feature, we model execution times of tasks as random variables. In this paper, we study how to design high-performance and low-cost MPSoC systems to execute a set of such tasks with data dependencies in a pipelined fashion. Our objective is to obtain the optimal functional unit assignment and voltage selection for the pipelined MPSoC systems, such that the system cost is minimized while timing constraints can be met with a given guaranteed probability. For each required probability, our proposed algorithm can efficiently obtain the optimal solution. Experiments show that other existing algorithms cannot find feasible solutions in most cases, but ours can. Even for those solutions that other algorithms can obtain, ours can reach 30% reductions in total cost compared with others.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Weiwen</first_name>
          <last_name>Jiang</last_name>
          <affiliation>Chongqing University</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Edwin</first_name>
          <last_name>Sha</last_name>
          <affiliation>Chongqing University</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Qingfeng</first_name>
          <last_name>Zhuge</last_name>
          <affiliation>Chongqing University, China</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.cqu.edu.cn/en/supervisors</homepage_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Hailiang</first_name>
          <last_name>Dong</last_name>
          <affiliation>Chongqing University</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Xianzhang</first_name>
          <last_name>Chen</last_name>
          <affiliation>Chongqing University</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>- The 18th Annual ACM SIGPLAN / SIGBED Conference on Languages, Compilers, and Tools for Embedded Systems</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>95895f92-a3f1-40d4-96b3-b77b0c0e97b3</slot_id>
      <title>Integrating Task Scheduling and Cache Locking for Multicore Real-time Embedded Systems</title>
      <room>LCTES-MainTrack</room>
      <date>2017/06/21</date>
      <start_time>16:45</start_time>
      <end_time>17:10</end_time>
      <description>Modern embedded processors provide hardware support for cache locking, a mechanism used to facilitate the WCET (Worst-Case Execution Time) calculation of a task. We investigate the problem of integrating task scheduling and cache locking for a set of pre-emptible tasks with individual release times and deadlines on a multicore processor with two level caches. We propose a novel integrated approach that schedules the task set and allocates the locked cache contents of each task to the local caches (L1 caches) and the level two cache (L2 cache). Our approach consists of three major components, the task scheduler, the L1 cache allocator, and the L2 cache allocator. The task scheduler aims at minimizing the number of task preemptions. The L1 cache allocator converts the interference graph of all the tasks scheduled on each core into a DAG by considering the preemptions between tasks and allocates L1 cache space to each task. The L2 cache allocator converts the interference graph of all the tasks into a DAG by using a k-longest-path based graph orientation algorithm and allocates L2 cache space to each task. Both cache allocators significantly improve the utilization of all the caches due to the efficient use of the interference graphs of tasks. We have implemented our approach and compared it with the extended version of the preemption tree-based approach and the static analysis approach without cache locking by using a set of benchmarks from the MRTC benchmark suite and SNU real-time benchmarks. Compared to the extended version of the preemption tree-based approach, the maximum WCRT (Worst Case Response Time) improvement of our approach is 15%. Compared to the static analysis approach, the maximum WCRT improvement of our approach is 37%.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Wenguang</first_name>
          <last_name>Zheng</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Hui</first_name>
          <last_name>Wu</last_name>
          <affiliation>University of New South Wales, Australia</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cse.unsw.edu.au/~huiw</homepage_url>
          <picture_url>http://pldi17.sigplan.org/getProfileImage/huiwu/e2ab7008-f775-4583-96c4-2dc092dbe6f1/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Chuanyao</first_name>
          <last_name>Nie</last_name>
          <affiliation>The University of New South Wales</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>- The 18th Annual ACM SIGPLAN / SIGBED Conference on Languages, Compilers, and Tools for Embedded Systems</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>92ccf2c3-5d08-49b9-9fff-7b9cd1000076</subevent_id>
    <title>LCTES 2017: Session 1: Compiler Optimization for Embedded Systems</title>
    <subevent_type type="regular"/>
    <room>LCTES-MainTrack</room>
    <date>2017/06/21</date>
    <url>http://pldi17.sigplan.org/track/LCTES-2017-papers</url>
    <url_link_display>- The 18th Annual ACM SIGPLAN / SIGBED Conference on Languages, Compilers, and Tools for Embedded Systems</url_link_display>
    <tracks>
      <track>- The 18th Annual ACM SIGPLAN / SIGBED Conference on Languages, Compilers, and Tools for Embedded Systems</track>
    </tracks>
    <timeslot>
      <slot_id>002db108-6d4f-4321-bfc9-98e3d933957b</slot_id>
      <title>Dynamic Translation of Structured Loads/Stores and Register Mapping for Architectures with SIMD Extensions</title>
      <room>LCTES-MainTrack</room>
      <date>2017/06/21</date>
      <start_time>12:05</start_time>
      <end_time>12:30</end_time>
      <description>More and more modern processors have been supporting non-contiguous SIMD data accesses. However, translating such instructions has been overlooked in the Dynamic Binary Translation (DBT) area. For example, in the popular QEMU dynamic binary translator, guest memory instructions with strides are emulated by a sequence of scalar instructions, leaving a significant room for performance improvement when the host machines have SIMD instructions available. Structured loads/stores, such as VLDn/VSTn in ARM NEON, are one type of strided SIMD data access instructions. They are widely used in signal processing, multimedia, mathematical and 2D matrix transposition applications. Efficient translation of such structured loads/stores is a critical issue when migrating ARM executables to other ISAs. However, it is quite challenging since not only the translation of structured loads/stores is not trivial, but also the difference between guest and host register configurations must be taken into consideration. In this work, we present the design and implementation of translating structured loads/stores in DBT, including target code generation as well as efficient SIMD register mapping. Our proposed register mapping mechanisms are not limited to handling structured load/stores, they can be extended to deal with normal SIMD instructions. On a set of OpenCV benchmarks, our QEMU-based system has achieved a maximum speedup of 5.41x, with an average improvement of 2.93x. On a set of BLAS benchmarks, our system has also obtained a maximum speedup of 2.19x and an average improvement of 1.63x.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Sheng-Yu</first_name>
          <last_name>Fu</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Ding-Yong</first_name>
          <last_name>Hong</last_name>
          <affiliation>Institute of Information Science, Academia Sinica</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Yu-Ping</first_name>
          <last_name>Liu</last_name>
          <affiliation>Department of Computer Science and Information Engineering, National Taiwan University</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Jan-Jan</first_name>
          <last_name>Wu</last_name>
          <affiliation>Institute of Information Science, Academia Sinica</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Wei-Chung</first_name>
          <last_name>Hsu</last_name>
          <affiliation>Dept. Computer Science &amp; Information Engineering, National Taiwan University</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>- The 18th Annual ACM SIGPLAN / SIGBED Conference on Languages, Compilers, and Tools for Embedded Systems</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>351ab6b3-2fa5-480e-a823-19302a0d46f8</slot_id>
      <title>Adaptive Optimization for OpenCL Programs on Embedded Heterogeneous Systems</title>
      <room>LCTES-MainTrack</room>
      <date>2017/06/21</date>
      <start_time>11:15</start_time>
      <end_time>11:40</end_time>
      <description>Heterogeneous multi-core architectures consisting of CPUs and GPUs are commonplace in today’s embedded systems. These architectures offer potential for energy efficient computing if the application task is mapped to the right core. Realizing such potential is challenging due to the complex and evolving natural of hardware and applications. This paper presents an automatic approach to map OpenCL kernels onto heterogeneous multi-cores for a given optimization criterion – whether it is faster runtime, lower energy consumption or a trade-off between them. This is achieved by developing a machine learning based approach to predict which processor to use to run the OpenCL kernel and the host program, and at what frequency the processor should operate. Instead of hand-tuning a model for each optimization metric, we use machine learning to develop a unified framework that first automatically learns the optimization heuristic for each metric off-line, and then uses the learned knowledge to schedule OpenCL kernels at runtime based on code and runtime information of the program. We apply our approach to a set of representative \OpenCL benchmarks and evaluate it on an ARM big.LITTLE mobile platform. Our approach achieves over 93% of the performance delivered by an oracle predictor. We obtain, on average, 1.2x, 1.6x, and 1.8x improvement respectively for runtime, energy consumption and the energy delay product, when compared to a state-of-the-art heterogeneous-aware OpenCL task mapping scheme.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Ben</first_name>
          <last_name>Taylor</last_name>
          <affiliation>Lancaster University, UK</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Vicent Sanz</first_name>
          <last_name>Marco</last_name>
          <affiliation>Lancaster University</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Zheng</first_name>
          <last_name>Wang</last_name>
          <affiliation>Lancaster University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.lancaster.ac.uk/staff/wangz3/</homepage_url>
          <picture_url>http://pldi17.sigplan.org/getProfileImage/zhengwang/9f51ef64-4f51-41e2-8d62-4a954783d991/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>- The 18th Annual ACM SIGPLAN / SIGBED Conference on Languages, Compilers, and Tools for Embedded Systems</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>6b673349-326d-4385-8b13-f8f5eac5cdde</slot_id>
      <title>Auto-Vectorization for Image Processing DSLs</title>
      <room>LCTES-MainTrack</room>
      <date>2017/06/21</date>
      <start_time>11:40</start_time>
      <end_time>12:05</end_time>
      <description>The parallelization of programs and distributing their workloads to multiple threads can be a challenging task. In addition to multi- threading, harnessing vector units in CPUs proves highly desirable. However, employing vector units to speed up programs can be quite tedious. Either a program developer solely relies on the auto-vectorization capabilities of the compiler or he manually applies vector intrinsics, which is extremely error-prone, difficult to maintain, and not portable at all. Based on whole-function vectorization, a method to replace con- trol flow with data flow, we propose auto-vectorization techniques for image processing DSLs in the context of source-to-source com- pilation. The approach does not require the input to be available in SSA form. Moreover, we formulate constraints under which the vectorization analysis and code transformations may be greatly sim- plified in the context of image processing DSLs. As part of our methodology, we present control flow to data flow transformation as a source-to-source translation. Moreover, we propose a method to efficiently analyze algorithms with mixed bit-width data types to determine the optimal SIMD width, independently of the target instruction set. The techniques are integrated into an open source DSL framework. Subsequently, the vectorization capabilities are compared to a variety of existing state-of-the-art C/C ++ compilers. Speedups of up to 7.4 are observed for benchmarks taken from ISPC and image processing, compared to non-vectorized executions.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Oliver</first_name>
          <last_name>Reiche</last_name>
          <affiliation>Friedrich-Alexander-Universität Erlangen-Nürnberg (FAU)</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www12.cs.fau.de/people/reiche/</homepage_url>
          <picture_url>http://pldi17.sigplan.org/getProfileImage/oliverreiche/866f2dfe-ced2-4bf6-adaf-530acc81fa16/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Christof</first_name>
          <last_name>Kobylko</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Frank</first_name>
          <last_name>Hannig</last_name>
          <affiliation>Friedrich-Alexander University Erlangen-Nürnberg (FAU)</affiliation>
          <bio>Frank Hannig leads the Architecture and Compiler Design Group in the CS Department at Friedrich-Alexander University Erlangen-N&amp;uuml;rnberg (FAU), Germany, since 2004. He received a diploma degree in an interdisciplinary course of study in EE and CS from the University of Paderborn, Germany in 2000 and a Ph.D. degree (Dr.-Ing.) in CS from FAU in 2009. His main research interests are the design of massively parallel architectures, ranging from dedicated hardware to multi-core architectures, mapping methodologies for domain-specific computing, and architecture/compiler co-design. Frank has authored or coauthored more than 120 peer-reviewed publications. He serves on the program committees of several international conferences (ARC, ASAP, CODES+ISSS, DATE, DASIP, SAC). Frank is a senior member of the IEEE.</bio>
          <homepage_url>https://www12.cs.fau.de/people/hannig/</homepage_url>
          <picture_url>http://pldi17.sigplan.org/getProfileImage/frankhannig/cd43fb9e-78a0-4928-ab52-27b847d9ebcc/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Jürgen</first_name>
          <last_name>Teich</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>- The 18th Annual ACM SIGPLAN / SIGBED Conference on Languages, Compilers, and Tools for Embedded Systems</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>7fd93fd6-495f-4550-bdba-f50014af12c1</slot_id>
      <title>AOT Vs. JIT: Impact of Profile Data on Code Quality</title>
      <room>LCTES-MainTrack</room>
      <date>2017/06/21</date>
      <start_time>10:50</start_time>
      <end_time>11:15</end_time>
      <description>Just-in-time (JIT) compilation during program execution and ahead-of-time (AOT) compilation during software installation are alternate techniques used by managed language virtual machines (VM) to generate optimized native code while simultaneously achieving binary code portability and high execution performance. Profile data collected by JIT compilers at run-time can enable profile-guided optimizations (PGO) to customize the generated native code to different program inputs. AOT compilation removes the speed and energy overhead of online profile collection and dynamic compilation, but may not be able to achieve the quality and performance of customized native code. The goal of this work is to investigate and quantify the implications of the AOT compilation model on the quality of the generated native code for current VMs. 
First, we quantify the quality of native code generated by the two compilation models for a state-of-the-art (HotSpot) Java VM. Second, we determine how the amount of profile data collected affects the quality of generated code. Third, we develop a mechanism to determine the accuracy or similarity for different profile data for a given program run, and investigate how the accuracy of profile data affects its ability to effectively guide PGOs. Finally, we categorize the profile data types in our VM and explore the contribution of each such category to performance.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>April W.</first_name>
          <last_name>Wade</last_name>
          <affiliation>University of Kansas</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Prasad</first_name>
          <last_name>Kulkarni</last_name>
          <affiliation>University of Kansas</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.ittc.ku.edu/~kulkarni/</homepage_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Michael</first_name>
          <last_name>Jantz</last_name>
          <affiliation>University of Tennessee</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>- The 18th Annual ACM SIGPLAN / SIGBED Conference on Languages, Compilers, and Tools for Embedded Systems</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>72af39c4-c166-458e-b943-749aa8ac3594</subevent_id>
    <title>ARRAY 2017: Morning talks 2</title>
    <subevent_type type="regular"/>
    <room>PLDI-B</room>
    <date>2017/06/18</date>
    <url>http://pldi17.sigplan.org/track/array-2017</url>
    <url_link_display>ARRAY 2017</url_link_display>
    <tracks>
      <track>ARRAY 2017</track>
    </tracks>
    <timeslot>
      <slot_id>a8535a86-be90-4fd7-b923-07b1c8605df6</slot_id>
      <title>An ELI-to-C Compiler: Design, Implementation and Performance</title>
      <room>PLDI-B</room>
      <date>2017/06/18</date>
      <start_time>11:00</start_time>
      <end_time>11:30</end_time>
      <description>ELI is a succinct array-based interactive programming language derived from APL. In this paper we present the overall design and implementation of a bootstrapped ELI-to-C compiler which is implemented in ELI. We provide a brief introduction to the ELI language, a high-level view of the code generation strategy, and a description of our bootstrapping process. We also provide a preliminary performance evaluation. Firstly, we use three existing C benchmarks to demonstrate the performance of the ELI-generated C code as compared with interpreted ELI and native C. Secondly, we use two benchmarks originally from APL to compare the ELI-generated C to interpreted ELI and a naive hand-generated C version. These preliminary results are encouraging, showing speedups over the interpreter and in many cases performance close to C. The results also show that some future optimizations, such as copy elimination/avoidance, would be beneficial.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Hanfeng</first_name>
          <last_name>Chen</last_name>
          <affiliation>McGill University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.sable.mcgill.ca/~hanfeng.c/</homepage_url>
          <picture_url>http://pldi17.sigplan.org/getProfileImage/hanfengchen/dbce785a-ff66-4180-9241-a5a14a8b7642/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Wai-Mee</first_name>
          <last_name>Ching</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Laurie</first_name>
          <last_name>Hendren</last_name>
          <affiliation>McGill University, Canada</affiliation>
          <bio>I am a Professor of Computer Science at McGill University, Montreal, Canada. I hold the Canada Research Chair in Compiler Tools and Techniques and am a Fellow of the ACM and a Fellow of the Royal Society of Canada.
Historically my main area of research area has been the development of compilers for object-oriented and aspect-oriented programming languages. I also have a long-standing interest in pointer analysis and program analysis frameworks.
My most recent research focus is on how to bring our compiler expertise to the world of scientists and engineers, and in particular how to support effective and efficient programming in the dynamic programming language MATLAB. To kick-start research in this area we are building a toolkit, McLAB (http://www.sable.mcgill.ca/mclab/), to support language extensions, compiler optimizations and transformations, virtual machines and JITs, and program understanding/refactoring tools for MATLAB and extensions of MATLAB.
An important facet of my work is that new research ideas should be developed along with software infrastructures to test those ideas. This has led to the development of many publicly available software frameworks, more details can be found on the group’s web site at http://www.sable.mcgill.ca . Our research group hopes that other groups will use their software, and will contribute new pieces back them so that all compiler groups can benefit from the work.</bio>
          <homepage_url>http://www.sable.mcgill.ca/~hendren/</homepage_url>
          <picture_url>http://pldi17.sigplan.org/getProfileImage/lauriehendren/cbe09b6f-7703-4f46-8bd8-a6cdf3425cc8/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>ARRAY 2017</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>b92f0659-f713-4e74-9358-80928172c111</slot_id>
      <title>Array Programming in Whiley</title>
      <room>PLDI-B</room>
      <date>2017/06/18</date>
      <start_time>11:30</start_time>
      <end_time>12:00</end_time>
      <description>Arrays are a fundamental mechanism for developing and reasoning about programs. Using them, one can easily encode a range of important algorithms from various domains, such as for sorting, graph traversal, heap manipulation and more. However, the encoding of such problems in traditional languages is relatively opaque. That is, such programming languages do not allow those properties important for the given problem to be encoded within the language itself and, instead, rely up on programmer-supplied comments.
This paper explores how array-based programming is enhanced by programming languages which support specifications and invariants over arrays. Examples of such systems include Dafny, Why3, Whiley, Spec# and more. For this paper, we choose Whiley as this language provides good support for array-based programming. Whiley is a programming language designed for verification and employs a verifying compiler to ensure that programs meet their specifications. A number of features make Whiley particularly suitable for array-based programming, such as type invariants and abstract properties. We explore this through a series of worked examples.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>David</first_name>
          <last_name>Pearce</last_name>
          <affiliation>Victoria University of Wellington</affiliation>
          <bio>David (@whileydave) graduated with a PhD from Imperial College London in 2005, and took up a lecturer position at Victoria University of Wellington, NZ. David’s PhD thesis was on efficient algorithms for pointer analysis of C, and his techniques have since been incorporated into GCC. His interests are in programming languages, compilers and static analysis.
Since 2009, he has been developing the Whiley Programming Language (whiley.org) which is designed specifically to simplify program verification. Prior to that, David developed the Java Compiler Kit (JKit), which is an open source Java Compiler aimed at simplifying static analysis.
David has previously interned at Bell Labs, New Jersey, where he worked on compilers for FPGAs; and also at IBM Hursely, UK, where he worked with the AspectJ development team on profiling systems.</bio>
          <homepage_url>http://homepages.ecs.vuw.ac.nz/~djp/</homepage_url>
          <picture_url>http://pldi17.sigplan.org/getProfileImage/davidpearce/22bf61c2-1912-4f75-a0a6-fc77ea16dd34/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>ARRAY 2017</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>c2cf0829-be36-4445-bb28-9dd3f654ad94</slot_id>
      <title>Flexible Data Views: Design and Implementation</title>
      <room>PLDI-B</room>
      <date>2017/06/18</date>
      <start_time>12:00</start_time>
      <end_time>12:30</end_time>
      <description>In this paper, we present a library-based framework of data views over chunks of memory segments. Such views not only enable a uniform treatment of references and arrays, but they provide a more general abstraction in the sense that parts of arrays, references, or even views, can be combined into hierarchies to form new logical data structures. To provide efficient implementations in widely used industrial languages such as C++ and Scala, we employ static and dynamic multi-staging techniques, respectively. Through staging and code specialization, the overhead of traversal and tracking of such view hierarchies is mostly eliminated. Thus, our data views can be used as building blocks for creating data structures for which programmers need not pick a specific representation but can rely on code generation and specialization to provide the right implementation that meets asymptotic running time and space guarantees. We apply our approach in case studies in which two-dimensional array views are used to efficiently encode real-world matrices, showing performance on par with specialized data structures such as sparse matrices from popular linear algebra libraries (Armadillo and Eigen), or hand-tuned dense representations. We also show the practicality of specializing data views at run-time on the JVM via Lightweight Modular Staging, a Scala framework for dynamic multi-stage programming, by designing a user-friendly API that hides the underlying compilation through lazy evaluation and a uniform access principle.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Leo</first_name>
          <last_name>Osvald</last_name>
          <affiliation>Purdue University, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://losvald.github.io/</homepage_url>
          <picture_url>http://pldi17.sigplan.org/getProfileImage/leoosvald/c3133578-a5cb-4a62-b264-f5f112cacb7a/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Tiark</first_name>
          <last_name>Rompf</last_name>
          <affiliation>Purdue University</affiliation>
          <bio>Tiark Rompf is an assistant professor at Purdue University. His work focuses on runtime code generation, advanced compiler technology, and associated language support. From 2008 to 2014 he was a member of Martin Odersky’s Scala team at EPFL where he developed the LMS compiler framework and made various contributions to the Scala language and toolchain (delimited continuations, efficient immutable data structures, compiler speedups, type system work).</bio>
          <homepage_url>http://tiarkrompf.github.io/</homepage_url>
          <picture_url>http://pldi17.sigplan.org/getProfileImage/tiarkrompf/0262a01e-7fda-45b0-92d8-4ba269ad7997/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>ARRAY 2017</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>946979d4-6abb-47f1-a547-7f4e3df75ede</subevent_id>
    <title>Catering: Lunch with ECOOP,LCTES (provided) + SRC Awards</title>
    <subevent_type type="regular"/>
    <room>PLDI-CoffeeBreaks</room>
    <date>2017/06/21</date>
    <url>http://pldi17.sigplan.org/track/pldi-2017-catering</url>
    <url_link_display>Catering</url_link_display>
    <tracks>
      <track>Catering</track>
    </tracks>
    <timeslot>
      <slot_id>7939d089-4b68-4c19-999a-b6e876a8a688</slot_id>
      <title>Lunch</title>
      <room>PLDI-CoffeeBreaks</room>
      <date>2017/06/21</date>
      <start_time>12:30</start_time>
      <end_time>14:00</end_time>
      <description>Lunch</description>
      <tracks>
        <track>Catering</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>d9150125-da60-451e-a5a5-eee5c38d964a</subevent_id>
    <title>Catering: Coffee Break</title>
    <subevent_type type="regular"/>
    <room>PLDI-CoffeeBreaks</room>
    <date>2017/06/20</date>
    <url>http://pldi17.sigplan.org/track/pldi-2017-catering</url>
    <url_link_display>Catering</url_link_display>
    <tracks>
      <track>Catering</track>
    </tracks>
    <timeslot>
      <slot_id>f6fd1b51-daf4-49b4-8940-893093abee02</slot_id>
      <title>Break</title>
      <room>PLDI-CoffeeBreaks</room>
      <date>2017/06/20</date>
      <start_time>15:40</start_time>
      <end_time>16:10</end_time>
      <description>Break</description>
      <tracks>
        <track>Catering</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>a8bfa3eb-ee21-471b-be2f-69a18fdd80e3</subevent_id>
    <title>Catering: Coffee Break</title>
    <subevent_type type="regular"/>
    <room>PLDI-CoffeeBreaks</room>
    <date>2017/06/20</date>
    <url>http://pldi17.sigplan.org/track/pldi-2017-catering</url>
    <url_link_display>Catering</url_link_display>
    <tracks>
      <track>Catering</track>
    </tracks>
    <timeslot>
      <slot_id>cddcd7e4-b2df-4654-a736-ee48d337cf1d</slot_id>
      <title>Break</title>
      <room>PLDI-CoffeeBreaks</room>
      <date>2017/06/20</date>
      <start_time>10:25</start_time>
      <end_time>10:50</end_time>
      <description>Break</description>
      <tracks>
        <track>Catering</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>1ebaf683-5b16-4e93-a833-b7d726cfe53f</subevent_id>
    <title>Catering: Lunch (provided)</title>
    <subevent_type type="regular"/>
    <room>PLDI-CoffeeBreaks</room>
    <date>2017/06/19</date>
    <url>http://pldi17.sigplan.org/track/pldi-2017-catering</url>
    <url_link_display>Catering</url_link_display>
    <tracks>
      <track>Catering</track>
    </tracks>
    <timeslot>
      <slot_id>4eafde99-191d-4c18-ba78-c75399f5dafd</slot_id>
      <title>Lunch</title>
      <room>PLDI-CoffeeBreaks</room>
      <date>2017/06/19</date>
      <start_time>12:30</start_time>
      <end_time>14:00</end_time>
      <description>Lunch</description>
      <tracks>
        <track>Catering</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>da918f9b-cf27-4f77-9ce8-73ad5ae4c05e</subevent_id>
    <title>Catering: Social Event with Curry On (dinner provided)</title>
    <subevent_type type="regular"/>
    <room>PLDI-CoffeeBreaks</room>
    <date>2017/06/19</date>
    <url>http://pldi17.sigplan.org/track/pldi-2017-catering</url>
    <url_link_display>Catering</url_link_display>
    <tracks>
      <track>Catering</track>
    </tracks>
    <timeslot>
      <slot_id>91f1425c-c603-4c00-a405-ce6a21ee090a</slot_id>
      <title>Dinner</title>
      <room>PLDI-CoffeeBreaks</room>
      <date>2017/06/19</date>
      <start_time>19:00</start_time>
      <end_time>22:00</end_time>
      <description>Dinner</description>
      <tracks>
        <track>Catering</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>968c5a59-a1fd-4cf8-a09a-719929009378</subevent_id>
    <title>Catering: Coffee Break</title>
    <subevent_type type="regular"/>
    <room>PLDI-CoffeeBreaks</room>
    <date>2017/06/19</date>
    <url>http://pldi17.sigplan.org/track/pldi-2017-catering</url>
    <url_link_display>Catering</url_link_display>
    <tracks>
      <track>Catering</track>
    </tracks>
    <timeslot>
      <slot_id>97cc11a3-8983-44f1-a131-bf9f8ec72d4e</slot_id>
      <title>Break</title>
      <room>PLDI-CoffeeBreaks</room>
      <date>2017/06/19</date>
      <start_time>15:40</start_time>
      <end_time>16:10</end_time>
      <description>Break</description>
      <tracks>
        <track>Catering</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>3e93f620-bdf1-4d6e-a68c-fe5a8ea38342</subevent_id>
    <title>Catering: Coffee Break</title>
    <subevent_type type="regular"/>
    <room>PLDI-CoffeeBreaks</room>
    <date>2017/06/19</date>
    <url>http://pldi17.sigplan.org/track/pldi-2017-catering</url>
    <url_link_display>Catering</url_link_display>
    <tracks>
      <track>Catering</track>
    </tracks>
    <timeslot>
      <slot_id>97fd3ea2-2620-42b1-b227-a5183e3c13d2</slot_id>
      <title>Break</title>
      <room>PLDI-CoffeeBreaks</room>
      <date>2017/06/19</date>
      <start_time>10:30</start_time>
      <end_time>10:50</end_time>
      <description>Break</description>
      <tracks>
        <track>Catering</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>ffebb162-12eb-48ba-9178-bbbbb48325cb</subevent_id>
    <title>Catering: Coffee Break</title>
    <subevent_type type="regular"/>
    <room>PLDI-CoffeeBreaks</room>
    <date>2017/06/21</date>
    <url>http://pldi17.sigplan.org/track/pldi-2017-catering</url>
    <url_link_display>Catering</url_link_display>
    <tracks>
      <track>Catering</track>
    </tracks>
    <timeslot>
      <slot_id>c714c0da-4280-443b-8a26-94dde54f2883</slot_id>
      <title>Break</title>
      <room>PLDI-CoffeeBreaks</room>
      <date>2017/06/21</date>
      <start_time>09:55</start_time>
      <end_time>10:20</end_time>
      <description>Break</description>
      <tracks>
        <track>Catering</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>dc87d61f-6c7e-47e7-956a-3b60658ba90e</subevent_id>
    <title>Catering: Lunch (provided)</title>
    <subevent_type type="regular"/>
    <room>PLDI-CoffeeBreaks</room>
    <date>2017/06/20</date>
    <url>http://pldi17.sigplan.org/track/pldi-2017-catering</url>
    <url_link_display>Catering</url_link_display>
    <tracks>
      <track>Catering</track>
    </tracks>
    <timeslot>
      <slot_id>28744687-14b5-4183-9d9a-6fb1fd94db4a</slot_id>
      <title>Lunch</title>
      <room>PLDI-CoffeeBreaks</room>
      <date>2017/06/20</date>
      <start_time>12:30</start_time>
      <end_time>14:00</end_time>
      <description>Lunch</description>
      <tracks>
        <track>Catering</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>75a82cdf-838c-4eb6-9a01-6f676a471d91</subevent_id>
    <title>Tutorials: WALA Hack-A-Thon</title>
    <subevent_type type="regular"/>
    <room>PLDI-D</room>
    <date>2017/06/22</date>
    <url>http://pldi17.sigplan.org/track/pldi-2017-workshops-and-tutorials</url>
    <url_link_display>Tutorials</url_link_display>
    <tracks>
      <track>Tutorials</track>
    </tracks>
    <timeslot>
      <slot_id>7fda3b70-a61e-4957-8d8a-8336ca5c8e24</slot_id>
      <title>WALA Hack-A-Thon</title>
      <room>PLDI-D</room>
      <date>2017/06/22</date>
      <start_time>09:00</start_time>
      <end_time>18:00</end_time>
      <description>Abstract
In the past, we have done WALA-focused workshops and tutorials at various editions of PLDI. They have been reasonably attended most of the time, and they may have encouraged people to check out WALA. While there has been significant development in WALA which could justify another tutorial around its JavaScript functionality, we think it might be even more useful to have a WALA “hack-a-thon” instead. 
In this hackathon, would be structured by people choosing some set of ideas that we are trying to develop, and all of us working intensively on them during the hackathon. It would be a good opportunity for WALA hackers to share knowledge and also for people interested in working with WALA to get started with plenty of help. The goal would be for participants to further their own work with WALA, or to join WALA-based research that appeals to them. The assumption is that participants would largely be students, for whom this would be an opportunity to either further their current projects, join in other existing work, or find new research directions. We hope that this hack-a-thon will be a good opportunity for the community of WALA users to come together to work with WALA and share knowledge and ideas.
Activities
For this hack-a-thon, people can come and work on any of their current projects involving WALA. There will be knowledgeable WALA users and some of its creators at the hack-a-thon, and so interactive support and question answering will be more available than normal. It will be a good place to share thoughts and tips on how to use WALA, too.
For groups that are already significant users of and contributors to WALA, having people at the hack-a-thon would be a good opportunity for us to work together directly to take contributions and also to address any issues in WALA that make using it less than ideal. For people getting started with WALA, the hack-a-thon could be a good opportunity to get set up and working.
On the other hand, we also have several topics that would make a good focus for projects specific to the hack-a-thon. People could work in groups of whatever size to make progress on advancing WALA. While these ideas are mostly infrastructure related, they feed rather directly into research questions:
Swift Support
Apple is a dominant player in the mobile space, and Swift is its new language for writing mobile apps. While Apple provides tooling based on LLVM, current research analysis frameworks have little support for Swift. Given the amount of published work on Android, based on available infrastructure, we believe support for Swift would enable a wide range of new work. Apple’s security model is significantly different from that of Android, for example, and similarly Swift is rather different from popular languages on Android; it would be interesting to understand how these aspects affect program analysis. There is ongoing work on Swift support now, and we expect to have some basic level of functionality for people to explore at the hack-a-thon.
We are also very excited that Devin Coughlin, from the Swift team at Apple, will be at the hack-a-thon. Devin has expertise both in program analysis and in Apple’s Swift infrastructure, including the Swift Intermediate Language on which we are basing Swift support in WALA.
Concrete project idea: evaluate Swift call graph construction for some open source Swift code, and create any needed special-purpose context sensitivity policies to avoid precision loss in the face of advanced Swift features.
WALA Client
We recently made it possible to run at least some aspects of WALA directly in the browser using TeaVM, and we have a working prototype of client-side call graph construction for JavaScript. It could be interesting to see to what extent it is practical to create “online” program analysis for that looks for issues in JavaScript code when it is loaded. Analysis could also be integrated into increasingly popular Web-based IDEs and editors, such as Atom and Eclipse Orion.
Concrete project idea: build a plugin for Eclipse Orion that analyzes a JavaScript source file for references to non-existent functions in calls.
.NET Support
We have currently internal support for .NET in WALA; there is support inside for releasing it, but it would help to have strong interest outside. Since .NET opens up a wide range of languages that have little support in current research infrastructure, there will be many projects enabled by .NET support. We have working code now, and we could quickly start research based on it.
Concrete project idea: analyze Visual Basic .NET code and do basic FindBugs-style analysis.
Node.js Support
Support for nodejs was recently contributed to WALA, but we have done little to evaluate how analysis performs on nodejs apps. The code is part of the core and tested on Travis, so we could quickly start doing experiments with it as part of the hack-a-thon.
Concrete project idea: implement simple security analysis for nodejs.
These project ideas are not meant to be exhaustive; we would encourage any suggestions that you may have!</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Julian</first_name>
          <last_name>Dolby</last_name>
          <affiliation>IBM Thomas J. Watson Research Center</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://researcher.watson.ibm.com/researcher/view.php?person=us-dolby</homepage_url>
          <picture_url>http://pldi17.sigplan.org/getProfileImage/juliandolby/092667c4-6e51-4476-8ef0-58b41ce9014d/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Karim</first_name>
          <last_name>Ali</last_name>
          <affiliation>University of Alberta</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://karimali.ca</homepage_url>
          <picture_url>http://pldi17.sigplan.org/getProfileImage/karimali/460ecc0b-764d-462b-a93e-66a3270d72ef/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Tutorials</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>ccb47616-2752-4501-9017-289364fdd928</subevent_id>
    <title>Tutorials: Building your own modular static analyzer with Facebook Infer</title>
    <subevent_type type="regular"/>
    <room>PLDI-A</room>
    <date>2017/06/22</date>
    <url>http://pldi17.sigplan.org/track/pldi-2017-workshops-and-tutorials</url>
    <url_link_display>Tutorials</url_link_display>
    <tracks>
      <track>Tutorials</track>
    </tracks>
    <timeslot>
      <slot_id>03c9f9c9-5339-45b9-83b1-3eaba84207a1</slot_id>
      <title>Building your own modular static analyzer with Facebook Infer</title>
      <room>PLDI-A</room>
      <date>2017/06/22</date>
      <start_time>09:00</start_time>
      <end_time>12:00</end_time>
      <description>Infer is an open-source static analyzer that is used to find bugs in code at Facebook. Every month, Infer runs on thousands of code changes and detects hundreds of bugs that are fixed by developers before they reach production. Over the years, Infer has evolved from a standalone separation logic [2, 3]- based analyzer to a powerful framework for quickly implementing modular interprocedural analyses. This framework can take a simple intraprocedural analysis that computes the summary for a single procedure and lift it to a compositional interprocedural analysis that scales to millions of lines of code. Because of compositionality, the analysis can run much more quickly on a code change than on an entire codebase, opening the way to a “move fast” form of deployment which keeps pace with the workflow of developers. Infer analyses target a common intermediate language, which allows each analyzer to be run on Java, C++, Objective-C, and C code with minimal language-specific logic. The goal of this tutorial is to explain the capabilities of this framework and encourage attendees to use Infer as a platform for their own research. Attendees will learn tips and tricks for compositional program analysis at scale and gain hands-on experience in writing new analyses using the Infer infrastructure.</description>
      <persons>
        <person>
          <role>Tutorial organizer</role>
          <sort_key>1</sort_key>
          <first_name>Dino</first_name>
          <last_name>Distefano</last_name>
          <affiliation>Facebook London</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.eecs.qmul.ac.uk/~ddino/ddino_homepage/About_me.html</homepage_url>
        </person>
        <person>
          <role>Tutorial organizer</role>
          <sort_key>2</sort_key>
          <first_name>Peter</first_name>
          <last_name>O'Hearn</last_name>
          <affiliation>Facebook</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www0.cs.ucl.ac.uk/staff/p.ohearn/</homepage_url>
        </person>
        <person>
          <role>Tutorial organizer</role>
          <sort_key>3</sort_key>
          <first_name>Sam</first_name>
          <last_name>Blackshear</last_name>
          <affiliation>Facebook</affiliation>
          <bio>undefined</bio>
          <picture_url>http://pldi17.sigplan.org/getProfileImage/samblackshear/addb986f-9c91-49dc-963c-46cb4f6b41a7/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Tutorials</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>4f27d338-c72b-49ea-b276-70a148b2fc23</subevent_id>
    <title>Tutorials: Writing Verified Programs in CakeML</title>
    <subevent_type type="regular"/>
    <room>PLDI-E</room>
    <date>2017/06/23</date>
    <url>http://pldi17.sigplan.org/track/pldi-2017-workshops-and-tutorials</url>
    <url_link_display>Tutorials</url_link_display>
    <tracks>
      <track>Tutorials</track>
    </tracks>
    <timeslot>
      <slot_id>8480d8db-a14e-4f8b-9b87-aa513c40663e</slot_id>
      <title>Writing Verified Programs in CakeML</title>
      <room>PLDI-E</room>
      <date>2017/06/23</date>
      <start_time>09:00</start_time>
      <end_time>18:00</end_time>
      <description>Get a taste of program verification in CakeML!
We are offering a tutorial for students, practitioners, and researchers alike on writing and verifying programs in CakeML, the world’s foremost verified ML implementation. CakeML is a functional programming language and verification ecosystem backed by the higher-order logic (HOL) theorem prover. We will show you how to write useful programs in CakeML, prove their correctness, and leverage the verified optimising CakeML compiler to obtain a trustworthy and efficient executable.
In this tutorial, you will get hands-on experience with 
 
 writing programs in CakeML, 
 proving program specifications in HOL, 
 producing verified CakeML automatically from verified algorithms in HOL, and 
 interactively verifying imperative CakeML programs that do I/O. 

Participants are expected to have some prior exposure to functional programming, however no experience with interactive theorem proving or verification is required. At the same time, there is plenty of scope for verification experts to dive in and learn something new.</description>
      <persons>
        <person>
          <role>Tutorial organizer</role>
          <sort_key>1</sort_key>
          <first_name>Ramana</first_name>
          <last_name>Kumar</last_name>
          <affiliation>Data61, CSIRO / UNSW, Australia</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://ts.data61.csiro.au/people/?cn=Ramana+Kumar</homepage_url>
          <picture_url>http://pldi17.sigplan.org/getProfileImage/ramanakumar/bb13afb4-b983-48aa-bd31-bcbf597a4ad3/small.jpg</picture_url>
        </person>
        <person>
          <role>Tutorial organizer</role>
          <sort_key>2</sort_key>
          <first_name>Michael</first_name>
          <last_name>Norrish</last_name>
          <affiliation>Data61, CSIRO / ANU, Australia</affiliation>
          <bio>I did my PhD at the University of Cambridge, finishing in 1999. Since 2003, I have worked in Canberra, first with NICTA, and now with Data61 (the result of NICTA merging into CSIRO)</bio>
          <homepage_url>http://ts.data61.csiro.au/people/?cn=Michael+Norrish</homepage_url>
          <picture_url>http://pldi17.sigplan.org/getProfileImage/michaelnorrish/b4ee437b-353d-4dc9-8d90-ed1f71465fe6/small.jpg</picture_url>
        </person>
        <person>
          <role>Tutorial organizer</role>
          <sort_key>3</sort_key>
          <first_name>Scott</first_name>
          <last_name>Owens</last_name>
          <affiliation>University of Kent, UK</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.kent.ac.uk/~sao</homepage_url>
          <picture_url>http://pldi17.sigplan.org/getProfileImage/scottowens/bd54a5d6-66ab-457b-baf3-08288eae6ee2/small.jpg</picture_url>
        </person>
        <person>
          <role>Tutorial organizer</role>
          <sort_key>4</sort_key>
          <first_name>Magnus O.</first_name>
          <last_name>Myreen</last_name>
          <affiliation>Chalmers University of Technology, Sweden</affiliation>
          <bio>I did a B.A. in Computer Science at the University of Oxford, tutored by Dr Jeff Sanders. 
I completed my Ph.D. on program verification in 2009 at the University of Cambridge, supervised by Prof. Mike Gordon. My PhD dissertation was selected as the winner of the BCS Distinguished Dissertation Competition 2010.
In 2012, I became a Royal Society Research Fellow, UK.
In 2014, I moved to Chalmers where I became a tenured Associate Professor in 2015.</bio>
          <homepage_url>http://www.cse.chalmers.se/~myreen/</homepage_url>
          <picture_url>http://pldi17.sigplan.org/getProfileImage/magnusomyreen/ccd5e9cd-2811-4ef2-a9f0-3dd7802233ca/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Tutorials</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>7c0a36b0-e6f3-400d-9f6e-e2fdc90655c2</subevent_id>
    <title>Tutorials: Polyhedral Compilation</title>
    <subevent_type type="regular"/>
    <room>PLDI-A</room>
    <date>2017/06/22</date>
    <url>http://pldi17.sigplan.org/track/pldi-2017-workshops-and-tutorials</url>
    <url_link_display>Tutorials</url_link_display>
    <tracks>
      <track>Tutorials</track>
    </tracks>
    <timeslot>
      <slot_id>62c1b10b-287e-4d6f-b8a5-cb5b39e1f526</slot_id>
      <title>Polyhedral Compilation</title>
      <room>PLDI-A</room>
      <date>2017/06/22</date>
      <start_time>14:00</start_time>
      <end_time>18:00</end_time>
      <description>Polyhedral techniques that allow for precise and fine-grained reasoning about computational programs facilitate research in areas ranging from abstract interpretation over automatic parallelization to hardware synthesis. 
Using Presburger Sets as mathematical tool, individual instances of computations and memory accesses in “sufficiently regular” programs are modeled, analyzed, and optimized. In this interactive tutorial, we introduce the foundations of polyhedral compilation and demonstrate how recent advances in interactive and graphical tools enable its intuitive and easy application. In particular, we address the following: 
 
 Interactive calculations with Presburger sets 
 Polyhedral modeling of imperative programs 
 Optimization for data locality and parallelism 
 Generation and re-generation of imperative code 
 Automated transformations across languages with LLVM 
 Advanced GPU and accelerator mapping techniques 
 Interactive manual and semi-automatic transformations 
 Analytical program modeling using integer set counting 

Provided with a set of pre-made analysis tools, tutorial attendees learn how to develop themselves optimizing program transformation and how to use polyhedral modeling techniques to solve various problems in program engineering.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Tobias</first_name>
          <last_name>Grosser</last_name>
          <affiliation>ETH Zurich</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.grosser.es</homepage_url>
          <picture_url>http://pldi17.sigplan.org/getProfileImage/tobiasgrosser/1ee43044-14e9-497e-a230-90f96a8da867/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Oleksandr</first_name>
          <last_name>Zinenko</last_name>
          <affiliation>Inria</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.ozinenko.com</homepage_url>
          <picture_url>http://pldi17.sigplan.org/getProfileImage/oleksandrzinenko/fad5d61a-12cc-433b-b8bb-4fd43bac8ff0/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Tutorials</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>497a2b34-c497-45c7-8525-b59bcec89251</subevent_id>
    <title>Tutorials: Scala, LMS and Delite for High-Performance DSLs and Program Generators</title>
    <subevent_type type="regular"/>
    <room>PLDI-B</room>
    <date>2017/06/23</date>
    <url>http://pldi17.sigplan.org/track/pldi-2017-workshops-and-tutorials</url>
    <url_link_display>Tutorials</url_link_display>
    <tracks>
      <track>Tutorials</track>
    </tracks>
    <timeslot>
      <slot_id>b427b478-1f92-46de-90cc-939db528c2fb</slot_id>
      <title>Scala, LMS and Delite for High-Performance DSLs and Program Generators</title>
      <room>PLDI-B</room>
      <date>2017/06/23</date>
      <start_time>09:00</start_time>
      <end_time>18:00</end_time>
      <description>The aim of this tutorial is to equip attendees with the knowledge and tools to develop high-performance DSLs and code generators. Lightweight Modular Staging (LMS) is a pragmatic approach to runtime code generation in Scala, and Delite is a compiler framework for embedded DSLs that simplifies the process of implementing DSLs for parallel computation and heterogeneous targets, through a high-level intermediate language of parallel patterns. This tutorial provides an overview of the technology stack, demonstrates use-cases where it has been successfully applied, and guides the attendees step-by-step through the creation of simple generators and DSLs.</description>
      <persons>
        <person>
          <role>Tutorial organizer</role>
          <sort_key>1</sort_key>
          <first_name>Tiark</first_name>
          <last_name>Rompf</last_name>
          <affiliation>Purdue University</affiliation>
          <bio>Tiark Rompf is an assistant professor at Purdue University. His work focuses on runtime code generation, advanced compiler technology, and associated language support. From 2008 to 2014 he was a member of Martin Odersky’s Scala team at EPFL where he developed the LMS compiler framework and made various contributions to the Scala language and toolchain (delimited continuations, efficient immutable data structures, compiler speedups, type system work).</bio>
          <homepage_url>http://tiarkrompf.github.io/</homepage_url>
          <picture_url>http://pldi17.sigplan.org/getProfileImage/tiarkrompf/0262a01e-7fda-45b0-92d8-4ba269ad7997/small.jpg</picture_url>
        </person>
        <person>
          <role>Tutorial organizer</role>
          <sort_key>2</sort_key>
          <first_name>Kunle</first_name>
          <last_name>Olukotun</last_name>
          <affiliation>Stanford University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://arsenalfc.stanford.edu/kunle</homepage_url>
        </person>
        <person>
          <role>Tutorial organizer</role>
          <sort_key>3</sort_key>
          <first_name>Markus</first_name>
          <last_name>Püschel</last_name>
          <affiliation>ETH Zurich</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://people.inf.ethz.ch/markusp/</homepage_url>
          <picture_url>http://pldi17.sigplan.org/getProfileImage/markuspuschel/531dfe05-df8b-4f25-acb6-59ea5e4e59ea/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Tutorials</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>b622ae2f-b7b6-4c6c-bbcd-40d60f6d3c0d</subevent_id>
    <title>Tutorials: P4: Programming the Network Data Plane</title>
    <subevent_type type="regular"/>
    <room>PLDI-A</room>
    <date>2017/06/18</date>
    <url>http://pldi17.sigplan.org/track/pldi-2017-workshops-and-tutorials</url>
    <url_link_display>Tutorials</url_link_display>
    <tracks>
      <track>Tutorials</track>
    </tracks>
    <timeslot>
      <slot_id>3e901858-7b4d-4e3f-8971-0d4590d2259e</slot_id>
      <title>P4: Programming the Network Data Plane</title>
      <room>PLDI-A</room>
      <date>2017/06/18</date>
      <start_time>09:00</start_time>
      <end_time>12:00</end_time>
      <description>P4 www.p4.org is a new programming language for describing how network packets should be processed on a variety of targets ranging from general-purpose CPUs to network processors, FPGAs, and custom ASICs. P4 was designed with three goals in mind: 
 
 Protocol independence: devices should not “bake in” specific protocols; 
 field reconfigurability: programmers should be able to modify the behavior of devices after they have been deployed; and 
 portability: programs should not be tied to specific hardware targets. 

The P4 community has created – and continues to maintain and develop – a language specification, a set of open-source tools (compilers, debuggers, code analyzers, libraries, software P4 switches, etc.), and sample P4 programs with the goal of making it easy for P4 users to quickly and correctly author new data-plane behaviors. New ideas are being developed in P4, prototyped as new forwarding behaviors, and published at some of the top conferences in networking. Existing data- plane features typically realized in a fixed-function logic are also being authored in P4.</description>
      <persons>
        <person>
          <role>Tutorial organizer</role>
          <sort_key>1</sort_key>
          <first_name>Nate</first_name>
          <last_name>Foster</last_name>
          <affiliation>Cornell University</affiliation>
          <bio>Nate Foster is an Associate Professor of Computer Science at Cornell University. The goal of his research is to develop languages and tools that make it easy for programmers to build secure and reliable systems. His current work focuses on the design and implementation of languages for programming software-defined networks. In the past he has also worked on bidirectional languages (also known as “lenses”), database query languages, data provenance, type systems, mechanized proof, and formal semantics. He received a PhD in Computer Science from the University of Pennsylvania, an MPhil in History and Philosophy of Science from Cambridge University, and a BA in Computer Science from Williams College. His awards include a Sloan Research Fellowship, an NSF CAREER Award, a Most Influential POPL Paper Award, a Tien ’72 Teaching Award, a Google Research Award, a Yahoo! Academic Career Enhancement Award, a Cornell Engineering Research Excellence Award, and the Morris and Dorothy Rubinoff Award.</bio>
          <homepage_url>http://www.cs.cornell.edu/~jnfoster/</homepage_url>
          <picture_url>http://pldi17.sigplan.org/getProfileImage/natefoster/fc11e437-6a66-45e4-b6a3-c4b879fa2e7c/small.jpg</picture_url>
        </person>
        <person>
          <role>Tutorial organizer</role>
          <sort_key>2</sort_key>
          <first_name>Cole</first_name>
          <last_name>Schlesinger</last_name>
          <affiliation>Samsung Research America</affiliation>
          <bio>I am a research engineer with the Advanced Programming Tools team at Samsung Research America. My research focuses on linguistic modeling and verification of software systems and networks.
Prior to joining SRA, I received a Ph.D. from Princeton University, advised by David Walker.
For past and ongoing projects, please visit: http://www.schlesinger.tech</bio>
          <homepage_url>http://www.schlesinger.tech</homepage_url>
          <picture_url>http://pldi17.sigplan.org/getProfileImage/coleschlesinger/026cdfa4-a4e7-40fc-8218-4b61c3a8e12c/small.jpg</picture_url>
        </person>
        <person>
          <role>Tutorial organizer</role>
          <sort_key>3</sort_key>
          <first_name>Calin</first_name>
          <last_name>Cascaval</last_name>
          <affiliation>Barefoot Networks</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://home.cascaval.us/calin</homepage_url>
        </person>
      </persons>
      <tracks>
        <track>Tutorials</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>a0623885-59f1-4a31-9a0e-311e06cc69ca</subevent_id>
    <title>Tutorials: Bug detection in JavaScript web apps using the SAFE framework</title>
    <subevent_type type="regular"/>
    <room>PLDI-A</room>
    <date>2017/06/18</date>
    <url>http://pldi17.sigplan.org/track/pldi-2017-workshops-and-tutorials</url>
    <url_link_display>Tutorials</url_link_display>
    <tracks>
      <track>Tutorials</track>
    </tracks>
    <timeslot>
      <slot_id>0fbf513d-69e7-4be6-b983-e9c76ccf65dd</slot_id>
      <title>Bug detection in JavaScript web apps using the SAFE framework</title>
      <room>PLDI-A</room>
      <date>2017/06/18</date>
      <start_time>14:00</start_time>
      <end_time>18:00</end_time>
      <description>While JavaScript has been the language for web applications, JavaScript web applications are often vulnerable to type-related errors and security attacks. To lessen the problem, researchers have developed various analysis techniques in different analyzers, but such analyzers are not especially aimed for ease of use by analysis developers. SAFE, a scalable analysis framework for ECMAScript, is especially designed as a playground for advanced research in JavaScript web applications. SAFE is light-weight, which supports pluggability, extensibility, and debuggability. In this tutorial, we walk the attendees through this process. We start with a technical overview of the SAFE framework and its support for analysis of JavaScript web applications. Then, we present two concrete use cases of SAFE: a taint analysis of web applications and a cross-project big code analysis.</description>
      <persons>
        <person>
          <role>Tutorial organizer</role>
          <sort_key>1</sort_key>
          <first_name>Sukyoung</first_name>
          <last_name>Ryu</last_name>
          <affiliation>KAIST</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://plrg.kaist.ac.kr/ryu</homepage_url>
          <picture_url>http://pldi17.sigplan.org/getProfileImage/sukyoungryu/3bdcd232-f3d4-4610-9953-30b513926e54/small.jpg</picture_url>
        </person>
        <person>
          <role>Tutorial organizer</role>
          <sort_key>2</sort_key>
          <first_name>Alexander</first_name>
          <last_name>Jordan</last_name>
          <affiliation>Oracle Labs, Australia</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://labs.oracle.com</homepage_url>
          <picture_url>http://pldi17.sigplan.org/getProfileImage/alexanderjordan/0d109a3b-6f9b-4db2-a335-299486d1b8cf/small.jpg</picture_url>
        </person>
        <person>
          <role>Tutorial organizer</role>
          <sort_key>3</sort_key>
          <first_name>Dongsun</first_name>
          <last_name>Kim</last_name>
          <affiliation>University of Luxembourg</affiliation>
          <bio>Dongsun Kim is a Research Associate at the University of Luxembourg. He was formerly a post-doctoral fellow at the Hong Kong University of Science and Technology. His research interest includes automatic patch generation, fault localization, static analysis, and search-based software engineering (SBSE). In particular, automated debugging is his current focus. He is also pursuing an topic on automatic code generation based on SBSE. His recent work has been recognized by several awards such as a featured article of the IEEE Transactions on Software Engineering (TSE) and ACM SIGSOFT Distinguished Paper of the International Conference on Software Engineering (ICSE). He is leading the FIXPATTERN project funded by FNR (Luxembourg National Research Fund) CORE programme.</bio>
          <homepage_url>http://www.darkrsw.net/</homepage_url>
          <picture_url>http://pldi17.sigplan.org/getProfileImage/dongsunkim/877e49ef-9c87-466f-a2d1-7103d1f15991/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Tutorials</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>2c897933-503b-4ced-8ffc-55c29adf3bed</subevent_id>
    <title>Tutorials: Refinement Types for Program Verification and Synthesis</title>
    <subevent_type type="regular"/>
    <room>PLDI-E</room>
    <date>2017/06/22</date>
    <url>http://pldi17.sigplan.org/track/pldi-2017-workshops-and-tutorials</url>
    <url_link_display>Tutorials</url_link_display>
    <tracks>
      <track>Tutorials</track>
    </tracks>
    <timeslot>
      <slot_id>25af45c6-e0ca-44c2-9364-4f5bcd8520cc</slot_id>
      <title>Refinement Types for Program Verification and Synthesis</title>
      <room>PLDI-E</room>
      <date>2017/06/22</date>
      <start_time>09:00</start_time>
      <end_time>12:00</end_time>
      <description>In this tutorial you will learn how refinement types—types decorated with decidable predicates—can be used for automated SMT-based program analysis and synthesis. The presentation will focus on two programming tools we have developed. The first one is LiquidHaskell, a program verifier that relies on refinement type inference to analyze advanced language features like higher order functions, polymorphism, and algebraic data types, leading to practical verification of real-world Haskell code, including safe pointer arithmetic, array indexing and functional correctness of AVL/Red-Black trees. The second tool is Synquid, a program synthesizer that generates recursive functional programs that provably satisfy a given specification in the form of a refinement type. The tutorial will include hands-on exercises, so bring your laptops!</description>
      <persons>
        <person>
          <role>Tutorial organizer</role>
          <sort_key>1</sort_key>
          <first_name>Niki</first_name>
          <last_name>Vazou</last_name>
          <affiliation>University of Maryland</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://nikivazou.github.io/</homepage_url>
          <picture_url>http://pldi17.sigplan.org/getProfileImage/nikivazou/8cc6ddec-154b-47e9-b40d-c66e78476391/small.jpg</picture_url>
        </person>
        <person>
          <role>Tutorial organizer</role>
          <sort_key>2</sort_key>
          <first_name>Nadia</first_name>
          <last_name>Polikarpova</last_name>
          <affiliation>MIT CSAIL, USA</affiliation>
          <bio>Nadia Polikarpova is a postdoctoral researcher at the MIT Computer Science and Artificial Intelligence Lab interested in helping programmers build error-free software. She completed her PhD in 2014 at ETH Zurich (Switzerland). For her dissertation she developed tools and techniques for automated formal verification of object-oriented libraries. During her doctoral studies Nadia was an intern at Microsoft Research Redmond, where she worked on verifying real-world implementations of security protocols. At MIT, Nadia has been applying type-based verification to automated program synthesis and repair. She received her Bachelor’s and Master’s degrees in Applied Mathematics and Informatics from ITMO University (Saint Petersburg, Russia).</bio>
          <homepage_url>http://people.csail.mit.edu/polikarn/</homepage_url>
          <picture_url>http://pldi17.sigplan.org/getProfileImage/nadiapolikarpova/1ca23575-2891-4776-a8b4-c4216af887f3/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Ranjit</first_name>
          <last_name>Jhala</last_name>
          <affiliation>UC San Diego</affiliation>
          <bio>Nom nom. Chomp. Burp.</bio>
          <homepage_url>http://ranjitjhala.github.io</homepage_url>
          <picture_url>http://pldi17.sigplan.org/getProfileImage/ranjitjhala/afbdab69-ed23-4022-b7a4-2c57128f20ec/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Tutorials</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>aa16ed56-dbdb-46a7-a40e-50db41b6c5b7</subevent_id>
    <title>Tutorials: Engineering Static Analyzers with Soufflé</title>
    <subevent_type type="regular"/>
    <room>PLDI-D</room>
    <date>2017/06/23</date>
    <url>http://pldi17.sigplan.org/track/pldi-2017-workshops-and-tutorials</url>
    <url_link_display>Tutorials</url_link_display>
    <tracks>
      <track>Tutorials</track>
    </tracks>
    <timeslot>
      <slot_id>93e07f63-d60f-4f07-a18b-e0e870f07949</slot_id>
      <title>Engineering Static Analyzers with Soufflé</title>
      <room>PLDI-D</room>
      <date>2017/06/23</date>
      <start_time>09:00</start_time>
      <end_time>18:00</end_time>
      <description>Souffl&amp;eacute; is a system for developing static program analyses in a declarative fashion. An analysis is expressed in a Datalog-like logic language. From the logic specification of the analysis, Souffl&amp;eacute; synthesizes a highly efficient, parallel C++ program via partial evaluation. Souffl&amp;eacute; is currently being employed for industrial-strength static analysis problems, including large-scale program analysis and security analysis of cloud networks. This tutorial will introduce (1) the logic language of Souffl&amp;eacute;, (2) how to write Datalog-based static analyses, (3) give a guide on how one can build efficient static analyzers using industrial use-cases, and (4) give an overview of the underlying technology of Souffl&amp;eacute;.</description>
      <persons>
        <person>
          <role>Tutorial organizer</role>
          <sort_key>1</sort_key>
          <first_name>Bernhard</first_name>
          <last_name>Scholz</last_name>
          <affiliation>University of Sydney, Australia</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://sydney.edu.au/engineering/people/bernhard.scholz.php</homepage_url>
          <picture_url>http://pldi17.sigplan.org/getProfileImage/bernhardscholz1/2ad1b16f-f423-4db2-bfce-56e86799d860/small.jpg</picture_url>
        </person>
        <person>
          <role>Tutorial organizer</role>
          <sort_key>2</sort_key>
          <first_name>Herbert</first_name>
          <last_name>Jordan</last_name>
          <affiliation>University of Innsbruck</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Pavle</first_name>
          <last_name>Subotic</last_name>
          <affiliation>University College London</affiliation>
          <bio>undefined</bio>
          <picture_url>http://pldi17.sigplan.org/getProfileImage/pavlesubotic/3ce2d074-69f7-4cfa-a7ba-633a795f3b70/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Tutorials</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>e4a7371a-d751-4fdc-adab-81870080a62f</subevent_id>
    <title>Tutorials: Graal: High Performance Compilation for Managed Languages</title>
    <subevent_type type="regular"/>
    <room>PLDI-A</room>
    <date>2017/06/23</date>
    <url>http://pldi17.sigplan.org/track/pldi-2017-workshops-and-tutorials</url>
    <url_link_display>Tutorials</url_link_display>
    <tracks>
      <track>Tutorials</track>
    </tracks>
    <timeslot>
      <slot_id>1e13d15f-ef21-4201-a91f-24b5793313d2</slot_id>
      <title>Graal: High Performance Compilation for Managed Languages</title>
      <room>PLDI-A</room>
      <date>2017/06/23</date>
      <start_time>09:00</start_time>
      <end_time>12:00</end_time>
      <description>This tutorial presents Graal, a high-performance dynamic compiler written in Java. Because it is highly configurable and extensible, it delivers excellent peak performance for a diverse set of managed languages including Java (beating the Java HotSpot server compiler), JavaScript (beating the V8 Crankshaft compiler), Ruby, and R. This lifts compiler research using Graal to a new level: researchers can evaluate new compiler optimizations immediately on many languages. If you are a language implementer who is curious how modern VMs like the Java HotSpot VM or the V8 JavaScript VM optimize your code, you will get all your questions answered too.
In detail, the tutorial covers the following topics: 
 
 Key distinguishing features of Graal, 
 Introduction to the Graal IR: basic properties, instructions, and optimization phases 
 Speculative optimizations: first-class support for optimistic optimizations and deoptimization 
 Graal API: separation of the compiler from the VM 
 Snippets: expressing high-level semantics in low-level Java code 
 Compiler intrinsics: use all your hardware instructions with Graal 
 Using Graal for static analysis 
 Custom compilations with Graal: integration of the compiler with an application or library 
 Graal as a compiler for dynamic programming languages</description>
      <persons>
        <person>
          <role>Tutorial organizer</role>
          <sort_key>1</sort_key>
          <first_name>Christian</first_name>
          <last_name>Wimmer</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <picture_url>http://pldi17.sigplan.org/getProfileImage/christianwimmer/cdeb11d2-56bd-4c5e-81a3-fb4c52918c0b/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Tutorials</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>e9b7dd00-b0d1-46ec-acca-d6b778e11d99</subevent_id>
    <title>ISMM 2017: Session 1: Garbage Collection</title>
    <subevent_type type="regular"/>
    <room>ISMM-A</room>
    <date>2017/06/18</date>
    <url>http://pldi17.sigplan.org/track/ismm-2017-papers</url>
    <url_link_display>Research Papers</url_link_display>
    <tracks>
      <track>Research Papers</track>
    </tracks>
    <timeslot>
      <slot_id>17719ebb-c9fb-4d0a-b5a5-7cbc5ff517c0</slot_id>
      <title>NG2C: Pretenuring Garbage Collection with Dynamic Generations for HotSpot Big Data Applications</title>
      <room>ISMM-A</room>
      <date>2017/06/18</date>
      <start_time>09:30</start_time>
      <end_time>10:00</end_time>
      <description>Big Data applications suffer from unpredictable and unacceptably high pause times due to Garbage Collection (GC). This is the case in latency-sensitive applications such as on-line credit-card fraud detection, graph-based computing for analysis on social networks, etc. Such pauses compromise latency requirements of the whole application stack and result from applications’ aggressive buffering/caching of data, exposing an ill-suited GC design, which assumes that most objects will die young and does not consider that applications hold large amounts of middle-lived data in memory.
To avoid such pauses, we propose NG2C, a new GC algorithm that combines pretenuring with user-defined dynamic generations. By being able to allocate objects into different generations, NG2C is able to group objects with similar lifetime profiles in the same generation. By allocating objects with similar lifetime profiles close to each other, i.e. in the same generation, we avoid object promotion (copying between generations) and heap fragmentation (which leads to heap compactions) both responsible for most of the duration of HotSpot GC pause times.
NG2C is implemented for the OpenJDK 8 HotSpot Java Virtual Machine, as an extension of the Garbage First GC. We evaluate NG2C using Cassandra, Lucene, and GraphChi with three different GCs: Garbage First (G1), Concurrent Mark Sweep (CMS), and NG2C. Results show that NG2C decreases the worst observable GC pause time by up to 94.8% for Cassandra, 85.0% for Lucene and 96.45% for GraphChi, when compared to current collectors (G1 and CMS). In addition, NG2C has no negative impact on application throughput or memory usage.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Rodrigo</first_name>
          <last_name>Bruno</last_name>
          <affiliation>INESC-ID / Instituto Superior Técnico, University of Lisbon</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Luís</first_name>
          <last_name>Picciochi Oliveira</last_name>
          <affiliation>Feedzai</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Paulo</first_name>
          <last_name>Ferreira</last_name>
          <affiliation>INESC-ID / Instituto Superior Técnico, University of Lisbon</affiliation>
          <bio>Paulo Ferreira holds a PhD from the Universit&amp;eacute; Pierre et Marie Curie (1996) in Computer Science. His MSc (1992) and BSc (1988) are both from Instituto Superior T&amp;eacute;cnico (University of Lisbon) in Electrotechnical Engineering. He holds the “agrega&amp;ccedil;&amp;atilde;o” since November 2009 from the same University.
He is currently Associated Professor with “Agrega&amp;ccedil;&amp;atilde;o” in Instituto Superior T&amp;eacute;cnico at the Department of Computer Science and Engineering where he has been teaching courses within the scientific area of Architecture and Operating Systems, at both undergraduate and graduate levels, including Mobile Computing, Middleware for Distributed Internet Applications, Operating Systems, and Advanced Distributed Systems. 
He was Pro-Rector at the Technical University of Lisbon (UTL) between 2007 and 2010, being responsible for the analysis and evaluation of existing information and communication systems. In this activity, among other tasks, he has coordinated the VoIP project, improved the computer system of the academic services as well as the infrastructure of communications between the various schools of UTL. He is also member of the Directory Board of &amp;Oacute;bidos Technological Park representing UTL. 
He was responsible for the Distributed Systems Group (“Grupo de Sistemas Distribu&amp;iacute;dos”, GSD) of INESC ID since January 1999 to 2010 (sharing this responsibility every two years since 2010 on a rotative basis). This group is currently composed of nine PhDs and several PhD and MSc students. In addition to the responsibility for scientific coordination of GSD, he has also been responsible for the Research Action Line at INESC ID called Computing Systems and Communication Networks in 2012-2013 and 2008-2009. 
He is senior member of INESC ID in the Distributed Systems Group, where he develops his research work in the scientific research area of ​​distributed systems, with emphasis on middleware, mobile computing and operating systems. He has published, as author or co-author, more than 100 articles in international journals and conferences, 1 scientific book, 11 book chapters, a pedagogical book (with 3 editions, being one in Brazil), serves on various program committees (e.g. Middleware, ICDCS, DAIS, etc.), served as an expert to the European Union for assessment of projects proposals under the 7th Framework Program, led more than 15 research projects, was one of the founders and board officer of EuroSys (ACM - European Chapter of the Special Interest Group on Operating Systems) being currently member of the Steering Committee; he is also a member of the Steering Committee of the ACM/IFIP/Usenix Middleware (2013-2014) and ACM/IFIP/Usenix Adaptive and Reflective Middleware (ARM). He is currently member of the editorial board of the Springer Journal of Internet Services and Applications. 
He is senior member of ACM and IEEE, was awarded two Best Paper Awards at international events (ACM/IFIP/Usenix Middleware Conference, level A in both CORE and RADIST rankings), 1 Recognition of Service Award from ACM, his PhD thesis was top ranked at the Universit&amp;eacute; Pierre et Marie Curie, and in the academic years of 2010/2011 (2nd semester) and 2013/14 (1st semester) he was awarded the mention of “excellent teaching” at IST in the courses of Mobile Computing (MSc, 1st year) and Operating Systems (BSc, 2nd year), respectively.</bio>
          <homepage_url>http://www.gsd.inesc-id.pt/~pjpf/</homepage_url>
          <picture_url>http://pldi17.sigplan.org/getProfileImage/pauloferreira1/79f3aa22-48d0-4270-936a-d893470665ff/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>52469fbc-19f6-4f57-b18f-28c90ee48171</slot_id>
      <title>Type-Assisted Automatic Garbage Collection for Lock-Free Data Structures</title>
      <room>ISMM-A</room>
      <date>2017/06/18</date>
      <start_time>10:00</start_time>
      <end_time>10:30</end_time>
      <description>We introduce Isolde, an automatic garbage collection scheme designed specifically for managing memory in lock-free data structures, such as stacks, lists, maps and queues. Isolde exists as a plug-in memory manager, designed to sit on-top of another memory manager, and use it’s allocator and reclaimer. Isolde treats a lock-free data structure as a logical heap, isolated from the rest of the program. This allows garbage collection outside of Isolde to take place without affecting the lock-free data structure. Isolde further manages objects allocated on a Isolde heap in a fully concurrent manner, allowing garbage collection to incrementally remove garbage without stopping other threads doing work.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Albert</first_name>
          <last_name>Mingkun Yang</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Tobias</first_name>
          <last_name>Wrigstad</last_name>
          <affiliation>Uppsala University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://wrigstad.com</homepage_url>
          <picture_url>http://pldi17.sigplan.org/getProfileImage/tobiaswrigstad/8c34d309-e66c-4655-9a5f-908cd3c4605a/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>df2d01a0-0073-4885-816f-6cc5a476d163</subevent_id>
    <title>ISMM 2017: Opening</title>
    <subevent_type type="regular"/>
    <room>ISMM-A</room>
    <date>2017/06/18</date>
    <url>http://pldi17.sigplan.org/track/ismm-2017-papers</url>
    <url_link_display>Research Papers</url_link_display>
    <tracks>
      <track>Research Papers</track>
    </tracks>
    <timeslot>
      <slot_id>89bd85d5-5fab-4598-bf48-f13938f22225</slot_id>
      <title>Opening</title>
      <room>ISMM-A</room>
      <date>2017/06/18</date>
      <start_time>08:30</start_time>
      <end_time>08:45</end_time>
      <description>undefined</description>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>9305efb4-e0f5-4902-9e1e-997ac35f8f79</subevent_id>
    <title>ISMM 2017: Keynote</title>
    <subevent_type type="regular"/>
    <room>ISMM-A</room>
    <date>2017/06/18</date>
    <url>http://pldi17.sigplan.org/track/ismm-2017-papers</url>
    <url_link_display>Research Papers</url_link_display>
    <tracks>
      <track>Research Papers</track>
    </tracks>
    <timeslot>
      <slot_id>10c13e4a-9a57-45fb-a0d9-dcd641740496</slot_id>
      <title>Bridging the Gap between Memory Performance and Massive Parallelism: The Critical Role of Programming Systems Innovations</title>
      <room>ISMM-A</room>
      <date>2017/06/18</date>
      <start_time>08:45</start_time>
      <end_time>09:30</end_time>
      <description>This talk examines some trends in the modern developments of memory systems and their relations with the massive parallelism in processors and applications. It then draws on some recent work on GPU to explain the important role of programming systems in bridging the gap; it particularly emphasizes the importance of innovations for enabling better software controllability, more software elasticity, and inter-thread data locality enhancements. The talk further discusses the implications brought to programming systems by the increasingly blurred boundaries among memory, storage, and processing.</description>
      <persons>
        <person>
          <role>Keynote Speaker</role>
          <sort_key>1</sort_key>
          <first_name>Xipeng</first_name>
          <last_name>Shen</last_name>
          <affiliation>North Carolina State University</affiliation>
          <bio>Xipeng Shen is an associate professor at the Computer Science Department, North Carolina State University (NCSU). He has been an IBM Canada CAS Research Faculty Fellow since 2010, and a receipt of the 2010 NSF CAREER Award, 2011 DOE Early Career Award, and 2015 Google Faculty Research Award. Before joining NCSU, he was an Adina Allen Term Distinguished Associate Professor at the College of William and Mary.</bio>
          <homepage_url>http://people.engr.ncsu.edu/xshen5/</homepage_url>
          <picture_url>http://pldi17.sigplan.org/getProfileImage/xipengshen/7ba54e69-f90a-4cf7-90d2-19fdd5f42e87/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>be82c376-c0aa-4f41-b3b4-30abb0d5934c</subevent_id>
    <title>ISMM 2017: Session 3: Hybrid Memory Systems</title>
    <subevent_type type="regular"/>
    <room>ISMM-A</room>
    <date>2017/06/18</date>
    <url>http://pldi17.sigplan.org/track/ismm-2017-papers</url>
    <url_link_display>Research Papers</url_link_display>
    <tracks>
      <track>Research Papers</track>
    </tracks>
    <timeslot>
      <slot_id>1609a01a-ac11-44c0-a767-7757fdb18f0c</slot_id>
      <title>Analyzing Memory Management Methods on Integrated CPU-GPU Systems</title>
      <room>ISMM-A</room>
      <date>2017/06/18</date>
      <start_time>14:00</start_time>
      <end_time>14:30</end_time>
      <description>Heterogeneous systems that integrate a multicore CPU and a GPU on the same die are ubiquitous. On these systems, both the CPU and GPU share the same physical memory as opposed to using separate memory dies. Although integration eliminates the need to copy data between the CPU and the GPU, arranging transparent memory sharing between the two devices can carry large overheads. Memory on CPU/GPU systems is typically managed by a software framework such as OpenCL or CUDA, a runtime library, and a GPU driver. These frameworks offer a range of memory management methods that vary in ease of use, consistency guarantees and performance. In this study, we analyze some of the common memory management methods of the most widely used software frameworks for heterogeneous systems: CUDA, OpenCL 1.2, OpenCL 2.0, and HSA, on NVIDIA and AMD hardware. We focus on performance/functionality trade-offs, with the goal of exposing their performance impact and simplifying the choice of memory management methods for programmers.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Mohammad</first_name>
          <last_name>Dashti</last_name>
          <affiliation>University of British Columbia</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Alexandra (Sasha)</first_name>
          <last_name>Fedorova</last_name>
          <affiliation>Simon Fraser University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.sfu.ca/~fedorova/</homepage_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>51af11ca-d3aa-4736-83d6-e878eb006735</slot_id>
      <title>RTHMS: A Tool for Data Placement on Hybrid Memory System</title>
      <room>ISMM-A</room>
      <date>2017/06/18</date>
      <start_time>15:00</start_time>
      <end_time>15:30</end_time>
      <description>Modern applications running on supercomputers have increasing demands for memory, in terms of capacity, speed, power efficiency, and persistence. Since there is no single memory technology today that can satisfy all these requirements, next-generation supercomputers are expected to feature deeper memory hierarchies that consist of characteristically different memory technologies complementing each other or working side-by-side. A central question in these scenarios is how to place application data structures on the available memories to achieve optimal performance. Manual allocation is prohibitive for applications with more than an handful of memory objects. In this work, we present an algorithm for data placement on hybrid-memory system based on a set of memory allocation rules and global data placement decision algorithm. We propose a tool OracleHMS that implements our algorithm and provides recommendations on code change and memory setup to programmers. Our experiments on real hybrid-memory system show that our tool recommendations match or outperform manual optimization in a variety of scientific and data analytics applications.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Ivy Bo</first_name>
          <last_name>Peng</last_name>
          <affiliation>KTH Royal Institute of Technology</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Roberto</first_name>
          <last_name>Gioiosa</last_name>
          <affiliation>Pacific Northwest National Laboratory</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Gokcen</first_name>
          <last_name>Kestor</last_name>
          <affiliation>Pacific Northwest National Laboratory</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Stefano</first_name>
          <last_name>Markidis</last_name>
          <affiliation>KTH Royal Institute of Technology</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Pietro</first_name>
          <last_name>Cicotti</last_name>
          <affiliation>San Diego Supercomputer Center</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Erwin</first_name>
          <last_name>Laure</last_name>
          <affiliation>KTH Royal Institute of Technology</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>b4f8ccaa-c3d1-4fcb-bde9-80db5a4ec3f0</slot_id>
      <title>Continuous Checkpointing of HTM Transactions in NVM</title>
      <room>ISMM-A</room>
      <date>2017/06/18</date>
      <start_time>14:30</start_time>
      <end_time>15:00</end_time>
      <description>This paper addresses the challenges of coupling byte addressable non-volatile memory (NVM) and hardware transaction memory (HTM) in high-performance transaction processing. We first show that HTM transactions can be ordered using existing processor instructions without any hardware changes. In contrast, existing solutions posit changes to HTM mechanisms in the form of special instructions or modified functionality. We exploit the ordering mechanism to design a novel persistence method that decouples HTM concurrency from back-end NVM operations. Failure atomicity is achieved using redo logging coupled with aliasing to guard against mistimed cache evictions. Our algorithm uses efficient lock-free mechanisms with bounded static memory requirements. We evaluated our approach using both micro-benchmarks, and, benchmarks in the STAMP suite, and showed that it compares well with standard (volatile) HTM transactions. We also showed that it yields significant gains in throughput and latency in comparison with persistent transactional locking.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Ellis</first_name>
          <last_name>Giles</last_name>
          <affiliation>Rice University</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Kshitij</first_name>
          <last_name>Doshi</last_name>
          <affiliation>Intel Corporation</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Peter</first_name>
          <last_name>Varman</last_name>
          <affiliation>Rice University</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>5a54d080-bcf8-4696-a31d-f64849c1bc6d</subevent_id>
    <title>ISMM 2017: Session 4: A Deeper Look</title>
    <subevent_type type="regular"/>
    <room>ISMM-A</room>
    <date>2017/06/18</date>
    <url>http://pldi17.sigplan.org/track/ismm-2017-papers</url>
    <url_link_display>Research Papers</url_link_display>
    <tracks>
      <track>Research Papers</track>
    </tracks>
    <timeslot>
      <slot_id>5fbe5d1f-4fa2-4f4c-b833-da4a06c494ab</slot_id>
      <title>Avoiding Consistency Exceptions Under Strong Memory Consistency Models</title>
      <room>ISMM-A</room>
      <date>2017/06/18</date>
      <start_time>17:00</start_time>
      <end_time>17:30</end_time>
      <description>Shared-memory languages and systems generally provide weak or undefined semantics for executions with data races. Prior work has proposed memory consistency models that ensure well-defined, easy-to-understand semantics based on \emph{region serializability} (RS), but the resulting system may throw a \emph{consistency exception} in the presence of a data race. Consistency exceptions can occur unexpectedly even in well-tested programs, hurting availability and thus limiting the practicality of RS-based memory models.
To our knowledge, this paper is the first to consider the problem of availability for memory consistency models that throw consistency exceptions. We first extend existing approaches that enforce \emph{RSx}, a memory model based on serializability of synchronization-free regions (SFRs), to avoid region conflicts and thus consistency exceptions. These new approaches demonstrate both the potential for and limitations of avoiding consistency exceptions under RSx. To improve availability further, we introduce (1) a new memory model called \emph{RIx} based on \emph{isolation} of SFRs and (2) a new approach called \emph{Avalon} that provides RIx. We demonstrate two variants of Avalon that offer different performance–availability tradeoffs for RIx.
An evaluation on real Java programs shows that this work’s novel approaches are able to reduce consistency exceptions, thereby improving the applicability of strong memory consistency models. Furthermore, the approaches provide compelling points in the performance–availability tradeoff space for memory consistency enforcement. RIx and Avalon thus represent a promising direction for tackling the challenge of availability under strong consistency models that throw consistency exceptions.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Minjia</first_name>
          <last_name>Zhang</last_name>
          <affiliation>Microsoft Research</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://zhangminjia.me</homepage_url>
          <picture_url>http://pldi17.sigplan.org/getProfileImage/minjiazhang1/e1a7348e-3480-439b-a1b5-28f6a3d2cffd/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Swarnendu</first_name>
          <last_name>Biswas</last_name>
          <affiliation>University of Texas at Austin</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://users.ices.utexas.edu/~sbiswas/</homepage_url>
          <picture_url>http://pldi17.sigplan.org/getProfileImage/swarnendubiswas/019cc09d-cabe-40c0-8f57-1aaf6ab97a13/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Michael</first_name>
          <last_name>Bond</last_name>
          <affiliation>Ohio State University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cse.ohio-state.edu/~mikebond</homepage_url>
          <picture_url>http://pldi17.sigplan.org/getProfileImage/michaelbond/92c528d2-84b3-4369-8b57-6555f1016a8e/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>78b2f783-b7fa-475c-9a6f-1e219cf67df8</slot_id>
      <title>"What's in a Name?" Going Beyond Allocation Site Names in Heap Analysis</title>
      <room>ISMM-A</room>
      <date>2017/06/18</date>
      <start_time>16:00</start_time>
      <end_time>16:30</end_time>
      <description>A points-to analysis computes a sound abstraction of heap memory conventionally using a name-based abstraction that summarizes runtime memory by grouping locations using the names of allocation sites: All concrete heap locations allocated by the same statement are grouped together. The locations in the same group are treated alike i.e., a pointer to any one location of the group is assumed to point to every location in the group leading to an over-approximation of points-to relations.
We propose an access-based abstraction that partitions each name-based group of locations into equivalence classes at every program point using an additional criterion of the sets of access paths (chains of pointer indirections) reaching the locations in the memory. The intuition is that the locations that are both allocated and accessed alike should be grouped into the same equivalence class. Since the access paths in the memory could reach different locations at different program points, our groupings change flow sensitively unlike the name-based groupings. This creates a more precise view of the memory. Theoretically, it is strictly more precise than the name-based abstraction except in some trivial cases; practically it is far more precise.
Our empirical measurements show the benefits of our tool Access-Based Heap Analyzer (ABHA) on SPEC CPU 2006 and heap manipulating SV-COMP benchmarks. ABHA scales to 20 kLoC and can improve the precision even up to 99% (in terms of the number of aliases). Additionally, ABHA allows any user-defined summarization of an access path to be plugged in; we have implemented and evaluated four summarization techniques. ABHA can also act as a front-end to TVLA, a parametrized shape analyzer, in order to automate its parametrization by generating predicates that capture the program behaviour more accurately.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Vini</first_name>
          <last_name>Kanvar</last_name>
          <affiliation>Indian Institute of Technology (IIT) Bombay</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.cse.iitb.ac.in/~vini/</homepage_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Uday</first_name>
          <last_name>P. Khedker</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>a8ee9d44-320e-44da-9c21-d0cb841be9a3</slot_id>
      <title>A Refinement Hierarchy for Free List Memory Allocators</title>
      <room>ISMM-A</room>
      <date>2017/06/18</date>
      <start_time>16:30</start_time>
      <end_time>17:00</end_time>
      <description>Existing implementations of dynamic memory allocators (DMA) employ a large spectrum of policies and techniques. The formal specifications of these techniques are quite complicated in isolation and very complex when combined. Therefore, the formal reasoning on a specific DMA implementation is difficult for automatic tools and mostly single-use. This paper proposes a solution to this problem by providing formal models for a full class of DMA, the free list class. To obtain manageable formal reasoning and reusable formal models, we organise these models in a hierarchy ranked by refinement relations. We prove the soundness of models and refinement relations using an off-the-shelf theorem prover. We demonstrate that our hierarchy is a basis for an algorithm theory for the class of free list DMA: it abstracts various existing implementations of DMA and leads to new DMA implementations. We illustrate its application to model-based code generation, testing, run-time verification, and static analysis.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Bin</first_name>
          <last_name>Fang</last_name>
          <affiliation>East China Normal University (China) and University Paris Diderot and CNRS (France)</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://fangbin.github.io/</homepage_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Mihaela</first_name>
          <last_name>Sighireanu</last_name>
          <affiliation>IRIF, University Paris Diderot and CNRS, France</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>de659907-2be5-47fb-af5c-7b21615ce975</subevent_id>
    <title>ISMM 2017: Session 2: Clever Data Tricks</title>
    <subevent_type type="regular"/>
    <room>ISMM-A</room>
    <date>2017/06/18</date>
    <url>http://pldi17.sigplan.org/track/ismm-2017-papers</url>
    <url_link_display>Research Papers</url_link_display>
    <tracks>
      <track>Research Papers</track>
    </tracks>
    <timeslot>
      <slot_id>1f08992d-3748-47e5-a6d2-38cf3962e566</slot_id>
      <title>A Marshalled Data Format for Pointers in Relocatable Data Blocks</title>
      <room>ISMM-A</room>
      <date>2017/06/18</date>
      <start_time>11:00</start_time>
      <end_time>11:30</end_time>
      <description>As future computing hardware progresses towards extreme-scale technology, new challenges arise for addressing heterogeneous compute and memory resources, for providing application resilience in the presence of more frequent failures, and for working within strict energy constraints. While C++ has gained popularity in recent years within the HPC community, some concepts of object- oriented program design may be at odds with the techniques we use to address the challenges of extreme-scale computing. In this work, we focus on the challenges related to using aggregate data structures that include pointer values within a programming model where the runtime may frequently relocate data, and traditional serialization techniques are not practical. We propose and evaluate a marshalled encoding for relocatable data blocks, and present a C++ library and other tools to simplify the work of the application programmer developing new applications or porting existing applications to such emerging programming models.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Nick</first_name>
          <last_name>Vrvilo</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Lechen</first_name>
          <last_name>Yu</last_name>
          <affiliation>Rice University</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Vivek</first_name>
          <last_name>Sarkar</last_name>
          <affiliation>Rice University, USA</affiliation>
          <bio>undefined</bio>
          <picture_url>http://pldi17.sigplan.org/getProfileImage/viveksarkar/265f6790-2dd2-44b7-939e-07ebfc095e59/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>534762c9-84c0-455e-b459-fb5035a69f2d</slot_id>
      <title>Flexible and Efficient Memory Object Metadata</title>
      <room>ISMM-A</room>
      <date>2017/06/18</date>
      <start_time>11:30</start_time>
      <end_time>12:00</end_time>
      <description>Compiler-based tools can protect software from attack and find bugs within programs. To support programs written in type-unsafe languages such as C, such tools need to add code into a program that must, at run-time, take a pointer into a memory object and locate metadata for that memory object. Current methods of locating metadata are either flexible (supporting metadata of varying sizes) at the expense of speed and scalability or are fast (e.g., by using shadow tables) at the cost of flexibility (metadata is small and must always be the same size).
This paper presents a new method of attaching metadata to memory objects, named Padding Area MetaData (PAMD), that is both flexible and efficient. Metadata can be any size, and different memory objects can have different sized metadata. While flexible, the algorithm for finding the metadata given a pointer into the memory object takes constant time. Our method extends Baggy Bounds with Accurate Checking (BBAC) which attaches constant-sized metadata to memory objects for performing precise dynamic bounds checks. Our design supports variable-sized metadata, and our implementation supports larger programs.
We evaluated the performance and scalability of PAMD using dynamic bounds checking as an exemplar of our method. Our results show that our method adds at most 33% overhead to an identical dynamic bounds checking tool that trades precision for performance by using a simple shadow table. Our results also show that our method, while having the same flexibility as splay trees, performs significantly faster and scales better as a program allocates more memory.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Zhengyang</first_name>
          <last_name>Liu</last_name>
          <affiliation>Beijing University of Posts and Telecommunications</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://zhengyang-liu.com</homepage_url>
          <picture_url>http://pldi17.sigplan.org/getProfileImage/zhengyangliu/f0a2fd9a-0e89-491b-8bc2-c3a5a7bb498c/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>John</first_name>
          <last_name>Criswell</last_name>
          <affiliation>University of Rochester</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.rochester.edu/u/criswell/</homepage_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>c719342d-2229-4ab1-923f-68cdc62d8d1e</slot_id>
      <title>Shadow State Encoding for Efficient Monitoring of Block-level Properties</title>
      <room>ISMM-A</room>
      <date>2017/06/18</date>
      <start_time>12:00</start_time>
      <end_time>12:30</end_time>
      <description>Memory shadowing associates addresses from an application’s memory to values stored in a disjoint memory space called shadow memory. At runtime shadow values store metadata about application memory locations they are mapped to. Shadow state encodings – the structure of shadow values and their interpretation – vary across different tools. Encodings used by the state-of-the-art monitoring tools have been proven useful for tracking memory at a byte-level, but cannot address properties related to memory block boundaries. Tracking block boundaries is however crucial for spatial memory safety analysis, where a spatial violation such as out-of-bounds access, may dereference an allocated location belonging to an adjacent block or a different struct member.
This paper describes two novel shadow state encodings which capture block-boundary-related properties. These encodings have been implemented in E-ACSL – a runtime verification tool for C programs. Initial experiments involving checking validity of pointer and array accesses in computationally intensive runs of programs selected from SPEC CPU benchmarks demonstrate runtime overheads comparable to state-of-the-art memory debuggers.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Kostyantyn</first_name>
          <last_name>Vorobyov</last_name>
          <affiliation>CEA LIST, France</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Julien</first_name>
          <last_name>Signoles</last_name>
          <affiliation>CEA LIST</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Nikolai</first_name>
          <last_name>Kosmatov</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>1cd670e0-e93f-4121-81cb-8a2f5315aa2a</subevent_id>
    <title>Invited Speakers: Welcome</title>
    <subevent_type type="regular"/>
    <room>PLDI-MainTrack-A</room>
    <date>2017/06/19</date>
    <url>http://pldi17.sigplan.org/track/pldi-2017-keynotes</url>
    <url_link_display>Invited Speakers</url_link_display>
    <tracks>
      <track>Invited Speakers</track>
    </tracks>
    <timeslot>
      <slot_id>ecbf7301-4afa-492f-8711-a81efb64eabd</slot_id>
      <title>Welcome</title>
      <room>PLDI-MainTrack-A</room>
      <date>2017/06/19</date>
      <start_time>09:00</start_time>
      <end_time>09:05</end_time>
      <description>undefined</description>
      <tracks>
        <track>Invited Speakers</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>96925845-cd67-4db7-988f-48af6de3d7eb</subevent_id>
    <title>Invited Speakers: Martin Abadi</title>
    <subevent_type type="regular"/>
    <room>PLDI-MainTrack-A</room>
    <date>2017/06/19</date>
    <url>http://pldi17.sigplan.org/track/pldi-2017-keynotes</url>
    <url_link_display>Invited Speakers</url_link_display>
    <tracks>
      <track>Invited Speakers</track>
    </tracks>
    <timeslot>
      <slot_id>689fa7b3-5677-4490-8123-4f249ea908f7</slot_id>
      <title>TensorFlow considered as a programming language</title>
      <room>PLDI-MainTrack-A</room>
      <date>2017/06/19</date>
      <start_time>17:50</start_time>
      <end_time>18:40</end_time>
      <description>The recent, remarkable successes of machine learning are due in part to the invention of machine learning methods (especially for deep learning), to the collection of datasets for tackling problems in many fields, and to the availability of powerful hardware, including CPUs, GPUs, and custom-designed ASICs. Software systems, however, are central to this progress.
This talk suggests that it is instructive and fruitful to think of these software systems from a programming-language perspective. It focuses on TensorFlow, a recent system for machine learning that operates at large scale and in heterogeneous environments. TensorFlow owes its generality to its programmability. In TensorFlow, models for machine learning are assembled from primitive operations by function composition and other simple, familiar constructs. Other aspects of TensorFlow, such as its support for automatic differentiation and its memory management, are less common in mainstream programming languages. TensorFlow enables the development of a wide variety of models, in both production and research. As examples, this talk briefly describes some recent research applications related to programming.
This talk is based on joint work with many people, primarily at Google Brain. More information on TensorFlow is available at tensorflow.org.</description>
      <persons>
        <person>
          <role>Keynote Speaker</role>
          <sort_key>1</sort_key>
          <first_name>Martin</first_name>
          <last_name>Abadi</last_name>
          <affiliation>Google</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://users.soe.ucsc.edu/~abadi/home.html</homepage_url>
          <picture_url>http://pldi17.sigplan.org/getProfileImage/martinabadi/a231774e-aa73-4273-9494-7467e09dfe83/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Invited Speakers</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>3d1442c0-e92b-45ca-a78e-fb20757088bd</subevent_id>
    <title>Invited Speakers: Program Chair report and SIGPLAN Town Hall meeting</title>
    <subevent_type type="regular"/>
    <room>PLDI-MainTrack-A</room>
    <date>2017/06/20</date>
    <url>http://pldi17.sigplan.org/track/pldi-2017-keynotes</url>
    <url_link_display>Invited Speakers</url_link_display>
    <tracks>
      <track>Invited Speakers</track>
    </tracks>
    <timeslot>
      <slot_id>a2741695-a7f2-4f84-9747-216d6a1975ea</slot_id>
      <title>Program Chair report and SIGPLAN Town Hall meeting</title>
      <room>PLDI-MainTrack-A</room>
      <date>2017/06/20</date>
      <start_time>17:00</start_time>
      <end_time>18:00</end_time>
      <description>undefined</description>
      <tracks>
        <track>Invited Speakers</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>b95f272c-266f-4164-9c2e-2008f14731a1</subevent_id>
    <title>Invited Speakers: Martin Odersky</title>
    <subevent_type type="regular"/>
    <room>PLDI-MainTrack-A</room>
    <date>2017/06/19</date>
    <url>http://pldi17.sigplan.org/track/pldi-2017-keynotes</url>
    <url_link_display>Invited Speakers</url_link_display>
    <tracks>
      <track>Invited Speakers</track>
    </tracks>
    <timeslot>
      <slot_id>13325515-b2c8-4e08-af05-34d839de103b</slot_id>
      <title>What to Leave Implicit</title>
      <room>PLDI-MainTrack-A</room>
      <date>2017/06/19</date>
      <start_time>09:05</start_time>
      <end_time>10:00</end_time>
      <description>To understand a piece of program text one must also understand the con-text in which the program fragment is to be executed. Modern programming languages offer an array of constructs to define context. In Scala, those constructs can be summed up as the three I’s: Imports, Inheritance, and Implicits. Implicits in particular are a central, but also controversial part of the language.
This talk explores the different facets of implicits in Scala, as they exist now and as they might evolve in the future. It highlights their potential benefits and problems, covering aspects of design, implementation, and ergonomics.</description>
      <persons>
        <person>
          <role>Keynote Speaker</role>
          <sort_key>1</sort_key>
          <first_name>Martin</first_name>
          <last_name>Odersky</last_name>
          <affiliation>EPFL, Switzerland</affiliation>
          <bio>Martin Odersky is a professor at EPFL in Lausanne, Switzerland. He has been working on programming languages for most of his career. He first studied structured and object-oriented programming as a PhD student of Niklaus Wirth, then fell in love with functional programming while working as a post doc at IBM and Yale. When Java came out, he started to add functional programming constructs to the new platform. This led to Pizza and GJ and eventually to Java 5 with generics. During that time he also developed javac, the current reference compiler for Java. 
Over the last 10 years, Martin worked on unifying object-oriented and functional programming in the Scala language. Scala quickly escaped from the research lab and became a popular open source tool and industrial language. He now oversees development of Scala as head of the programming group at EPFL and as academic director of the Scala center.</bio>
          <homepage_url>http://lampwww.epfl.ch/~odersky/</homepage_url>
          <picture_url>http://pldi17.sigplan.org/getProfileImage/martinodersky/ae04208a-af42-4887-a6c1-b5952a33acf3/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Invited Speakers</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>e2b93a41-544b-4210-ac8e-1598d2ffeffa</subevent_id>
    <title>Invited Speakers: Frank Wood</title>
    <subevent_type type="regular"/>
    <room>PLDI-MainTrack-A</room>
    <date>2017/06/21</date>
    <url>http://pldi17.sigplan.org/track/pldi-2017-keynotes</url>
    <url_link_display>Invited Speakers</url_link_display>
    <tracks>
      <track>Invited Speakers</track>
    </tracks>
    <timeslot>
      <slot_id>30299006-d5a9-43e9-a0af-72f76626def2</slot_id>
      <title>Probabilistic Programming and Inference Compilation, or, How I Learned to Stop Worrying and Love Deep Networks</title>
      <room>PLDI-MainTrack-A</room>
      <date>2017/06/21</date>
      <start_time>09:00</start_time>
      <end_time>09:55</end_time>
      <description>Probabilistic programming uses programming language techniques to make it easy to denote and perform inference in the kinds of probabilistic models that inform decision-making, accelerate scientific discovery, and underlie modern attacks on the problem of artificial intelligence. Deep learning uses programming language techniques to automate supervised learning of program parameter values by gradient-based optimization.What happens if we put them together? This talk will review probabilistic programming. It will also introduce inference compilation and address how linking deep learning and probabilistic programming is leading to powerful new AI techniques while also opening up significant new research questions.</description>
      <persons>
        <person>
          <role>Keynote Speaker</role>
          <sort_key>1</sort_key>
          <first_name>Frank</first_name>
          <last_name>Wood</last_name>
          <affiliation>University of Oxford</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.robots.ox.ac.uk/~fwood/</homepage_url>
          <picture_url>http://pldi17.sigplan.org/getProfileImage/frankwood/c81b456a-695a-4eeb-bad4-4609f231f346/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Invited Speakers</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>8748277e-4fd1-467b-bc30-1dd3fd6e169e</subevent_id>
    <title>SOAP: Benchmarking</title>
    <subevent_type type="regular"/>
    <room>PLDI-C</room>
    <date>2017/06/18</date>
    <url>http://pldi17.sigplan.org/track/SOAP-2017-papers</url>
    <url_link_display>SOAP 2017</url_link_display>
    <tracks>
      <track>SOAP 2017</track>
    </tracks>
    <timeslot>
      <slot_id>58db5e74-51ff-4a6a-a101-3a644506536a</slot_id>
      <title>Hermes: Assessment and Creation of Effective Test Corpora</title>
      <room>PLDI-C</room>
      <date>2017/06/18</date>
      <start_time>16:00</start_time>
      <end_time>16:20</end_time>
      <description>An integral part of developing a new analysis is to validate the correctness of its implementation and to demonstrate its usefulness when applied to real-world code. As a foundation for addressing both challenges developers typically use custom or well-established collections of Java projects. The hope is that the collected projects are representative for the analysis’ target domain and therefore ensure a sound evaluation. But, without proper means to understand how and to which degree the features relevant to an analysis are found in the projects, the evaluation necessarily remains inconclusive. Additionally, it is likely that the collection contains many projects which are – w.r.t. the developed analysis – basically identical and therefore do not help the overall evaluation/testing of the analysis, but still cost evaluation time. To overcome these limitations we propose Hermes, a framework that enables the systematic assessment of given corpora and the creation of new corpora of Java projects. To show the usefulness of Hermes, we used it to comprehend the nature of the projects belonging to the Qualitas Corpus (QC) and then used it to compute a minimal subset of all QC projects useful for generic data- and control-flow analyses. This subset enables effective and efficient integration test suites.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Michael</first_name>
          <last_name>Reif</last_name>
          <affiliation>TU Darmstadt, Germany</affiliation>
          <bio>undefined</bio>
          <picture_url>http://pldi17.sigplan.org/getProfileImage/michaelreif/f8b76a60-c00d-415b-8ce6-23e761896cff/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Michael</first_name>
          <last_name>Eichberg</last_name>
          <affiliation>TU Darmstadt, Germany</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Ben</first_name>
          <last_name>Hermann</last_name>
          <affiliation>Technische Universität Darmstadt</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.thewhitespace.de</homepage_url>
          <picture_url>http://pldi17.sigplan.org/getProfileImage/benhermann1/8d5d764e-6408-48bb-9ead-c1c016c62297/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Mira</first_name>
          <last_name>Mezini</last_name>
          <affiliation>TU Darmstadt</affiliation>
          <bio>I am a Professor of Computer Science at the Technical University of Darmstadt, Germany.
My research focuses on software development paradigms and tools.
On the paradigms side, I develop programming languages to enable the visions of “software as a service (SaaS)” and “software product-lines” by providing large-scale module concepts with built-in support for adaptability and extensibility.
On the tools side, I work on intelligent software-development environments that guide developers to increase the development productivity and the software quality. Such environment leverage web-based resources to automatically generate and recommend established programming rules and patterns; they also enable architects to explicitly specify such patterns to be enforced during development.
I have (co)authored over 100 scientific publications in renowned publication venues in software engineering and programming languages. I regularly serve on steering committees, program committees, and editorial boards of top tier conferences and journals in software engineering and programming languages.</bio>
          <homepage_url>http://www.stg.tu-darmstadt.de/staff/mira_mezini/</homepage_url>
          <picture_url>http://pldi17.sigplan.org/getProfileImage/miramezini/8e9ce50d-5266-482f-8510-cf2da66e77ae/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>SOAP 2017</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>1d7a0053-ab9c-4003-b2d9-c368de001b6b</subevent_id>
    <title>SOAP: Invited Speaker - Julian Dolby</title>
    <subevent_type type="regular"/>
    <room>PLDI-C</room>
    <date>2017/06/18</date>
    <url>http://pldi17.sigplan.org/track/SOAP-2017-papers</url>
    <url_link_display>SOAP 2017</url_link_display>
    <tracks>
      <track>SOAP 2017</track>
    </tracks>
    <timeslot>
      <slot_id>1e002b92-2fbe-41d1-8c78-280ec2135319</slot_id>
      <title>WALA Everywhere</title>
      <room>PLDI-C</room>
      <date>2017/06/18</date>
      <start_time>14:00</start_time>
      <end_time>14:45</end_time>
      <description>The Watson Libraries for Analysis (WALA) started life as analysis for Java bytecode, but soon grew to include JavaScript and .NET bytecode as well. I shall briefly summarize this history and the design decisions that grew out of it, because those decisions enabled further expansion after WALA became open source: from Android to nodejs, WALA handles more systems, much of the work being done by the community and contributed to the open source project. I shall talk about 3 of those expansions. The first is analysis of hybrid mobile applications, in which Android bytecode and JavaScript source code are analyzed together to create a cross-language analysis result; I shall present the WALA architecture that enables such analysis and talk about how such analysis has been used so far. The second is WALA Client, in which much of WALA is run in a Web browser, including a version of our JavaScript analysis, potentially enabling live analysis of visited Web sites. I shall discuss how this is accomplished technically, and I shall show it running as part of the talk. Third, I shall discuss our ongoing work building analysis of Apple’s Swift language. Throughout this talk, I shall try to bring out how WALA design decisions made in the beginning have enabled this expansion, and how an increasing community of researchers have made it possible.</description>
      <persons>
        <person>
          <role>Keynote Speaker</role>
          <sort_key>1</sort_key>
          <first_name>Julian</first_name>
          <last_name>Dolby</last_name>
          <affiliation>IBM Thomas J. Watson Research Center</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://researcher.watson.ibm.com/researcher/view.php?person=us-dolby</homepage_url>
          <picture_url>http://pldi17.sigplan.org/getProfileImage/juliandolby/092667c4-6e51-4476-8ef0-58b41ce9014d/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>SOAP 2017</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>e215320c-e57c-4c64-a185-577a21ad9619</subevent_id>
    <title>SOAP: Modular Analysis</title>
    <subevent_type type="regular"/>
    <room>PLDI-C</room>
    <date>2017/06/18</date>
    <url>http://pldi17.sigplan.org/track/SOAP-2017-papers</url>
    <url_link_display>SOAP 2017</url_link_display>
    <tracks>
      <track>SOAP 2017</track>
    </tracks>
    <timeslot>
      <slot_id>13653e1f-c15f-4cba-b07d-b66c85806465</slot_id>
      <title>Porting Doop to Soufflé: A Tale of Inter-Engine Portability for Datalog-Based Analyses</title>
      <room>PLDI-C</room>
      <date>2017/06/18</date>
      <start_time>12:07</start_time>
      <end_time>12:30</end_time>
      <description>We give a declarative model of a rich family of must-alias analyses. Our emphasis is on careful and compact modeling, while exposing the key points where the algorithm can adjust its inference power. The model is executable, in the Datalog language, and forms the basis of a full-fledged must-alias analysis of Java bytecode in the DOOP framework.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Tony</first_name>
          <last_name>Antoniadis</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <picture_url>http://pldi17.sigplan.org/getProfileImage/tonyantoniadis/fb0f10eb-be87-449a-bb29-3879c99c4bf2/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Konstantinos</first_name>
          <last_name>Triantafyllou</last_name>
          <affiliation>University of Athens, Greece</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Yannis</first_name>
          <last_name>Smaragdakis</last_name>
          <affiliation>University of Athens</affiliation>
          <bio>Research Interests: applied programming languages and software engineering 
 
 Language mechanisms for abstraction (declarative languages, program generation, DSLs, modules and components, generics, extensible languages, multi-paradigm programming) 
 Program analysis and testing (pointer analysis, automatic test generation, invariant inference, symbolic execution) 
 Languages and tools for systems (programming models for concurrency, language support for distributed computing, memory management and program locality)</bio>
          <homepage_url>http://smaragd.org/</homepage_url>
          <picture_url>http://pldi17.sigplan.org/getProfileImage/yannissmaragdakis/62908ab5-aaed-4f2a-a953-10d12d91d826/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>SOAP 2017</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>bd0f8184-9807-4bf7-8083-672c2f6684d6</slot_id>
      <title>SootKeeper: Runtime Reusability for Modular Static Analysis</title>
      <room>PLDI-C</room>
      <date>2017/06/18</date>
      <start_time>11:45</start_time>
      <end_time>12:07</end_time>
      <description>In order to achieve a higher reusability and testability, static analyses are increasingly being build as modular pipelines of analysis components. However, to build, debug, test, and evaluate these components the complete pipeline has to be executed every time. This process recomputes intermediate results which have already been computed in a previous run but are lost because the preceding process ended and removed them from memory. We propose to leverage runtime reusability for static analysis pipelines and introduce SootKeeper, a framework to modularize static analyses into OSGi (Open Service Gateway initiative) bundles, which takes care of the automatic caching of intermediate results. Little to no change to the original analysis is necessary to use SootKeeper while speeding up the execution of code-build-debug cycles or evaluation pipelines significantly.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Florian</first_name>
          <last_name>Kübler</last_name>
          <affiliation>TU Darmstadt, Germany</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Patrick</first_name>
          <last_name>Müller</last_name>
          <affiliation>TU Darmstadt, Germany</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Ben</first_name>
          <last_name>Hermann</last_name>
          <affiliation>Technische Universität Darmstadt</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.thewhitespace.de</homepage_url>
          <picture_url>http://pldi17.sigplan.org/getProfileImage/benhermann1/8d5d764e-6408-48bb-9ead-c1c016c62297/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>SOAP 2017</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>a4b4c2c3-7d26-4b14-ad43-c6dba85215e9</subevent_id>
    <title>SOAP: Soundness and Precision</title>
    <subevent_type type="regular"/>
    <room>PLDI-C</room>
    <date>2017/06/18</date>
    <url>http://pldi17.sigplan.org/track/SOAP-2017-papers</url>
    <url_link_display>SOAP 2017</url_link_display>
    <tracks>
      <track>SOAP 2017</track>
    </tracks>
    <timeslot>
      <slot_id>ab9aeae9-c4ef-4324-bf42-044934d97fde</slot_id>
      <title>On the Construction of Soundness Oracles</title>
      <room>PLDI-C</room>
      <date>2017/06/18</date>
      <start_time>15:07</start_time>
      <end_time>15:30</end_time>
      <description>One of the inherent advantages of static analysis is that it can create and reason about models of an entire program. However, mainstream languages such as Java use numerous dynamic language features designed to boost programmer productivity, but these features are notoriously difficult to capture by static analysis, leading to unsoundness in practice. 
While existing research has focused on providing sound handling for selected language features (mostly reflection) based on anecdotal evidence and case studies, there is little empirical work to investigate the extent to which particular features cause unsoundness of static analysis in practice. In this paper, we (1) discuss language features that may cause unsoundness and (2) discuss a methodology that can be used to check the (un)soundness of a particular static analysis, call-graph construction, based on soundness oracles. These oracles can also be used for hybrid analyses.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Jens</first_name>
          <last_name>Dietrich</last_name>
          <affiliation>Massey University</affiliation>
          <bio>I am an Associate Professor in the School of Engineering and Advanced Technology (SEAT) at the Turitea (Palmerston North) Campus of Massey University. I amalso the major leader of the Software Engineering program at Massey. I have a Master in Mathematics and a PhD in Computer Science from the University of Leipzig. I have worked for a couple of years in industry as consultant in Germany, Namibia, Switzerland and the UK, and returned in 2003 to academia. My research interests are in the areas of software componentry and evolution and static analysis.</bio>
          <homepage_url>https://sites.google.com/site/jensdietrich/</homepage_url>
          <picture_url>http://pldi17.sigplan.org/getProfileImage/jensdietrich/ab54c290-4f44-4d77-9842-cdc18922d7b4/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Li</first_name>
          <last_name>Sui</last_name>
          <affiliation>Massey University, New Zealand</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Shawn</first_name>
          <last_name>Rasheed</last_name>
          <affiliation>Massey University</affiliation>
          <bio>I am a PhD student at Massey University. Currently, my research is in using program analysis for software security.</bio>
          <picture_url>http://pldi17.sigplan.org/getProfileImage/shawnrasheed/3cd79b5c-7bee-44f6-9c33-78d9e8956d7f/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Amjed</first_name>
          <last_name>Tahir</last_name>
          <affiliation>Massey University</affiliation>
          <bio>I am a Lecturer at Massey University, New Zealand. I obtained my PhD from the University of Otago in 2016. My research interest is on program maintenance and comprehension.</bio>
          <picture_url>http://pldi17.sigplan.org/getProfileImage/amjedtahir/8de3cc3f-2d29-425d-b997-399d3e03747d/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>SOAP 2017</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>cdf0d241-78ad-46cf-9b10-fb019d35ca21</slot_id>
      <title>Systematic Approaches for Increasing Soundness and Precision of Static Analyzers</title>
      <room>PLDI-C</room>
      <date>2017/06/18</date>
      <start_time>14:45</start_time>
      <end_time>15:07</end_time>
      <description>Building static analyzers for modern programming languages is difficult. Often soundness is a requirement, perhaps with some well-defined exceptions, and precision must be adequate for producing useful results on realistic input programs. Formally proving such properties of a complex static analysis implementation is rarely an option in practice, which raises the challenge of how to identify causes and importance of soundness and precision problems. 
Through a series of examples, we present our experience with semi-automated methods based on delta debugging and dynamic analysis for increasing soundness and precision of a static analyzer for JavaScript. The individual methods are well known, but to our knowledge rarely used systematically and in combination.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Esben</first_name>
          <last_name>Andreasen</last_name>
          <affiliation>Aarhus University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://cs.au.dk/~esbena</homepage_url>
          <picture_url>http://pldi17.sigplan.org/getProfileImage/esbenandreasen/b5c5a4ce-9ba9-4b00-946a-c511bc17b6cf/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Anders</first_name>
          <last_name>Møller</last_name>
          <affiliation>Aarhus University</affiliation>
          <bio>Professor at Department of Computer Science, Aarhus University, Denmark</bio>
          <homepage_url>https://cs.au.dk/~amoeller/</homepage_url>
          <picture_url>http://pldi17.sigplan.org/getProfileImage/andersmoller/a6b971e9-27d8-44ed-84d2-5ce2d53ff5e4/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Benjamin Barslev</first_name>
          <last_name>Nielsen</last_name>
          <affiliation>Aarhus University</affiliation>
          <bio>undefined</bio>
          <picture_url>http://pldi17.sigplan.org/getProfileImage/benjaminbarslevnielsen/7c6acacc-eb83-4ad2-8f27-d9a7ce64e58e/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>SOAP 2017</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>05f50c7e-649a-4a56-9227-7cd484de96ff</subevent_id>
    <title>SOAP: Invited Speaker - Sukyoung Ryu</title>
    <subevent_type type="regular"/>
    <room>PLDI-C</room>
    <date>2017/06/18</date>
    <url>http://pldi17.sigplan.org/track/SOAP-2017-papers</url>
    <url_link_display>SOAP 2017</url_link_display>
    <tracks>
      <track>SOAP 2017</track>
    </tracks>
    <timeslot>
      <slot_id>ac3691e2-e6f8-45f3-af17-fff6477f5b44</slot_id>
      <title>Journey to Find Bugs in JavaScript Web Applications in the Wild</title>
      <room>PLDI-C</room>
      <date>2017/06/18</date>
      <start_time>08:45</start_time>
      <end_time>09:30</end_time>
      <description>Analyzing real-world JavaScript web applications is a challenging task. On top of understanding the semantics of JavaScript, it requires modeling of web documents, platform objects, and interactions between them. In this talk, we present our attempts to analyze JavaScript web applications in the wild mostly statically using various approaches. From pure JavaScript programs to JavaScript web applications using platform-specific libraries and dynamic code loading, we explain technical challenges in analyzing each of them and how we built an open-source analysis framework for JavaScript, SAFE, that addresses the challenges incrementally. In spite of active research accomplishments in analysis of JavaScript web applications, many issues still remain to be resolved such as events, callback functions, and hybrid web applications. We discuss possible future research directions and open challenges.</description>
      <persons>
        <person>
          <role>Keynote Speaker</role>
          <sort_key>1</sort_key>
          <first_name>Sukyoung</first_name>
          <last_name>Ryu</last_name>
          <affiliation>KAIST</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://plrg.kaist.ac.kr/ryu</homepage_url>
          <picture_url>http://pldi17.sigplan.org/getProfileImage/sukyoungryu/3bdcd232-f3d4-4610-9953-30b513926e54/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>SOAP 2017</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>5f548767-5690-4bca-84f7-ac8ab90bbf74</subevent_id>
    <title>SOAP: Invited Speaker - Jingling Xue</title>
    <subevent_type type="regular"/>
    <room>PLDI-C</room>
    <date>2017/06/18</date>
    <url>http://pldi17.sigplan.org/track/SOAP-2017-papers</url>
    <url_link_display>SOAP 2017</url_link_display>
    <tracks>
      <track>SOAP 2017</track>
    </tracks>
    <timeslot>
      <slot_id>973aa6be-a64c-40c7-890d-44e07f910a21</slot_id>
      <title>Static Analysis of Java Reflection</title>
      <room>PLDI-C</room>
      <date>2017/06/18</date>
      <start_time>11:00</start_time>
      <end_time>11:45</end_time>
      <description>Reflection is a dynamic language feature that poses a major obstacle to static analyses, especially pointer analysis. In this talk, I will introduce several techniques/tools, ELF, SOLAR, TAILOR and RIPPLE, developed in my research group for statically handling reflection in the context of a pointer analysis. I will discuss some challenges and possible future research directions on reflection analysis.</description>
      <persons>
        <person>
          <role>Keynote Speaker</role>
          <sort_key>1</sort_key>
          <first_name>Jingling</first_name>
          <last_name>Xue</last_name>
          <affiliation>UNSW Australia</affiliation>
          <bio>Jingling Xue received his BSc and MSc degrees in Computer Science and Engineering from Tsinghua University in 1984 and 1987, respectively, and his PhD degree in Computer Science and Engineering from Edinburgh University in 1992. He is currently a Scientia Professor in the School of Computer Science and Engineering, University of New South Wales, Australia, where he leads the Programming Languages and Compilers Group. 
Jingling Xue’s main research interest has been programming languages and compilers for over 25 years. He is currently supervising a group of postdocs and PhD students on a number of topics including programming and compiler techniques for multi-core processors and embedded systems, concurrent programming models, static and dynamic program analysis for bugs and security vulnerabilities, security analysis of Android apps, and automatic parallelization of programs for parallel and distributed systems. His research has been supported by Intel, Sun Microsystems, Oracle, Huawei and Australian Research Council.
Jingling Xue is interested in sharing the outcomes of his research projects in the form of open-source tools (http://www.cse.unsw.edu.au/~jingling/tools.html). 
Jingling Xue is an Associate Editor for several journals, including IEEE Transactions on Computers (2011 – 2015), Software: Practice and Experience, and Journal of Computer Science and Technology. He has served as a program committee member in numerous conferences in his field.</bio>
          <homepage_url>http://www.cse.unsw.edu.au/~jingling/</homepage_url>
          <picture_url>http://pldi17.sigplan.org/getProfileImage/jinglingxue/cc011767-23b5-466f-9501-72b57243ae4d/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>SOAP 2017</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>94cee1a1-7e8f-4a7a-9f31-94c81baa0300</subevent_id>
    <title>SOAP: Opening</title>
    <subevent_type type="regular"/>
    <room>PLDI-C</room>
    <date>2017/06/18</date>
    <url>http://pldi17.sigplan.org/track/SOAP-2017-papers</url>
    <url_link_display>SOAP 2017</url_link_display>
    <tracks>
      <track>SOAP 2017</track>
    </tracks>
    <timeslot>
      <slot_id>08ecdf61-aae7-4ca7-a372-d7ef252df6b5</slot_id>
      <title>Opening</title>
      <room>PLDI-C</room>
      <date>2017/06/18</date>
      <start_time>08:30</start_time>
      <end_time>08:45</end_time>
      <description>undefined</description>
      <tracks>
        <track>SOAP 2017</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>c0f98226-1c36-41c1-9e2d-84d4b97a14aa</subevent_id>
    <title>SOAP: Open Discussion</title>
    <subevent_type type="regular"/>
    <room>PLDI-C</room>
    <date>2017/06/18</date>
    <url>http://pldi17.sigplan.org/track/SOAP-2017-papers</url>
    <url_link_display>SOAP 2017</url_link_display>
    <tracks>
      <track>SOAP 2017</track>
    </tracks>
    <timeslot>
      <slot_id>be3c302f-df4c-4fe2-a7bb-f4177cd77d3e</slot_id>
      <title>Open Discussion</title>
      <room>PLDI-C</room>
      <date>2017/06/18</date>
      <start_time>16:20</start_time>
      <end_time>18:00</end_time>
      <description>undefined</description>
      <tracks>
        <track>SOAP 2017</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>ba1375bd-deba-4a02-bc0a-ce14bafa44c9</subevent_id>
    <title>SOAP: Points-to Analysis</title>
    <subevent_type type="regular"/>
    <room>PLDI-C</room>
    <date>2017/06/18</date>
    <url>http://pldi17.sigplan.org/track/SOAP-2017-papers</url>
    <url_link_display>SOAP 2017</url_link_display>
    <tracks>
      <track>SOAP 2017</track>
    </tracks>
    <timeslot>
      <slot_id>218be595-aa2d-4a11-9ad4-f1f2d5340068</slot_id>
      <title>An Efficient Tunable Selective Points-to Analysis for Large Codebases</title>
      <room>PLDI-C</room>
      <date>2017/06/18</date>
      <start_time>10:10</start_time>
      <end_time>10:30</end_time>
      <description>Points-to analysis is a fundamental static program analysis technique for tools including compilers and bug-checkers. Although object-based context sensitivity is known to improve precision of points-to analysis, scaling it for large Java codebases remains a challenge. 
In this work, we develop a tunable, client-independent, object-sensitive points-to analysis framework where heap cloning is applied selectively. This approach is aimed at large codebases where standard analysis is typically expensive. Our design includes a pre-analysis that determines program points that contribute to the cost of an object-sensitive points-to analysis. A subsequent analysis then determines the context depth for each allocation site. While our framework can run standalone, it is also possible to tune it – the user of the framework can use the knowledge of the codebase being analysed to influence the selection of expensive program points as well as the process to differentiate the required context-depth. Overall, the approach determines where the cloning is beneficial and where the cloning is unlikely to be beneficial. 
We have implemented our approach using Souffl&amp;eacute; (a Datalog compiler) and an extension of the DOOP framework. Our experiments on large programs, including OpenJDK, show that our technique is efficient and precise. For the OpenJDK, our analysis reduces 27% of runtime and 18% of memory usage in comparison with 2O1H points-to analysis for a negligible loss of precision, while for Jython from the DaCapo benchmark suite, the same analysis reduces 91% of runtime for no loss of precision.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Behnaz</first_name>
          <last_name>Hassanshahi</last_name>
          <affiliation>Oracle Labs, Australia</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Raghavendra</first_name>
          <last_name>Kagalavadi</last_name>
          <affiliation>Oracle Labs, Australia</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://labs.oracle.com/pls/apex/f?p=labs:bio:0:1919</homepage_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Paddy</first_name>
          <last_name>Krishnan</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Bernhard</first_name>
          <last_name>Scholz</last_name>
          <affiliation>University of Sydney, Australia</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://sydney.edu.au/engineering/people/bernhard.scholz.php</homepage_url>
          <picture_url>http://pldi17.sigplan.org/getProfileImage/bernhardscholz1/2ad1b16f-f423-4db2-bfce-56e86799d860/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Yi</first_name>
          <last_name>Lu</last_name>
          <affiliation>Oracle</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>SOAP 2017</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>d4454eb0-31ab-42b0-8971-3867638f7839</slot_id>
      <title>Revisiting Recency Abstraction for JavaScript: Towards an Intuitive, Compositional, and Efficient Heap Abstraction</title>
      <room>PLDI-C</room>
      <date>2017/06/18</date>
      <start_time>09:30</start_time>
      <end_time>09:50</end_time>
      <description>JavaScript is one of the most widely used programming languages. To understand the behaviors of JavaScript programs and to detect possible errors in them, researchers have developed several static analyzers based on the abstract interpretation framework. However, JavaScript provides various language features that are difficult to analyze statically and precisely such as dynamic addition and removal of object properties, first-class property names, and higher-order functions. To alleviate the problem, JavaScript static analyzers often use recency abstraction, which refines address abstraction by distinguishing recent objects from summaries of old objects. We observed that while recency abstraction enables more precise analysis results by allowing strong updates on recent objects, it is not monotone in the sense that it does not preserve the precision relationship between the underlying address abstraction techniques: for an address abstraction A and a more precise abstraction B, recency abstraction on B may not be more precise than recency abstraction on A. Such an unintuitive semantics of recency abstraction makes its composition with various analysis sensitivity techniques also unintuitive. In this paper, we propose a new singleton abstraction technique, which distinguishes singleton objects to allow strong updates on them without changing a given address abstraction. We formally define recency and singleton abstractions, and explain the unintuitive behaviors of recency abstraction. Our preliminary experiments show promising results for singleton abstraction.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Jihyeok</first_name>
          <last_name>Park</last_name>
          <affiliation>KAIST, South Korea</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Xavier</first_name>
          <last_name>Rival</last_name>
          <affiliation>INRIA/CNRS/ENS Paris</affiliation>
          <bio>Xavier Rival is a Senior Research Scientist (Directeur de Recherche) at INRIA Paris. His research interest focus on abstract interpretation and software verification by static analysis. He is mainly working on symbolic abstractions (trace partitionning abstraction, shape analysis, separation logic and memory abstract domains). He has been involved in the design, implementation and transfer of the Astr&amp;eacute;e analyser, a static analyser able to verify safety properties on industrial size safety critical softwares. He is currently the PI of the MemCAD ERC Starting Grant, aiming at the design of a library of abstract domains to describe memory states containing a wide range of complex data structures. He is also the Head of the ANTIQUE INRIA group, located at ENS Paris, and Professeur Charg&amp;eacute; de Cours at Ecole Polytechnique.</bio>
          <homepage_url>http://www.di.ens.fr/~rival/</homepage_url>
          <picture_url>http://pldi17.sigplan.org/getProfileImage/xavierrival/036511d0-47a1-4db2-97df-0bf5da1a2c8d/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Sukyoung</first_name>
          <last_name>Ryu</last_name>
          <affiliation>KAIST</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://plrg.kaist.ac.kr/ryu</homepage_url>
          <picture_url>http://pldi17.sigplan.org/getProfileImage/sukyoungryu/3bdcd232-f3d4-4610-9953-30b513926e54/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>SOAP 2017</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>ec4040b8-9b46-42a1-bb6e-1630ead27f4b</slot_id>
      <title>A Datalog Model of Must-Alias Analysis</title>
      <room>PLDI-C</room>
      <date>2017/06/18</date>
      <start_time>09:50</start_time>
      <end_time>10:10</end_time>
      <description>We give a declarative model of a rich family of must-alias analyses. Our emphasis is on careful and compact modeling, while exposing the key points where the algorithm can adjust its inference power. The model is executable, in the Datalog language, and forms the basis of a full-fledged must-alias analysis of Java bytecode in the Doop framework.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>George</first_name>
          <last_name>Balatsouras</last_name>
          <affiliation>University of Athens</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://gbalats.github.io/</homepage_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Kostas</first_name>
          <last_name>Ferles</last_name>
          <affiliation>University of Texas at Austin, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.utexas.edu/~kferles</homepage_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>George</first_name>
          <last_name>Kastrinis</last_name>
          <affiliation>University of Athens</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://gkastrinis.github.io/</homepage_url>
          <picture_url>http://pldi17.sigplan.org/getProfileImage/georgekastrinis/fac68dc6-ebee-4a63-a6b5-1369ea311b9d/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Yannis</first_name>
          <last_name>Smaragdakis</last_name>
          <affiliation>University of Athens</affiliation>
          <bio>Research Interests: applied programming languages and software engineering 
 
 Language mechanisms for abstraction (declarative languages, program generation, DSLs, modules and components, generics, extensible languages, multi-paradigm programming) 
 Program analysis and testing (pointer analysis, automatic test generation, invariant inference, symbolic execution) 
 Languages and tools for systems (programming models for concurrency, language support for distributed computing, memory management and program locality)</bio>
          <homepage_url>http://smaragd.org/</homepage_url>
          <picture_url>http://pldi17.sigplan.org/getProfileImage/yannissmaragdakis/62908ab5-aaed-4f2a-a953-10d12d91d826/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>SOAP 2017</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>35062406-f301-473e-958a-f11989138592</subevent_id>
    <title>Research Papers: Compiler Optimizations</title>
    <subevent_type type="regular"/>
    <room>PLDI-MainTrack-B</room>
    <date>2017/06/19</date>
    <url>http://pldi17.sigplan.org/track/pldi-2017-papers</url>
    <url_link_display>Research Papers</url_link_display>
    <tracks>
      <track>Research Papers</track>
    </tracks>
    <timeslot>
      <slot_id>350fa9d5-21b8-483f-b05b-dd6c68c2d84f</slot_id>
      <title>Fusing Effectful Comprehensions</title>
      <room>PLDI-MainTrack-B</room>
      <date>2017/06/19</date>
      <start_time>11:15</start_time>
      <end_time>11:40</end_time>
      <description>List comprehensions provide a powerful abstraction mechanism for expressing computations over ordered collections of data declaratively without having to use explicit iteration constructs. This paper puts forth effectful comprehensions as an elegant way to describe list comprehensions that incorporate loop carried state. This is motivated by operations such as compression/decompression and serialization/deserialization that are common in log/data processing pipelines and require loop-carried state when processing an input stream of data.
We build on the underlying theory of symbolic transducers to fuse pipelines of effectful comprehensions into a single representation, from which efficient code can be generated. Using background theory reasoning with an SMT solver our fusion and subsequent reachability based branch elimination algorithms can significantly reduce the complexity of the fused pipelines. Our implementation shows significant speedups over reasonable hand-written code (3.4X, on average) and traditionally fused version of the pipeline (2.6X, on average) for a variety of examples, including scenarios for extracting fields with regular expressions, processing XML with XPath, and running queries over encoded data.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Olli</first_name>
          <last_name>Saarikivi</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Margus</first_name>
          <last_name>Veanes</last_name>
          <affiliation>Microsoft Research</affiliation>
          <bio>undefined</bio>
          <picture_url>http://pldi17.sigplan.org/getProfileImage/margusveanes/a5174253-0401-46f7-aff1-e92a3a3ace77/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Todd</first_name>
          <last_name>Mytkowicz</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Madan</first_name>
          <last_name>Musuvathi</last_name>
          <affiliation>Microsoft Research</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://research.microsoft.com/en-us/people/madanm/</homepage_url>
          <picture_url>http://pldi17.sigplan.org/getProfileImage/madanmusuvathi/03a998f8-9b95-465d-acc2-a35967c0319f/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>4587cd04-6e0a-4950-b009-0598fa195332</slot_id>
      <title>Generalizations of the Theory and Deployment of Triangular Inequality for Compiler-Based Strength Reduction</title>
      <room>PLDI-MainTrack-B</room>
      <date>2017/06/19</date>
      <start_time>11:40</start_time>
      <end_time>12:05</end_time>
      <description>Triangular Inequality (TI) has been used in many manual algorithm designs to achieve good efficiency in solving some distance calculation-based problems. This paper presents our generalization of the idea into a compiler optimization technique, named TI-based strength reduction. The generalization consists of three parts. The first is the establishment of the theoretic foundation of this new optimization via the development of a new form of TI named Angular Triangular Inequality, along with several fundamental theorems. The second is the revealing of the properties of the new forms of TI and the proposal of guided TI adaptation, a systematic method to address the difficulties in effective deployments of TI optimizations. The third is an integration of the new optimization technique in an open-source compiler. Experiments on a set of data mining and machine learning algorithms show that the new technique can speed up the standard implementations by as much as 134X and 46X on average for distance-related problems, outperforming previous TI-based optimizations by 2.35X on average. It also extends the applicability of TI-based optimizations to vector related problems, producing tens of times of speedup.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Yufei</first_name>
          <last_name>Ding</last_name>
          <affiliation>North Carolina State University</affiliation>
          <bio>undefined</bio>
          <picture_url>http://pldi17.sigplan.org/getProfileImage/yufeiding/c37f32e5-103b-4441-891c-b82fc8e9640a/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Lin</first_name>
          <last_name>Ning</last_name>
          <affiliation>North Carolina State University</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Hui</first_name>
          <last_name>Guan</last_name>
          <affiliation>North Carolina State University</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Xipeng</first_name>
          <last_name>Shen</last_name>
          <affiliation>North Carolina State University</affiliation>
          <bio>Xipeng Shen is an associate professor at the Computer Science Department, North Carolina State University (NCSU). He has been an IBM Canada CAS Research Faculty Fellow since 2010, and a receipt of the 2010 NSF CAREER Award, 2011 DOE Early Career Award, and 2015 Google Faculty Research Award. Before joining NCSU, he was an Adina Allen Term Distinguished Associate Professor at the College of William and Mary.</bio>
          <homepage_url>http://people.engr.ncsu.edu/xshen5/</homepage_url>
          <picture_url>http://pldi17.sigplan.org/getProfileImage/xipengshen/7ba54e69-f90a-4cf7-90d2-19fdd5f42e87/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>c3d1c481-6e07-4ccd-8aa4-aecab86c9646</slot_id>
      <title>Cache Locality Optimization for Recursive Programs</title>
      <room>PLDI-MainTrack-B</room>
      <date>2017/06/19</date>
      <start_time>10:50</start_time>
      <end_time>11:15</end_time>
      <description>We present an approach to optimize the cache locality for recursive programs by dynamically splicing—recursively interleaving—the execution of distinct function invocations. By utilizing data effect annotations, we identify concurrency and data reuse opportunities across function invocations and interleave them to reduce reuse distance. We present algorithms that efficiently track effects in recursive programs, detect interference and dependencies, and interleave execution of function invocations using user-level (non-kernel) lightweight threads. To enable multi-core execution, a program is parallelized using a nested fork/join programming model. Our cache optimization strategy is designed to work in the context of a random work stealing scheduler. We present an implementation using the MIT Cilk framework that demonstrates significant improvements in sequential and parallel performance, competitive with a state-of-the-art compile-time optimizer for loop programs and a domain-specific optimizer for stencil programs.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Jonathan</first_name>
          <last_name>Lifflander</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Sriram</first_name>
          <last_name>Krishnamoorthy</last_name>
          <affiliation>Pacific Northwest National Laboratories</affiliation>
          <bio>Sriram Krishnamoorthy currently is a research scientist and the System Software and Applications Team Leader in PNNL’s High Performance Computing group, where he focuses on parallel programming models, fault tolerance, and compile-time/runtime optimizations for high-performance computing. He has more than 80 peer-reviewed conference and journal publications, receiving Best Paper awards for his publications at the International Conference on High Performance Computing (HiPC’03) and the International Parallel and Distributed Processing Symposium (IPDPS’04). In 2013, he received a U.S. Department of Energy Early Career award. That year, he also earned PNNL’s Ronald L. Brodzinski Award for Early Career Exceptional Achievement. In 2008, he received The Ohio State University’s Outstanding Researcher award. Dr. Krishnamoorthy is a senior member of the Institute of Electrical and Electronics Engineers. He earned his B.E. from the College of Engineering, Guindy (Chennai, India) and M.S. and Ph.D. degrees from The Ohio State University.</bio>
          <homepage_url>http://hpc.pnl.gov/people/sriram/</homepage_url>
          <picture_url>http://pldi17.sigplan.org/getProfileImage/sriramkrishnamoorthy/473cc601-1284-4417-bc71-6230b1548b0a/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>d1ce7a2a-eac0-4c7e-b358-4d2fcb699248</slot_id>
      <title>ALIVE-INFER: Data-Driven Precondition Inference for Peephole Optimizations in LLVM</title>
      <room>PLDI-MainTrack-B</room>
      <date>2017/06/19</date>
      <start_time>12:05</start_time>
      <end_time>12:30</end_time>
      <description>Peephole optimizations are a common source of compiler bugs. Compiler developers typically transform an incorrect peephole optimization into a valid one by strengthening the precondition. This process is challenging and tedious. This paper proposes, PInfer, a data-driven approach for inferring preconditions for peephole optimizations expressed in Alive. PInfer generates positive and negatives examples for an optimization, enumerates predicates on-demand, and learns a set of predicates that separate the positive and negative examples. PInfer repeats this process until it finds a precondition that ensures the validity of the optimization. PInfer reports both the weakest precondition and a set of succinct partial preconditions to the developer. The PInfer prototype successfully generates either the partial precondition or the weakest precondition for 164 out of 174 peephole optimizations in the Alive suite. It also generates preconditions that are weaker than LLVM’s precondition for 73 optimizations. We also demonstrate the applicability of this technique to generalize 54 concrete expression directed acyclic graphs generated by an LLVM IR-based super optimizer.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>David</first_name>
          <last_name>Menendez</last_name>
          <affiliation>Rutgers University</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Santosh</first_name>
          <last_name>Nagarakatte</last_name>
          <affiliation>Rutgers University, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.rutgers.edu/~santosh.nagarakatte/</homepage_url>
          <picture_url>http://pldi17.sigplan.org/getProfileImage/santoshnagarakatte/a3ea2016-e7d9-4e30-9b59-c61dd7270ea1/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>cb70627a-4eb9-4cc6-928e-d504ad8bccf5</subevent_id>
    <title>Research Papers: Language Implementation</title>
    <subevent_type type="regular"/>
    <room>PLDI-MainTrack-A</room>
    <date>2017/06/19</date>
    <url>http://pldi17.sigplan.org/track/pldi-2017-papers</url>
    <url_link_display>Research Papers</url_link_display>
    <tracks>
      <track>Research Papers</track>
    </tracks>
    <timeslot>
      <slot_id>188c3f3d-d141-4c6d-ba1f-74bfe7fd1a0e</slot_id>
      <title>Simple, fast and safe manual memory management</title>
      <room>PLDI-MainTrack-A</room>
      <date>2017/06/19</date>
      <start_time>15:15</start_time>
      <end_time>15:40</end_time>
      <description>Safe programming languages are readily available, but many applications continue to be written in unsafe languages, because the latter are more efficient. As a consequence, many applications continue to have exploitable memory safety bugs. Since garbage collection is a major source of inefficiency in the implementation of safe languages, replacing it with safe manual memory management would be an important step towards solving this problem.
Previous approaches to safe manual memory management use programming models based on regions, unique pointers, borrowing of references, and ownership types. We propose a much simpler programming model that does not require any of these concepts. Starting from the design of an imperative type safe language (like Java or C#), we just add a delete operator to free memory explicitly and an exception which is thrown if the program dereferences a pointer to freed memory. We propose an efficient implementation of this programming model that guarantees type safety. Experimental results from our implementation based on the C# native compiler show that this design achieves up to 3x reduction in peak working set and run time.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Piyus</first_name>
          <last_name>Kedia</last_name>
          <affiliation>Indian Institute of Technology Delhi</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Manuel</first_name>
          <last_name>Costa</last_name>
          <affiliation>Microsoft Research</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Matthew</first_name>
          <last_name>Parkinson</last_name>
          <affiliation>Microsoft Research, UK</affiliation>
          <bio>undefined</bio>
          <picture_url>http://pldi17.sigplan.org/getProfileImage/matthewparkinson/7039a7e0-dad3-4392-9f54-2f2c04477e71/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Kapil</first_name>
          <last_name>Vaswani</last_name>
          <affiliation>Microsoft Research</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Dimitrios</first_name>
          <last_name>Vytiniotis</last_name>
          <affiliation>Microsoft Research, Cambridge</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://research.microsoft.com/people/dimitris</homepage_url>
          <picture_url>http://pldi17.sigplan.org/getProfileImage/dimitriosvytiniotis/727f6b72-4d78-4863-a3a8-9b15d45ce7ac/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>48603c55-61e7-4e58-9c43-1c4d49de6686</slot_id>
      <title>Proactive and Adaptive Energy-Aware Programming with Mixed Typechecking</title>
      <room>PLDI-MainTrack-A</room>
      <date>2017/06/19</date>
      <start_time>14:50</start_time>
      <end_time>15:15</end_time>
      <description>Application-level energy management is an important dimension of energy optimization. In this paper, we introduce ENT, a novel programming language for enabling proactive and adaptive mode-based energy management at the application level. The proactive design allows programmers to apply their application knowledge to energy management, by characterizing the energy behavior of different program fragments with modes. The adaptive design allows such characterization to be delayed until run time, useful for capturing dynamic program behavior dependent on program states, configuration settings, external battery levels, or CPU temperatures. The key insight is both proactiveness and adaptiveness can be unified under a type system combined with static typing and dynamic typing. ENT has been implemented as an extension to Java, and successfully ported to three energy-conscious platforms: an Intel-based laptop, a Raspberry Pi, and an Android phone. Evaluation shows ENT improves the programmability, debuggability, and energy efficiency of battery-aware and temperature-aware programs.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Anthony</first_name>
          <last_name>Canino</last_name>
          <affiliation>SUNY Binghamton</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Yu David</first_name>
          <last_name>Liu</last_name>
          <affiliation>State University of New York (SUNY) Binghamton</affiliation>
          <bio>I am an Associate Professor at State University of New York (SUNY) at Binghamton. I am interested in programming languages, software engineering, and systems, with current focuses on energy-aware programming languages, data-intensive software, and type systems. I received my Ph.D. in Computer Science from the Johns Hopkins University, in 2007.</bio>
          <homepage_url>http://www.cs.binghamton.edu/~davidl</homepage_url>
          <picture_url>http://pldi17.sigplan.org/getProfileImage/yudavidliu/1da5367f-6c86-4df7-859d-ca63bc2a178b/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>6b2a3bce-b8be-4d89-8d8f-5712b3f785c0</slot_id>
      <title>Miniphases: Compilation using Modular and Efficient Tree Transformations</title>
      <room>PLDI-MainTrack-A</room>
      <date>2017/06/19</date>
      <start_time>14:25</start_time>
      <end_time>14:50</end_time>
      <description>Production compilers commonly perform dozens of transformations on an intermediate representation. Running those transformations in separate passes harms performance. One approach to recover performance is to combine transformations by hand in order to reduce number of passes. Such an approach harms modularity, and thus makes it hard to maintain and evolve a compiler over the long term, and makes reasoning about performance harder. This paper describes a methodology that allows a compiler writer to define multiple transformations separately, but fuse them into a single traversal of the intermediate representation when the compiler runs. This approach has been implemented in a compiler for the Scala language. Our performance evaluation indicates that this approach reduces the running time of tree transformations by 35\% and shows that this is due to improved cache friendliness. At the same time, the approach improves total memory consumption by reducing the object tenuring rate by 50\%. This approach enables compiler writers to write transformations that are both modular and fast at the same time.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Dmytro</first_name>
          <last_name>Petrashko</last_name>
          <affiliation>EPFL</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Ondřej</first_name>
          <last_name>Lhoták</last_name>
          <affiliation>University of Waterloo, Canada</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://plg.uwaterloo.ca/~olhotak/</homepage_url>
          <picture_url>http://pldi17.sigplan.org/getProfileImage/ondrejlhotak/5eff0fbe-ccf6-4901-88b8-25b68df221a3/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Martin</first_name>
          <last_name>Odersky</last_name>
          <affiliation>EPFL, Switzerland</affiliation>
          <bio>Martin Odersky is a professor at EPFL in Lausanne, Switzerland. He has been working on programming languages for most of his career. He first studied structured and object-oriented programming as a PhD student of Niklaus Wirth, then fell in love with functional programming while working as a post doc at IBM and Yale. When Java came out, he started to add functional programming constructs to the new platform. This led to Pizza and GJ and eventually to Java 5 with generics. During that time he also developed javac, the current reference compiler for Java. 
Over the last 10 years, Martin worked on unifying object-oriented and functional programming in the Scala language. Scala quickly escaped from the research lab and became a popular open source tool and industrial language. He now oversees development of Scala as head of the programming group at EPFL and as academic director of the Scala center.</bio>
          <homepage_url>http://lampwww.epfl.ch/~odersky/</homepage_url>
          <picture_url>http://pldi17.sigplan.org/getProfileImage/martinodersky/ae04208a-af42-4887-a6c1-b5952a33acf3/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>8b31ac7a-d960-4b73-88f4-b969876aa8ef</slot_id>
      <title>Bringing the Web up to Speed with WebAssembly</title>
      <room>PLDI-MainTrack-A</room>
      <date>2017/06/19</date>
      <start_time>14:00</start_time>
      <end_time>14:25</end_time>
      <description>The rapid improvement in JavaScript virtual machines combined with maturation of Web platform tools has given rise to sophisticated and demanding web applications such as interactive 3D maps, audio and video software, and games. The increasing ambition of these applications has made the efficiency and security of mobile code on the web more important than ever. Yet JavaScript has inconsistent performance and a number of other pitfalls, especially as a compilation target. Engineers from all major browser vendors have risen to the challenge and collaboratively designed a new low-level byte code for the web called WebAssembly. It offers compact representation, fast and simple validation and compilation, low to no-overhead safe execution, and easy interoperation with the web platform, including direct access to JavaScript and Web APIs. Rather than committing to a specific programming model, WebAssembly is an abstraction over modern hardware, making it both language- and platform-independent. We describe the motivation, design and formal semantics of WebAssembly and provide some preliminary experience with implementations.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Andreas</first_name>
          <last_name>Haas</last_name>
          <affiliation>Google</affiliation>
          <bio>undefined</bio>
          <picture_url>http://pldi17.sigplan.org/getProfileImage/andreashaas/392df86d-f0c7-42b1-b4b2-d91a5cc8f885/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Andreas</first_name>
          <last_name>Rossberg</last_name>
          <affiliation>Google</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.mpi-sws.org/~rossberg/</homepage_url>
          <picture_url>http://pldi17.sigplan.org/getProfileImage/andreasrossberg/c6329233-e420-4a58-9b0f-f6619c045332/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Derek</first_name>
          <last_name>Schuff</last_name>
          <affiliation>Google</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Ben</first_name>
          <last_name>L. Titzer</last_name>
          <affiliation>Google</affiliation>
          <bio>undefined</bio>
          <picture_url>http://pldi17.sigplan.org/getProfileImage/benltitzer/e78a671d-6f5a-48da-8c42-596ccc112232/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Dan</first_name>
          <last_name>Gohman</last_name>
          <affiliation>Mozilla</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Luke</first_name>
          <last_name>Wagner</last_name>
          <affiliation>Mozilla</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>7</sort_key>
          <first_name>Alon</first_name>
          <last_name>Zakai</last_name>
          <affiliation>Mozilla</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>8</sort_key>
          <first_name>JF</first_name>
          <last_name>Bastien</last_name>
          <affiliation>Apple</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://twitter.com/jfbastien</homepage_url>
          <picture_url>http://pldi17.sigplan.org/getProfileImage/jfbastien/df47221b-e29e-466b-aed1-ce7fea486c37/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>9</sort_key>
          <first_name>Michael</first_name>
          <last_name>Holman</last_name>
          <affiliation>Microsoft</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>ef0d5637-79c7-41ce-91e5-03b2512a908b</subevent_id>
    <title>Research Papers: Static Analysis</title>
    <subevent_type type="regular"/>
    <room>PLDI-MainTrack-B</room>
    <date>2017/06/19</date>
    <url>http://pldi17.sigplan.org/track/pldi-2017-papers</url>
    <url_link_display>Research Papers</url_link_display>
    <tracks>
      <track>Research Papers</track>
    </tracks>
    <timeslot>
      <slot_id>31633850-f345-444f-b984-ead313955cd0</slot_id>
      <title>Efficient and Precise Points-to Analysis: Modeling the Heap by Merging Equivalent Automata</title>
      <room>PLDI-MainTrack-B</room>
      <date>2017/06/19</date>
      <start_time>17:00</start_time>
      <end_time>17:25</end_time>
      <description>Mainstream points-to analysis techniques for object-oriented languages rely predominantly on the allocation-site abstraction to model heap objects. We present MAHJONG, a novel heap abstraction that is specifically developed to address the needs of an important class of type-dependent clients, such as call graph construction, devirtualization and may-fail casting. By merging equivalent automata representing type-consistent objects that are created by the allocation-site abstraction, MAHJONG enables an allocation-site-based points-to analysis to run significantly faster while achieving nearly the same precision for type-dependent clients. MAHJONG is simple conceptually, efficient, and drops easily on any allocation-site-based points-to analysis. We demonstrate its effectiveness by discussing some insights on why it is a better alternative of the allocation-site abstraction for type-dependent clients and evaluating it extensively on 12 large real-world Java programs with five context-sensitive points-to analyses and three widely used type-dependent clients. MAHJONG is expected to provide significant benefits for many program analyses where call graphs are required.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Tian</first_name>
          <last_name>Tan</last_name>
          <affiliation>UNSW Australia</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cse.unsw.edu.au/~tiantan/</homepage_url>
          <picture_url>http://pldi17.sigplan.org/getProfileImage/tiantan/4b1e811e-fce9-4642-92fb-d629f222b572/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Yue</first_name>
          <last_name>Li</last_name>
          <affiliation>UNSW Australia</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cse.unsw.edu.au/~yueli/</homepage_url>
          <picture_url>http://pldi17.sigplan.org/getProfileImage/yueli/c0b3b5ef-ffac-472c-9a05-5b9c8f165d7d/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Jingling</first_name>
          <last_name>Xue</last_name>
          <affiliation>UNSW Australia</affiliation>
          <bio>Jingling Xue received his BSc and MSc degrees in Computer Science and Engineering from Tsinghua University in 1984 and 1987, respectively, and his PhD degree in Computer Science and Engineering from Edinburgh University in 1992. He is currently a Scientia Professor in the School of Computer Science and Engineering, University of New South Wales, Australia, where he leads the Programming Languages and Compilers Group. 
Jingling Xue’s main research interest has been programming languages and compilers for over 25 years. He is currently supervising a group of postdocs and PhD students on a number of topics including programming and compiler techniques for multi-core processors and embedded systems, concurrent programming models, static and dynamic program analysis for bugs and security vulnerabilities, security analysis of Android apps, and automatic parallelization of programs for parallel and distributed systems. His research has been supported by Intel, Sun Microsystems, Oracle, Huawei and Australian Research Council.
Jingling Xue is interested in sharing the outcomes of his research projects in the form of open-source tools (http://www.cse.unsw.edu.au/~jingling/tools.html). 
Jingling Xue is an Associate Editor for several journals, including IEEE Transactions on Computers (2011 – 2015), Software: Practice and Experience, and Journal of Computer Science and Technology. He has served as a program committee member in numerous conferences in his field.</bio>
          <homepage_url>http://www.cse.unsw.edu.au/~jingling/</homepage_url>
          <picture_url>http://pldi17.sigplan.org/getProfileImage/jinglingxue/cc011767-23b5-466f-9501-72b57243ae4d/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>61671d70-746c-4928-9db5-5937cc4c3b2a</slot_id>
      <title>Context Transformations for Pointer Analysis</title>
      <room>PLDI-MainTrack-B</room>
      <date>2017/06/19</date>
      <start_time>16:35</start_time>
      <end_time>17:00</end_time>
      <description>Points-to analysis for Java benefits greatly from context-sensitivity. CFL-reachability and k-limited context-strings are two approaches to obtaining context sensitivity with different advantages: CFL-reachability allows local reasoning about data-value flow and thus is suitable for demand-driven analyses, whereas k-limited analyses allow object sensitivity which is a superior calling context abstraction for object-oriented languages. We combine the advantages of both approaches to obtain a context-sensitive analysis that is as precise as k-limited context-strings, but is more efficient to compute. Our key insight is based on a novel abstraction of contexts adapted from CFL-reachability that represents a relation between two calling contexts as a composition of transformations over contexts.
We formulate pointer analysis in an algebraic structure of context transformations, which is a set of functions over calling contexts closed under function composition. We show that the context representation of context-string-based analyses is an explicit enumeration of all input and output values of context transformations. CFL-reachability-based pointer analysis is formulated to use call-strings as contexts, but the context transformations concept can be applied to any context abstraction used in k-limited analyses, including object and type sensitive analysis. The result is a more efficient algorithm for computing context-sensitive results for a wide variety of context configurations.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Rei</first_name>
          <last_name>Thiessen</last_name>
          <affiliation>University of Waterloo</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Ondřej</first_name>
          <last_name>Lhoták</last_name>
          <affiliation>University of Waterloo, Canada</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://plg.uwaterloo.ca/~olhotak/</homepage_url>
          <picture_url>http://pldi17.sigplan.org/getProfileImage/ondrejlhotak/5eff0fbe-ccf6-4901-88b8-25b68df221a3/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>65baff4f-0f3f-4844-9f16-d5dc264c80de</slot_id>
      <title>Static Deadlock Detection for Asynchronous C# Programs</title>
      <room>PLDI-MainTrack-B</room>
      <date>2017/06/19</date>
      <start_time>17:25</start_time>
      <end_time>17:50</end_time>
      <description>Asynchronous programming is a standard approach for designing responsive applications. Modern languages such as C# provide primitives for the disciplined use of asynchrony. In spite of this, programs can deadlock because of incorrect use of blocking operations along with non-blocking (asynchronous) operations. While developers already know about this problem, there is no automated technique to detect deadlocks in asynchronous C# programs.
We present DeadWait, the first deadlock detection technique for asynchronous C# programs. We formulate necessary conditions for a deadlock to occur in a program using a novel program representation that captures the asynchronous control flow semantics of C#. We design a static analysis to construct the program representation and identify deadlocks.
Using DeadWait, we found 42 previously unknown deadlocks in 7 asynchronous C# libraries. We reported the deadlocks to the library developers. They have confirmed and fixed 40 of them. Thus, DeadWait is a useful technique to find real deadlocks in asynchronous C# programs.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Anirudh</first_name>
          <last_name>Santhiar</last_name>
          <affiliation>Indian Institute of Science</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Aditya</first_name>
          <last_name>Kanade</last_name>
          <affiliation>Indian Institute of Science, Bangalore</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.iisc-seal.net/kanade</homepage_url>
          <picture_url>http://pldi17.sigplan.org/getProfileImage/adityakanade/b668e6d6-c7cd-4f92-aa27-d5fc7a5a29c3/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>74a49783-0a3f-4eee-9165-932063a788b5</slot_id>
      <title>Compositional Recurrence Analysis Revisited</title>
      <room>PLDI-MainTrack-B</room>
      <date>2017/06/19</date>
      <start_time>16:10</start_time>
      <end_time>16:35</end_time>
      <description>Compositional recurrence analysis (CRA) is a static-analysis method based on a combination of symbolic analysis and abstract interpretation. This paper addresses the problem of creating a context-sensitive interprocedural version of CRA that handles recursive procedures. The problem is non-trivial because there is an “impedance mismatch” between CRA, which relies on analysis techniques based on regular languages (i.e., Tarjan’s path-expression method), and the context-free-language underpinnings of context-sensitive analysis.
We show how to address this impedance mismatch by augmenting the CRA abstract domain with additional operations. We call the resulting algorithm Interprocedural CRA (ICRA). Our experiments with ICRA show that it has broad overall strength, compared with several state-of-the-art software model checkers.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Zachary</first_name>
          <last_name>Kincaid</last_name>
          <affiliation>Princeton University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.princeton.edu/~zkincaid</homepage_url>
          <picture_url>http://pldi17.sigplan.org/getProfileImage/zacharykincaid/a26b486e-94a5-45f1-a8b3-9a2221495ff7/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Jason</first_name>
          <last_name>Breck</last_name>
          <affiliation>University of Wisconsin-Madison</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Ashkan Forouhi</first_name>
          <last_name>Boroujeni</last_name>
          <affiliation>University of Wisconsin-Madison</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Thomas</first_name>
          <last_name>Reps</last_name>
          <affiliation>University of Wisconsin - Madison and Grammatech Inc.</affiliation>
          <bio>Thomas W. Reps is the J. Barkley Rosser Professor &amp;amp; Rajiv and Ritu Batra Chair in the Computer Sciences Department of the University of Wisconsin, which he joined in 1985. Reps is the author or co-author of four books and more than one hundred seventy-five papers describing his research (see http://pages.cs.wisc.edu/~reps/). His work has concerned a wide variety of topics, including program slicing, dataflow analysis, pointer analysis, model checking, computer security, code instrumentation, language-based program-development environments, the use of program profiling in software testing, software renovation, incremental algorithms, and attribute grammars.
His collaboration with Professor Tim Teitelbaum at Cornell University from 1978 to 1985 led to the creation of two systems—the Cornell Program Synthesizer and the Synthesizer Generator—that explored how to build interactive programming tools that incorporate knowledge about the programming language being supported. The systems that they created were similar to modern program-development environments, such as Microsoft Visual Studio and Eclipse, but pre-dated them by more than two decades. Reps is President of GrammaTech, Inc., which he and Teitelbaum founded in 1988 to commercialize this work.
At Wisconsin, Professor Reps and collaborator Professor Susan Horwitz carried out many investigations of program slicing and its applications in software engineering. Reps’s most recent work concerns program analysis, computer security, and software model checking.
In 1996, Reps served as a consultant to DARPA to help them plan a project aimed at reducing the impact of the Year 2000 Problem on the U.S. Department of Defense. In 2003, he served on the F/A-22 Avionics Advisory Team, which provided advice to the U.S. Department of Defense about problems uncovered during integration testing of the plane’s avionics software.
Professor Reps received his Ph.D. in Computer Science from Cornell University in 1982. His Ph.D. dissertation won the 1983 ACM Doctoral Dissertation Award.
Reps’s 1988 paper on interprocedural slicing, with Susan Horwitz and his then-student David Binkley, was selected as one of the 50 most influential papers from the ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI), 1979-99. According to Google Scholar, the 1988 paper and the subsequent journal version have received over 1,780 citations.
His 2004 paper about analysis of assembly code, with his student Gogul Balakrishnan, received the ETAPS Best-Paper Award for 2004 from the European Association for Programming Languages and Systems (EAPLS). His 2008 paper about a system for generating static analyzers for machine instructions, with his student Junghee Lim, received the ETAPS Best-Paper Award for 2008 from EAPLS. In 2010, his 1984 paper “The Synthesizer Generator,” with Tim Teitelbaum, received an ACM SIGSOFT Retrospective Impact Paper Award. In 2011, his 1994 paper “Speeding up slicing,” with Susan Horwitz, Mooly Sagiv, and Genevieve Rosay, also received an ACM SIGSOFT Retrospective Impact Paper Award.
Four of his students, Gogul Balakrishnan, Akash Lal, Junghee Lim, and Aditya Thakur, have been recipients of the Outstanding Graduate Student Research Award given by the University of Wisconsin Computer Sciences Department. Akash Lal was also a co-recipient of the 2009 SIGPLAN Outstanding Doctoral Dissertation Award, and he was named as one of the 18 awardees selected for the 2011 India TR-35 list (top innovators under 35).
Reps has also been the recipient of an NSF Presidential Young Investigator Award (1986), a Packard Fellowship (1988), a Humboldt Research Award (2000), and a Guggenheim Fellowship (2000). He is also an ACM Fellow (2005). In 2013, Reps was elected a foreign member of Academia Europaea.
Reps has held visiting positions at the Institut National de Recherche en Informatique et en Automatique (INRIA) in Rocquencourt, France (1982-83), the University of Copenhagen, Denmark (1993-94), the Consiglio Nazionale delle Ricerche in Pisa, Italy (2000-2001), and the University Paris Diderot—Paris 7 (2007-2008).</bio>
          <homepage_url>http://pages.cs.wisc.edu/~reps/</homepage_url>
          <picture_url>http://pldi17.sigplan.org/getProfileImage/thomasreps/bc5323a6-d318-42c9-a136-d3252ecda280/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>b25c3c14-f7c3-4e08-bc48-c9b2f770770e</subevent_id>
    <title>Research Papers: Learning and Probabilistic</title>
    <subevent_type type="regular"/>
    <room>PLDI-MainTrack-A</room>
    <date>2017/06/19</date>
    <url>http://pldi17.sigplan.org/track/pldi-2017-papers</url>
    <url_link_display>Research Papers</url_link_display>
    <tracks>
      <track>Research Papers</track>
    </tracks>
    <timeslot>
      <slot_id>1b3c0238-1cfa-437a-a3ae-b39de3f3a606</slot_id>
      <title>Similarity of Binaries through re-Optimization</title>
      <room>PLDI-MainTrack-A</room>
      <date>2017/06/19</date>
      <start_time>11:15</start_time>
      <end_time>11:40</end_time>
      <description>We present a scalable approach for establishing similaritybetween stripped binaries (with no debug information). The main challenge is to establish similarity even when the code has been compiled using different compilers, with different optimization levels, or has been modified. Overcoming this challenge, while avoiding false positives, is invaluable to the process of reverse engineering, locating vulnerable code, and identifying \ac{IP} theft and plagiarism.
Finding similarity in binaries presents a natural tradeoff between the scalability of the approach, and its ability to identify semantic similarity which is crucial for precision. Previous techniques have been mostly heavily biased towards one of the ends of this spectrum. We present a technique that is scalable, precise and architecture-agnostic. It works by decomposing binary procedures to comparable segments, lifting segments to a \emph{canonical, optimized form} which allows for efficient semantic comparison, and then focusing comparisons on segments that are \emph{statistically significant} for establishing similarity.
We have implemented our technique in a tool called GitZ and performed an extensive evaluation. We show that GitZ is able to perform millions of comparisons efficiently, and find similarity with high accuracy.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Yaniv</first_name>
          <last_name>David</last_name>
          <affiliation>Technion</affiliation>
          <bio>undefined</bio>
          <picture_url>http://pldi17.sigplan.org/getProfileImage/yanivdavid/83ffa94a-79ef-4627-b213-9d48cfeac290/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Nimrod</first_name>
          <last_name>Partush</last_name>
          <affiliation>Technion</affiliation>
          <bio>undefined</bio>
          <picture_url>http://pldi17.sigplan.org/getProfileImage/nimrodpartush/c2139468-82b5-4897-a487-4db7cb7bb3c6/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Eran</first_name>
          <last_name>Yahav</last_name>
          <affiliation>Technion</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.technion.ac.il/~yahave/</homepage_url>
          <picture_url>http://pldi17.sigplan.org/getProfileImage/eranyahav/e77d8b4b-d267-4659-969c-6542a0d385b3/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>6f675b87-59c5-4c75-9f05-3f793a2b3a2b</slot_id>
      <title>Compiling Markov Chain Monte Carlo Algorithms for Probabilistic Modeling</title>
      <room>PLDI-MainTrack-A</room>
      <date>2017/06/19</date>
      <start_time>12:05</start_time>
      <end_time>12:30</end_time>
      <description>The job of a typical compiler is to convert a program written in some source language into assembly code. In contrast, a probabilistic programming language (PPL) compiler converts a specification of a probabilistic model into a statistical inference algorithm. Hence, the requirements of such a compiler are markedly different from those for a conventional one. In this paper, we describe a compiler for a restricted PPL that expresses Bayesian networks. In particular, we present a sequence of intermediate languages (ILs) that guide a compiler in gradually and successively refining a declarative specification of a probabilistic model into an executable Markov Chain Monte Carlo (MCMC) inference algorithm. The compilation strategy produces \emph{composable} MCMC algorithms for execution on a CPU or GPU.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Daniel</first_name>
          <last_name>Huang</last_name>
          <affiliation>Harvard University</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Jean-Baptiste</first_name>
          <last_name>Tristan</last_name>
          <affiliation>Oracle Labs</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Greg</first_name>
          <last_name>Morrisett</last_name>
          <affiliation>Cornell University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.cornell.edu/~jgm/</homepage_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>94d2137d-490a-4e9b-bd70-9ca534f0c2dd</slot_id>
      <title>Synthesizing Program Input Grammars</title>
      <room>PLDI-MainTrack-A</room>
      <date>2017/06/19</date>
      <start_time>11:40</start_time>
      <end_time>12:05</end_time>
      <description>We present an algorithm for synthesizing a context-free grammar encoding the language of valid program inputs from a set of input examples and blackbox access to the program. Our algorithm addresses shortcomings of existing grammar inference algorithms, which both severely overgeneralize and are prohibitively slow. Our implementation, GLADE, leverages the grammar synthesized by our algorithm to fuzz test programs with structured inputs. We show that GLADE substantially increases the incremental coverage on valid inputs compared to two baseline fuzzers.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Osbert</first_name>
          <last_name>Bastani</last_name>
          <affiliation>Stanford University</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Rahul</first_name>
          <last_name>Sharma</last_name>
          <affiliation>Microsoft Research</affiliation>
          <bio>Rahul Sharma is a researcher at Microsoft Research India. He received a Ph.D. in Computer Science from Stanford University, where he was advised by Prof. Alex Aiken. Before Stanford, he graduated with a B.Tech. from IIT Delhi. His research interests include program analysis, compilers, machine learning, and secure cloud computing.</bio>
          <homepage_url>http://cs.stanford.edu/people/sharmar</homepage_url>
          <picture_url>http://pldi17.sigplan.org/getProfileImage/rahulsharma/6d60eca8-356f-4141-af5d-4c6af0fadcd8/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Alex</first_name>
          <last_name>Aiken</last_name>
          <affiliation>Stanford University</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Percy</first_name>
          <last_name>Liang</last_name>
          <affiliation>Stanford University</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>d5fe544d-4176-42cf-810c-b8da66f5468f</slot_id>
      <title>DemoMatch: API Discovery from Demonstrations</title>
      <room>PLDI-MainTrack-A</room>
      <date>2017/06/19</date>
      <start_time>10:50</start_time>
      <end_time>11:15</end_time>
      <description>We introduce DemoMatch, a tool for API discovery that allows the user to discover how to implement functionality using a software framework by demonstrating the functionality in existing applications built with the same framework. \DemoMatch matches the demonstrations against a database of execution traces called \Semeru and generates code snippets explaining how to use the functionality. We evaluated \DemoMatch on several case studies involving Java Swing and Eclipse RCP.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Kuat</first_name>
          <last_name>Yessenov</last_name>
          <affiliation>MIT</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Ivan</first_name>
          <last_name>Kuraj</last_name>
          <affiliation>MIT CSAIL, USA</affiliation>
          <bio>undefined</bio>
          <picture_url>http://pldi17.sigplan.org/getProfileImage/ivankuraj/6a79beec-4cad-43a2-8ab0-2d344476a0dc/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Armando</first_name>
          <last_name>Solar-Lezama</last_name>
          <affiliation>MIT CSAIL</affiliation>
          <bio>undefined</bio>
          <picture_url>http://pldi17.sigplan.org/getProfileImage/armandosolarlezama/7befe52d-6968-4786-9841-408800f80c71/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>73610987-c5ab-42ae-93c6-b7ecbfe6c383</subevent_id>
    <title>Research Papers: Concurrency Analysis</title>
    <subevent_type type="regular"/>
    <room>PLDI-MainTrack-B</room>
    <date>2017/06/19</date>
    <url>http://pldi17.sigplan.org/track/pldi-2017-papers</url>
    <url_link_display>Research Papers</url_link_display>
    <tracks>
      <track>Research Papers</track>
    </tracks>
    <timeslot>
      <slot_id>90a5b2bd-749f-42b3-b850-ad0e8f4c5712</slot_id>
      <title>Systematic Black-Box Analysis of Collaborative Web Applications</title>
      <room>PLDI-MainTrack-B</room>
      <date>2017/06/19</date>
      <start_time>15:15</start_time>
      <end_time>15:40</end_time>
      <description>Web applications, such as collaborative editors that allow multiple clients to concurrently interact on a shared resource, are difficult to implement correctly. Existing techniques for analyzing concurrent software do not scale to such complex systems or do not consider multiple interacting clients. This paper presents Simian, the first fully automated technique for systematically analyzing multi-client web applications.
Naively exploring all possible interactions between a set of clients of such applications is practically infeasible. Simian obtains scalability for real-world applications by using a two-phase black-box approach. The application code remains unknown to the analysis and is first explored systematically using a single client to infer potential conflicts between client events triggered in a specific context. The second phase synthesizes multi-client interactions targeted at triggering misbehavior that may result from the potential conflicts, and reports an inconsistency if the clients do not converge to a consistent state.
We evaluate the analysis on three widely used systems, Google Docs, Firepad, and ownCloud Documents, where it reports a variety of inconsistencies, such as incorrect formatting and misplaced text fragments. Moreover, we find that the two-phase approach runs 10x faster compared to exhaustive exploration, making systematic analysis practically applicable.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Marina</first_name>
          <last_name>Billes</last_name>
          <affiliation>TU Darmstadt</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Anders</first_name>
          <last_name>Møller</last_name>
          <affiliation>Aarhus University</affiliation>
          <bio>Professor at Department of Computer Science, Aarhus University, Denmark</bio>
          <homepage_url>https://cs.au.dk/~amoeller/</homepage_url>
          <picture_url>http://pldi17.sigplan.org/getProfileImage/andersmoller/a6b971e9-27d8-44ed-84d2-5ce2d53ff5e4/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Michael</first_name>
          <last_name>Pradel</last_name>
          <affiliation>TU Darmstadt</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://mp.binaervarianz.de/</homepage_url>
          <picture_url>http://pldi17.sigplan.org/getProfileImage/michaelpradel/06ef7ed7-0982-404f-8261-5188acacd15f/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>b4f22a51-5cd4-4dee-909d-c61bfcf72ad2</slot_id>
      <title>BigFoot: Static Check Placement for Dynamic Race Detection</title>
      <room>PLDI-MainTrack-B</room>
      <date>2017/06/19</date>
      <start_time>14:25</start_time>
      <end_time>14:50</end_time>
      <description>Precise dynamic race detectors provide strong correctness guarantees but have high overheads because they generally keep analysis state in a separate shadow location for each heap memory location, and they check (and potentially update) the corresponding shadow location on each heap access. The BigFoot dynamic race detector uses a combination of static and dynamic analysis techniques to coalesce checks and compress shadow locations. With BigFoot, multiple accesses to an object or array often induce a single coalesced check that manipulates a single compressed shadow location, resulting in a performance improvement over FastTrack of 60% with no loss of precision.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Dustin</first_name>
          <last_name>Rhodes</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Cormac</first_name>
          <last_name>Flanagan</last_name>
          <affiliation>University of California, Santa Cruz</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://users.soe.ucsc.edu/~cormac/</homepage_url>
          <picture_url>http://pldi17.sigplan.org/getProfileImage/cormacflanagan/fd454a8e-4230-4fa5-a4da-1d16a1027de3/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Stephen</first_name>
          <last_name>Freund</last_name>
          <affiliation>Williams College</affiliation>
          <bio>undefined</bio>
          <picture_url>http://pldi17.sigplan.org/getProfileImage/stephenfreund/0b468f46-1f87-41c4-bcff-4321da9869c2/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>cb8e38e7-e05e-499a-84bf-a584263dd643</slot_id>
      <title>Dynamic Race Prediction in Linear Time</title>
      <room>PLDI-MainTrack-B</room>
      <date>2017/06/19</date>
      <start_time>14:50</start_time>
      <end_time>15:15</end_time>
      <description>Writing reliable concurrent software remains a huge challenge for today’s programmers. Programmers rarely reason about their code by explicitly considering different possible interleavings of its execution. We consider the problem of detecting data races from individual executions in a sound manner. The classical approach to solving this problem has been to use Lamport’s happens-before (HB) relation. Until now HB remains the only approach that runs in linear time. Previous efforts in improving over HB such as causally-precedes (CP) and maximal causal models fall short due to the fact they are not implementable efficiently and hence have to compromise on their race detecting ability by limiting their techniques to bounded sized fragments of the execution. We present a new relation weak-causally-precedes (WCP) that is provably better than CP in terms of being able to detect more races. WCP is also sound. Moreover it admits a linear time algorithm which works on the entire execution without having to fragment it.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Dileep</first_name>
          <last_name>Kini</last_name>
          <affiliation>University of Illinois at Urbana-Champaign</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Umang</first_name>
          <last_name>Mathur</last_name>
          <affiliation>University of Illinois at Urbana-Champaign</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://umathur3.web.engr.illinois.edu</homepage_url>
          <picture_url>http://pldi17.sigplan.org/getProfileImage/umangmathur/3f83afaf-6ef3-41c4-9599-b35a06186d73/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Mahesh</first_name>
          <last_name>Viswanathan</last_name>
          <affiliation>University of Illinois at Urbana-Champaign</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>f43bc494-069d-4143-8793-c71a76cb0f2a</slot_id>
      <title>BARRACUDA: Binary-level Analysis of Runtime RAces in CUDA programs</title>
      <room>PLDI-MainTrack-B</room>
      <date>2017/06/19</date>
      <start_time>14:00</start_time>
      <end_time>14:25</end_time>
      <description>GPU programming models enable and encourage massively parallel programming with over a million threads, requiring extreme parallelism to achieve good performance. Massive parallelism brings significant correctness challenges by increasing the possibility for bugs as the number of thread interleavings balloons. Conventional dynamic safety analyses struggle to run at this scale.
We present Barracuda, a data race detector for GPU programs written in Nvidia’s CUDA language. Barracuda handles a wider range of parallelism constructs than previous work, including branch operations, low-level atomics and memory fences, which allows Barracuda to detect new classes of races. Barracuda operates at the binary level for increased compatibility with existing code, leveraging a new binary instrumentation framework that is extensible to other dynamic analyses. Barracuda incorporates a number of novel optimizations that are crucial for scaling data race detection to over a million threads.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Ariel</first_name>
          <last_name>Eizenberg</last_name>
          <affiliation>University of Pennsylvania</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Yuanfeng</first_name>
          <last_name>Peng</last_name>
          <affiliation>University of Pennsylvania</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Toma</first_name>
          <last_name>Pigli</last_name>
          <affiliation>University of Pennsylvania</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>William</first_name>
          <last_name>Mansky</last_name>
          <affiliation>University of Pennsylvania</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Joseph</first_name>
          <last_name>Devietti</last_name>
          <affiliation>University of Pennsylvania</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://cis.upenn.edu/~devietti/</homepage_url>
          <picture_url>http://pldi17.sigplan.org/getProfileImage/josephdevietti/62850451-b71a-48b2-8b1b-fad646d36052/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>13e8e756-5054-46c5-b98a-954b65e952ec</subevent_id>
    <title>Research Papers: Functional Programming and Correctness</title>
    <subevent_type type="regular"/>
    <room>PLDI-MainTrack-B</room>
    <date>2017/06/20</date>
    <url>http://pldi17.sigplan.org/track/pldi-2017-papers</url>
    <url_link_display>Research Papers</url_link_display>
    <tracks>
      <track>Research Papers</track>
    </tracks>
    <timeslot>
      <slot_id>4c9f114a-8999-4991-9953-336ffa22fe0c</slot_id>
      <title>FunTAL: Reasonably Mixing a Functional Language with Assembly</title>
      <room>PLDI-MainTrack-B</room>
      <date>2017/06/20</date>
      <start_time>14:25</start_time>
      <end_time>14:50</end_time>
      <description>We present FunTAL, the first multi-language system to formalize safe interoperability between a high-level functional language and low-level assembly code while supporting compositional reasoning about the mix. A central challenge in developing such a multi-language is how to bridge the gap between assembly, which is staged into calls to continuations, and high-level code, where subterms return a result. We present a compositional stack-based typed assembly language that supports components, comprised of one or more basic blocks, that may be embedded in high-level contexts. We also present a logical relation for FunTAL that supports reasoning about equivalence of high-level components and their assembly replacements, mixed-language programs with callbacks between languages, and assembly components comprised of different numbers of basic blocks.
This work is a first step towards multi-language formalisms that (1) allow developers to replace high-level components with performant low-level implementations while reasoning about safety and correctness of the replacement; (2) can be used to specify compiler correctness theorems that permit compiled components to be linked with low-level code compiled from other languages (as proposed by Perconti and Ahmed [1, 19]); and (3) can be used to verify just-in-time compilers which replace portions of high-level code with equivalent assembly, inserting callbacks back to high-level code.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Daniel</first_name>
          <last_name>Patterson</last_name>
          <affiliation>Northeastern University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://dbp.io</homepage_url>
          <picture_url>http://pldi17.sigplan.org/getProfileImage/danielpatterson/5b299b7f-7940-4cf3-a798-2999ac0913c4/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Jamie</first_name>
          <last_name>Perconti</last_name>
          <affiliation>Northeastern University</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Christos</first_name>
          <last_name>Dimoulas</last_name>
          <affiliation>Harvard University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://people.seas.harvard.edu/~chrdimo/</homepage_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Amal</first_name>
          <last_name>Ahmed</last_name>
          <affiliation>Northeastern University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.ccs.neu.edu/home/amal/</homepage_url>
          <picture_url>http://pldi17.sigplan.org/getProfileImage/amalahmed/301fd92b-d4ae-4998-8f6b-82cf081da653/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>58445907-1ddf-42ff-a7f8-b726aaaf1f6b</slot_id>
      <title>Levity Polymorphism</title>
      <room>PLDI-MainTrack-B</room>
      <date>2017/06/20</date>
      <start_time>15:15</start_time>
      <end_time>15:40</end_time>
      <description>Parametric polymorphism is one of the lynchpins of modern typed programming. A function that can work seamlessly over a variety of types simplifies code, helps to avoid errors introduced through duplication, and and is easy to maintain. However, polymorphism comes at a very real cost, one that each language with support for polymorphism has paid in different ways. This paper describes this cost, proposes a theoretically simple way to reason about the cost—that kinds, not types, are calling conventions—and details one approach to dealing with polymorphism that works in the context of a language, Haskell, that prizes both efficiency and a principled type system.
This approach, levity polymorphism, allows the user to abstract over calling conventions; we detail and verify restrictions that are necessary in order to compile levity-polymorphic functions. Levity polymorphism has opened up surprising new opportunities for library design in Haskell.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Richard A.</first_name>
          <last_name>Eisenberg</last_name>
          <affiliation>Bryn Mawr College</affiliation>
          <bio>Assistant Professor at Bryn Mawr College. I completed my PhD in 2016 at University of Pennsylvania working under Stephanie Weirich; my dissertation topic was the integration of dependent types into the Haskell programming language. I am a regular contributor to the Glasgow Haskell Compiler (GHC).</bio>
          <homepage_url>http://cs.brynmawr.edu/~rae</homepage_url>
          <picture_url>http://pldi17.sigplan.org/getProfileImage/richardeisenberg/576e2511-ae2a-4c2a-93b0-b8981243251c/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Simon</first_name>
          <last_name>Peyton Jones</last_name>
          <affiliation>Microsoft Research, Cambridge</affiliation>
          <bio>Simon Peyton Jones, MA, MBCS, CEng, graduated from Trinity College Cambridge in 1980. After two years in industry, he spent seven years as a lecturer at University College London, and nine years as a professor at Glasgow University, before moving to Microsoft Research (Cambridge) in 1998. His main research interest is in functional programming languages, their implementation, and their application. He has led a succession of research projects focused around the design and implementation of production-quality functional-language systems for both uniprocessors and parallel machines. He was a key contributor to the design of the now-standard functional language Haskell, and is the lead designer of the widely-used Glasgow Haskell Compiler (GHC). He has written two textbooks about the implementation of functional languages.
More generally, he is interested in language design, rich type systems, software component architectures, compiler technology, code generation, runtime systems, virtual machines, and garbage collection. He is particularly motivated by direct use of principled theory to practical language design and implementation – that’s one reason he loves functional programming so much.</bio>
          <picture_url>http://pldi17.sigplan.org/getProfileImage/simonpaytonjones/61daea4a-3a8b-4363-925e-b38fe6eac90d/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>59a1275d-ff9a-46e7-b32c-eda386d51dd7</slot_id>
      <title>Compiling without continuations</title>
      <room>PLDI-MainTrack-B</room>
      <date>2017/06/20</date>
      <start_time>14:00</start_time>
      <end_time>14:25</end_time>
      <description>Many fields of study in compilers give rise to the concept of a join point—a place where different execution paths come together. While they have often been treated by representing them as functions or continuations, we believe it is time to study them in their own right. We show that adding them to a direct-style functional intermediate language allows new op- timizations to be performed, including a functional version of loop-invariant code motion. Finally, we report on recent work on the Glasgow Haskell Compiler which added join points to the Core language.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Luke</first_name>
          <last_name>Maurer</last_name>
          <affiliation>University of Oregon, USA</affiliation>
          <bio>Ph.D. student at the University of Oregon Department of Computer &amp;amp; Information Science. Currently working on my dissertation on intermediate languages in optimizing compilers, particularly GHC and other functional languages. Contributed to GHC 8.2.1 by adding join points to its Core intermediate language. Other research interests include parametricity, proof assistants, and category theory.</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Paul</first_name>
          <last_name>Downen</last_name>
          <affiliation>University of Oregon, USA</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Zena M.</first_name>
          <last_name>Ariola</last_name>
          <affiliation>University of Oregon, USA</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Simon</first_name>
          <last_name>Peyton Jones</last_name>
          <affiliation>Microsoft Research, Cambridge</affiliation>
          <bio>Simon Peyton Jones, MA, MBCS, CEng, graduated from Trinity College Cambridge in 1980. After two years in industry, he spent seven years as a lecturer at University College London, and nine years as a professor at Glasgow University, before moving to Microsoft Research (Cambridge) in 1998. His main research interest is in functional programming languages, their implementation, and their application. He has led a succession of research projects focused around the design and implementation of production-quality functional-language systems for both uniprocessors and parallel machines. He was a key contributor to the design of the now-standard functional language Haskell, and is the lead designer of the widely-used Glasgow Haskell Compiler (GHC). He has written two textbooks about the implementation of functional languages.
More generally, he is interested in language design, rich type systems, software component architectures, compiler technology, code generation, runtime systems, virtual machines, and garbage collection. He is particularly motivated by direct use of principled theory to practical language design and implementation – that’s one reason he loves functional programming so much.</bio>
          <picture_url>http://pldi17.sigplan.org/getProfileImage/simonpaytonjones/61daea4a-3a8b-4363-925e-b38fe6eac90d/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>81610db3-a8b4-41f6-9aa5-66c415e5c36c</slot_id>
      <title>HoTTSQL: Proving Query Rewrites with Univalent SQL Semantics</title>
      <room>PLDI-MainTrack-B</room>
      <date>2017/06/20</date>
      <start_time>14:50</start_time>
      <end_time>15:15</end_time>
      <description>Every database system contains a query optimizer that performs query rewrites. Unfortunately, developing query optimizers remains a highly challenging task. Part of the challenges comes from the intricacies and rich features of query languages, which makes reasoning about rewrite rules difficult. In this paper, we propose a machine-checkable denotational semantics for SQL, the de facto language for relational database, for rigorously validating rewrite rules. Unlike previously proposed semantics that are either non-mechanized or only cover a small amount of SQL language features, our semantics covers all major features of SQL, including bags, correlated subqueries, aggregation, and indexes. Our mechanized semantics, called HoTT SQL, is based on K-Relations and homotopy type theory, where we denote relations as mathematical functions from tuples to univalent types. We have implemented HoTTSQL in Coq, which takes only fewer than 300 lines of code and have proved a wide range of SQL rewrite rules, including those from database research literature (e.g., magic set rewrites) and real-world query optimizers (e.g., subquery elimination). Several of these rewrite rules have never been previously proven correct. In addition, while query equivalence is generally undecidable, we have implemented an automated decision procedure using HoTTSQL for conjunctive queries: a well studied decidable fragment of SQL that encompasses many real-world queries.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Shumo</first_name>
          <last_name>Chu</last_name>
          <affiliation>University of Washington, USA</affiliation>
          <bio>Shumo is a 4th year PhD student at Computer Science &amp;amp; Engineering, University of Washington. He interests in applying formal methods to data management and building data systems in a principled way.</bio>
          <homepage_url>http://shumochu.com/</homepage_url>
          <picture_url>http://pldi17.sigplan.org/getProfileImage/shumochu/da171030-a629-449a-951a-08ea17d308f2/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Konstantin</first_name>
          <last_name>Weitz</last_name>
          <affiliation>University of Washington</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://konne.me</homepage_url>
          <picture_url>http://pldi17.sigplan.org/getProfileImage/konstantinweitz/7ca25205-f53e-4659-a16a-511b86ab20f2/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Alvin</first_name>
          <last_name>Cheung</last_name>
          <affiliation>University of Washington</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://homes.cs.washington.edu/~akcheung</homepage_url>
          <picture_url>http://pldi17.sigplan.org/getProfileImage/alvincheung/8a51cd19-a395-45c9-8b2c-b121ff910c62/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Dan</first_name>
          <last_name>Suciu</last_name>
          <affiliation>University of Washington</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>1f616443-d2e7-4634-969c-f729bc121dda</subevent_id>
    <title>Research Papers: Parallelization and Concurrency</title>
    <subevent_type type="regular"/>
    <room>PLDI-MainTrack-A</room>
    <date>2017/06/20</date>
    <url>http://pldi17.sigplan.org/track/pldi-2017-papers</url>
    <url_link_display>Research Papers</url_link_display>
    <tracks>
      <track>Research Papers</track>
    </tracks>
    <timeslot>
      <slot_id>664a342a-5650-40a0-8910-67b67a325e3e</slot_id>
      <title>Futhark: Purely Functional GPU-programming with Nested Parallelism and In-place Array Updates</title>
      <room>PLDI-MainTrack-A</room>
      <date>2017/06/20</date>
      <start_time>14:25</start_time>
      <end_time>14:50</end_time>
      <description>We give a performance analysis of the purely functional ar- ray language Futhark and its GPU-targeting optimising com- piler on 16 benchmarks, and present several features that enable performance comparable with hand-written code: (i) a simple type system for in-place updates that ensures referential transparency and supports equational reasoning, (ii) several bulk-parallel operators, which encode strength- reduction invariants, along with their fusion rules, and (iii) a flattening transformation aimed at enhancing the degree of parallelism, which builds on loop interchange and dis- tribution but uses higher-order reasoning rather than array- dependence analysis, and preserves the opportunities for fur- ther locality-of-reference optimizations.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Troels</first_name>
          <last_name>Henriksen</last_name>
          <affiliation>DIKU, University of Copenhagen</affiliation>
          <bio>I try to make functional programs to really, really fast. It’s not easy.</bio>
          <homepage_url>http://sigkill.dk</homepage_url>
          <picture_url>http://pldi17.sigplan.org/getProfileImage/troelshenriksen/cc6f9601-4f83-467d-8063-85f9b13b9f6f/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Niels G. W.</first_name>
          <last_name>Serup</last_name>
          <affiliation>DIKU, University of Copenhagen</affiliation>
          <bio>I try to make things work.</bio>
          <homepage_url>http://metanohi.name/</homepage_url>
          <picture_url>http://pldi17.sigplan.org/getProfileImage/nielsgwserup/bf2ffef6-0dc4-4355-8db8-068174764758/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Martin</first_name>
          <last_name>Elsman</last_name>
          <affiliation>Department of Computer Science, University of Copenhagen</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.elsman.com</homepage_url>
          <picture_url>http://pldi17.sigplan.org/getProfileImage/martinelsman/1158f40b-68de-48a0-939e-89f98f6b4f18/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Fritz</first_name>
          <last_name>Henglein</last_name>
          <affiliation>DIKU, Denmark</affiliation>
          <bio>undefined</bio>
          <picture_url>http://pldi17.sigplan.org/getProfileImage/fritzhenglein/4984918d-01be-497a-b867-fbf1a77100e8/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Cosmin</first_name>
          <last_name>Oancea</last_name>
          <affiliation>DIKU, University of Copenhagen</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.diku.dk/~zgh600/</homepage_url>
          <picture_url>http://pldi17.sigplan.org/getProfileImage/cosminoancea/40450761-b155-4a17-9b03-9100541603b1/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>8e7d12f5-1ab4-407b-8d9b-3cb6d297e292</slot_id>
      <title>Gradual Synthesis for Static Parallelization</title>
      <room>PLDI-MainTrack-A</room>
      <date>2017/06/20</date>
      <start_time>14:50</start_time>
      <end_time>15:15</end_time>
      <description>Parallelizing of software improves its effectiveness and productivity. To guarantee correctness, each new parallel version of the former code must be formally verified to be equivalent to the serial version. We present a novel approach, called GRASSP, that automatically synthesizes parallel versions of software by treating the given serial versions as specifications. GRASSP statically augments an existing serial program with additional functionality to decompose data dependencies in loop iterations, to compute partial results, and to recompose them. In contrast to other parallelizers, GRASSP gradually considers several parallelization scenarios and certifies the results using Horn-based invariant synthesis. For several classes of single-pass array-processing programs, we show that such static parallelization can be performed efficiently. The C++ translations of the GRASSP solutions sped performance by up to 5X relative to serial code on an 8-thread machine and Hadoop translations by up to 10X on a 10-node Amazon EMR cluster.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Grigory</first_name>
          <last_name>Fedyukovich</last_name>
          <affiliation>UW CSE</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://homes.cs.washington.edu/~grigory</homepage_url>
          <picture_url>http://pldi17.sigplan.org/getProfileImage/grigoryfedyukovich/902a9cea-9078-42f4-9fb4-19a433865738/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Maaz Bin Safeer</first_name>
          <last_name>Ahmad</last_name>
          <affiliation>UW / CSE</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Rastislav</first_name>
          <last_name>Bodik</last_name>
          <affiliation>University of Washington</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.berkeley.edu/~bodik</homepage_url>
          <picture_url>http://pldi17.sigplan.org/getProfileImage/rastislavbodik/ae16ae8e-9d00-41c4-9067-0c37da65dde7/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>c314d075-29d5-4a40-8330-cc38f9c438af</slot_id>
      <title>Verifying invariants of lock-free data structures with rely-guarantee and refinement type</title>
      <room>PLDI-MainTrack-A</room>
      <date>2017/06/20</date>
      <start_time>15:15</start_time>
      <end_time>15:40</end_time>
      <description>Verifying invariants of fine-grained concurrent data structures is challenging because interference from other threads may occur at any time. We propose a new way of proving invariants of fine-grained concurrent data structures: applying rely-guarantee reasoning to references in the concurrent setting. Rely-guarantee applied to references can verify bounds on thread interference, without requiring a whole program to be verified. This paper provides three new results. First, it provides a new approach to preserving invariants and restricting usage of concurrent data structures. Our approach targets a space between simple type systems and modern concurrent program logics, offering an intermediate point between unverified code and full verification. Furthermore, it avoids sealing concurrent data structure implementations, and can interact safely with unverified imperative code. Second, we demonstrate the approach’s broad applicability through a series of case studies, using two implementations: an axiomatic COQ DSL and a library for Liquid Haskell. Third, these two implementations allow us to compare and contrast verifications by interactive proof (COQ) and a weaker form that can be expressed using SMT-discharged dependent refinement types (Liquid Haskell).</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Colin</first_name>
          <last_name>Gordon</last_name>
          <affiliation>Drexel University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://cs.drexel.edu/~csgordon/</homepage_url>
          <picture_url>http://pldi17.sigplan.org/getProfileImage/colingordon/d990db47-1ece-4016-bce5-b764428bd0ee/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Michael D.</first_name>
          <last_name>Ernst</last_name>
          <affiliation>University of Washington</affiliation>
          <bio>Michael D. Ernst is a Professor in the Computer Science &amp;amp; Engineering department at the University of Washington.
Ernst’s research aims to make software more reliable, more secure, and easier (and more fun!) to produce. His primary technical interests are in software engineering, programming languages, type theory, security, program analysis, bug prediction, testing, and verification. Ernst’s research combines strong theoretical foundations with realistic experimentation, with an eye to changing the way that software developers work.
Ernst is an ACM Fellow (2014) and received the inaugural John Backus Award (2009) and the NSF CAREER Award (2002). His research has received an ACM SIGSOFT Impact Paper Award (2013), 8 ACM Distinguished Paper Awards (FSE 2014, ISSTA 2014, ESEC/FSE 2011, ISSTA 2009, ESEC/FSE 2007, ICSE 2007, ICSE 2004, ESEC/FSE 2003), an ECOOP 2011 Best Paper Award, honorable mention in the 2000 ACM doctoral dissertation competition, and other honors. In 2013, Microsoft Academic Search ranked Ernst #2 in the world, in software engineering research contributions over the past 10 years.
Dr. Ernst was previously a tenured professor at MIT, and before that a researcher at Microsoft Research.</bio>
          <homepage_url>http://homes.cs.washington.edu/~mernst/</homepage_url>
          <picture_url>http://pldi17.sigplan.org/getProfileImage/michaeldernst/c4859f6d-6233-416a-bc82-36d41286e201/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Dan</first_name>
          <last_name>Grossman</last_name>
          <affiliation>University of Washington</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://homes.cs.washington.edu/~djg/</homepage_url>
          <picture_url>http://pldi17.sigplan.org/getProfileImage/dangrossman/941e0321-e962-4f03-9027-ba9f0448e7df/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Matthew</first_name>
          <last_name>Parkinson</last_name>
          <affiliation>Microsoft Research, UK</affiliation>
          <bio>undefined</bio>
          <picture_url>http://pldi17.sigplan.org/getProfileImage/matthewparkinson/7039a7e0-dad3-4392-9f54-2f2c04477e71/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>f1a1b48b-e71d-4c2a-afad-027ca70ef98b</slot_id>
      <title>Synthesis of Divide and Conquer Parallelism for Loops</title>
      <room>PLDI-MainTrack-A</room>
      <date>2017/06/20</date>
      <start_time>14:00</start_time>
      <end_time>14:25</end_time>
      <description>This paper focuses on automated synthesis of divide-and-conquer parallelism, which is a common parallel programming skeleton supported by many cross-platform multithreaded libraries. The challenges of producing (manually or automatically) a correct divide-and-conquer parallel program from a given sequential code are two-fold: (1) assuming that individual worker threads execute a code identical to the sequential code, the programmer has to provide the extra code for dividing the tasks and combining the computation results, and (2) sometimes, the sequential code may not be usable as is, and may need to be modified by the programmer. We address both challenges in this paper. We present an automated synthesis technique for the case where no modifications to the sequential code are required, and we propose an algorithm for modifying the sequential code to make it suitable for parallelization when some modification is necessary. The paper presents theoretical results for when this {\em modification} is efficiently possible, and experimental evaluation of the technique and the quality of the produced parallel programs.
(An anonymous extended version including all proofs has been submitted as &amp;quot;Supplementary Material.)</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Azadeh</first_name>
          <last_name>Farzan</last_name>
          <affiliation>University of Toronto</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.toronto.edu/~azadeh/</homepage_url>
          <picture_url>http://pldi17.sigplan.org/getProfileImage/azadehfarzan/f0942c46-887a-4f22-bf78-74fd48f6f0ed/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Victor</first_name>
          <last_name>Nicolet</last_name>
          <affiliation>University of Toronto</affiliation>
          <bio>undefined</bio>
          <picture_url>http://pldi17.sigplan.org/getProfileImage/victornicolet/416e5018-e5de-4c7b-a8bb-61ec7b3279f7/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>f93e2304-2070-4c70-9a48-4f55fad2efc9</subevent_id>
    <title>Research Papers: Verified Computation</title>
    <subevent_type type="regular"/>
    <room>PLDI-MainTrack-B</room>
    <date>2017/06/20</date>
    <url>http://pldi17.sigplan.org/track/pldi-2017-papers</url>
    <url_link_display>Research Papers</url_link_display>
    <tracks>
      <track>Research Papers</track>
    </tracks>
    <timeslot>
      <slot_id>7e0fd915-266e-4a2e-b4e8-bdfbea6de3ee</slot_id>
      <title>A Formally Verified Compiler for Lustre</title>
      <room>PLDI-MainTrack-B</room>
      <date>2017/06/20</date>
      <start_time>16:10</start_time>
      <end_time>16:35</end_time>
      <description>The correct compilation of block diagram languages like Lustre, Scade, and a discrete subset of Simulink is important since they are used to program critical embedded control software. We describe the specification and verification in an Interactive Theorem Prover of a compilation chain that treats the key aspects of Lustre: namely, sampling, nodes, and delays. Building on CompCert, we show that repeated execution of the generated assembly code faithfully implements the dataflow semantics of source programs.
We resolve two key technical challenges. The first is the change from a synchronous dataflow semantics, where programs manipulate streams of values, to an imperative one, where computations manipulate memory sequentially. The second is the verified compilation of an imperative language with encapsulated state to C~code where the state is realized by nested records. We also treat a standard control optimization that eliminates unnecessary conditional statements.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Timothy</first_name>
          <last_name>Bourke</last_name>
          <affiliation>INRIA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.tbrk.org</homepage_url>
          <picture_url>http://pldi17.sigplan.org/getProfileImage/timothybourke/747739f4-e5f1-4d96-957d-a9e98c1ba4f7/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Lélio</first_name>
          <last_name>Brun</last_name>
          <affiliation>ENS/Inria</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.di.ens.fr/~brun/</homepage_url>
          <picture_url>http://pldi17.sigplan.org/getProfileImage/leliobrun/df431723-e486-4606-8c6d-821892ffa593/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Pierre-Evariste</first_name>
          <last_name>Dagand</last_name>
          <affiliation>LIP6/CNRS </affiliation>
          <bio>undefined</bio>
          <homepage_url>https://pages.lip6.fr/Pierre-Evariste.Dagand/#contact</homepage_url>
          <picture_url>http://pldi17.sigplan.org/getProfileImage/pierreevaristedagand/9c64ffc3-c911-4f4b-ba1c-82259f88ac56/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Xavier</first_name>
          <last_name>Leroy</last_name>
          <affiliation>IRNIA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.xavierleroy.com/index.php</homepage_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Marc</first_name>
          <last_name>Pouzet</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Lionel</first_name>
          <last_name>Rieg</last_name>
          <affiliation>Collège de France</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>c2b5df99-56f9-425a-8c99-856f3aa14289</slot_id>
      <title>Flatten and Conquer (A Framework for Efficient Analysis of String Constraints)</title>
      <room>PLDI-MainTrack-B</room>
      <date>2017/06/20</date>
      <start_time>16:35</start_time>
      <end_time>17:00</end_time>
      <description>We describe a uniform and efficient framework for checking the satisfiability of a large class of string constraints. The framework is based on the observation that both satisfiability and unsatisfiability of common constraints can be demonstrated through witnesses with simple patterns. These patterns are captured using {\it flat} automata each of which consists of a sequence of simple loops. We build a Counter-Example Guided Abstraction Refinement (CEGAR) framework which contains both an under- and an over-approximation module. The flow of information between the modules allows to increase the precision in an automatic manner. We have implemented the framework as a tool and performed extensive experimentation that demonstrates both the generality and efficiency of our method.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Parosh</first_name>
          <last_name>Aziz Abdulla</last_name>
          <affiliation>Uppsala University, Sweden</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://user.it.uu.se/~parosh/</homepage_url>
          <picture_url>http://pldi17.sigplan.org/getProfileImage/paroshazizabdulla/342a7738-db1c-42a1-91cc-3b9467086b87/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Mohamed Faouzi</first_name>
          <last_name>Atig</last_name>
          <affiliation>Uppsala University</affiliation>
          <bio>Mohamed Faouzi Atig is an associate senior lecturer at the Department of Information Technology, Uppsala University. Previously, he was a Post-doctoral researcher at Uppsala University from July 2010 to March 2012. He obtained his doctoral degree in Computer Science from the University of Paris Diderot- Paris 7 (France) in 2010. His research interests broadly span model checking, verification of infinite state systems, weak memory models, and automata theory.</bio>
          <homepage_url>http://www.it.uu.se/katalog/mohat117</homepage_url>
          <picture_url>http://pldi17.sigplan.org/getProfileImage/mohamedfaouziatig/5061fc57-1b58-42f4-965d-a1c64ca186dd/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Phi-Diep</first_name>
          <last_name>Bui</last_name>
          <affiliation>Uppsala University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://diepbp.github.io/</homepage_url>
          <picture_url>http://pldi17.sigplan.org/getProfileImage/phidiepbui/04bc8805-8f6c-407b-be9a-d693717be6b3/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Yu-Fang</first_name>
          <last_name>Chen</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Lukas</first_name>
          <last_name>Holik</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Ahmed</first_name>
          <last_name>Rezine</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>7</sort_key>
          <first_name>Philipp</first_name>
          <last_name>Ruemmer</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>90679e3e-983f-430a-93eb-545cc5339e4f</subevent_id>
    <title>Research Papers: Dynamic Analysis and Testing</title>
    <subevent_type type="regular"/>
    <room>PLDI-MainTrack-A</room>
    <date>2017/06/19</date>
    <url>http://pldi17.sigplan.org/track/pldi-2017-papers</url>
    <url_link_display>Research Papers</url_link_display>
    <tracks>
      <track>Research Papers</track>
    </tracks>
    <timeslot>
      <slot_id>4975e101-f759-4555-a6ff-0bfacee709af</slot_id>
      <title>Instruction Punning: Lightweight Instrumentation for x86-64</title>
      <room>PLDI-MainTrack-A</room>
      <date>2017/06/19</date>
      <start_time>16:35</start_time>
      <end_time>17:00</end_time>
      <description>Existing techniques for injecting probes into running applications are limited; they either fail to support probing arbitrary locations, or to support scalable, rapid toggling of probes. We introduce a new technique on x86-64, called instruction punning, which allows scalable probes at any instruction. The key idea is that when we inject a jump instruction, the relative address of the jump serves simultaneously as data and as an instruction sequence. We show that this approach achieves probe invocation overheads of only a few dozen cycles, and probe activation/deactivation costs that are cheaper than a system call, even when all threads in the system are both invoking probes and toggling them.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Buddhika</first_name>
          <last_name>Chamith</last_name>
          <affiliation>Indiana University</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Luke</first_name>
          <last_name>Dalessandro</last_name>
          <affiliation>Indiana University</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Bo Joel</first_name>
          <last_name>Svensson</last_name>
          <affiliation>Chalmers University of Technology, Sweden</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cse.chalmers.se/~joels/</homepage_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Ryan R.</first_name>
          <last_name>Newton</last_name>
          <affiliation>Indiana University</affiliation>
          <bio>From South Florida. Ph.D. 2009 at MIT.</bio>
          <homepage_url>http://cs.indiana.edu/~rrnewton</homepage_url>
          <picture_url>http://pldi17.sigplan.org/getProfileImage/ryanrnewton/4dff7d06-8ca4-46f3-981b-52049bc71c54/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>e1ec1d66-0130-463d-8aef-a38cbfdce899</slot_id>
      <title>Skeletal Program Enumeration for Rigorous Compiler Testing</title>
      <room>PLDI-MainTrack-A</room>
      <date>2017/06/19</date>
      <start_time>17:25</start_time>
      <end_time>17:50</end_time>
      <description>A program can be viewed as a syntactic structure P (syntactic skeleton) parameterized by a collection of the identifiers V (variable names). This paper introduces the skeletal program enumeration (SPE) problem: Given a fixed syntactic skeleton P and a set of variables V , enumerate a set of programs P exhibiting all possible variable usage patterns within P. It proposes an effective realization of SPE for systematic, rigorous compiler testing by leveraging three important observations: (1) Programs with different variable usage patterns exhibit diverse control- and data-dependence information, and help exploit different compiler optimizations; (2) most real compiler bugs were revealed by small tests (i.e., small-sized P) — this “small-scope” observation opens up SPE for practical compiler validation; and (3) SPE is exhaustive w.r.t. a given syntactic skeleton and variable set, offering a level of guarantee absent from all existing compiler testing techniques.
The key challenge of SPE is how to eliminate the enormous amount of equivalent programs w.r.t. α-conversion. Our main technical contribution is a novel algorithm for computing the canonical (and smallest) set of all non-α-equivalent programs. To demonstrate its practical utility, we have applied the SPE technique to test C/C++ and Scala compilers using syntactic skeletons derived from their own regression test-suites. Our evaluation results are extremely encouraging. In less than six months, our approach has led to 217 confirmed GCC/Clang bug reports, 119 of which have already been fixed, and the majority are long latent bugs despite the extensive prior testing efforts (e.g., Csmith and EMI). The results also show that our algorithm for enumerating non-α-equivalent programs provides six orders of magnitude reduction, enabling processing the GCC test-suite in under a month versus 40K+ years with a na&amp;iuml;ve enumeration. Moreover, in about three weeks, our technique has also found 29 CompCert crashing bugs and 42 bugs in two Scala optimizing compilers. These results demonstrate our SPE technique’s generality and further illustrate its effectiveness.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Qirun</first_name>
          <last_name>Zhang</last_name>
          <affiliation>University of California, Davis</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://helloqirun.github.io/</homepage_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Chengnian</first_name>
          <last_name>Sun</last_name>
          <affiliation>University of California, Davis</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://chengniansun.bitbucket.org/</homepage_url>
          <picture_url>http://pldi17.sigplan.org/getProfileImage/chengniansun/c172ce7d-3932-4fba-979d-8526fa38562d/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Zhendong</first_name>
          <last_name>Su</last_name>
          <affiliation>University of California, Davis</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://web.cs.ucdavis.edu/~su/</homepage_url>
          <picture_url>http://pldi17.sigplan.org/getProfileImage/zhendongsu/6c82320e-8f16-4eb6-b6e1-0957ef6fe25e/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>e5442c55-c4bc-4f10-9107-64f7c8fbc5fa</slot_id>
      <title>Low Overhead Dynamic Binary Translation on ARM</title>
      <room>PLDI-MainTrack-A</room>
      <date>2017/06/19</date>
      <start_time>17:00</start_time>
      <end_time>17:25</end_time>
      <description>The ARMv8 architecture introduced AArch64, a 64-bit execution mode with a new instruction set, while retaining binary compatibility with previous versions of the ARM architecture through AArch32, a 32-bit execution mode. Most hardware implementations of ARMv8 processors support both AArch32 and AArch64, which comes at a cost in hardware complexity.
We present MAMBO-X64, a dynamic binary translator which executes 32-bit ARM binaries using only the AArch64 instruction set. We have evaluated the performance of MAMBO-X64 on three existing ARMv8 processors which support both AArch32 and AArch64 instruction sets. The performance was measured with SPEC CPU2006 and PARSEC by comparing the runtime of 32-bit benchmarks running under MAMBO-X64 with the same benchmark running natively. On both sequential and multi-threaded benchmarks, we achieve a geometric mean overhead of less than 7.5% on Cortex-A53 processors and a performance improvement of 1% on X-Gene processors.
MAMBO-X64 achieves such low overhead by novel optimizations to map AArch32 floating-point registers to AArch64 registers dynamically, generate traces that harness hardware return address prediction, and efficiently handle operating system signals.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Amanieu</first_name>
          <last_name>d'Antras</last_name>
          <affiliation>University of Manchester</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Cosmin</first_name>
          <last_name>Gorgovan</last_name>
          <affiliation>University of Manchester</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Jim</first_name>
          <last_name>Garside</last_name>
          <affiliation>University of Manchester</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Mikel</first_name>
          <last_name>Lujan</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>e799ab52-fcd0-4628-a4d0-35ee18670295</slot_id>
      <title>Achieving High Coverage for Floating-point Code via Unconstrained Programming</title>
      <room>PLDI-MainTrack-A</room>
      <date>2017/06/19</date>
      <start_time>16:10</start_time>
      <end_time>16:35</end_time>
      <description>Achieving high code coverage is essential in testing, which gives us confidence in code quality. Testing floating-point code usually requires painstaking efforts in handling floating-point constraints, e.g., in symbolic execution. This paper turns the challenge of testing floating-point code into the opportunity of applying unconstrained programming – the mathematical solution for calculating function minimum points over the entire search space. Our core insight is to derive a representing function from the floating-point program, whose minimum point is a test input guaranteed to exercise a new branch of the tested program. This guarantee allows us to achieve high coverage of the floating-point program by repeatedly minimizing the representing function.
We have implemented this approach into the tool CoverMe and conducted an extensive evaluation on Sun’s C math library. Our experiment shows that CoverMe can achieve 90.8% of branch coverage in 6.9 seconds on average. This result dramatically outperforms our compared tools: (1) Random testing, (2) AFL, a highly optimized, robust fuzzer released by Google, and (3) Austin, a state-of-the-art coverage-based testing tool designed for supporting floating-point code.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Zhoulai</first_name>
          <last_name>Fu</last_name>
          <affiliation>University of California, Davis</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Zhendong</first_name>
          <last_name>Su</last_name>
          <affiliation>University of California, Davis</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://web.cs.ucdavis.edu/~su/</homepage_url>
          <picture_url>http://pldi17.sigplan.org/getProfileImage/zhendongsu/6c82320e-8f16-4eb6-b6e1-0957ef6fe25e/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>f20e8184-15c0-4fa9-98bc-64f85c0f7a3a</subevent_id>
    <title>Research Papers: Synthesis</title>
    <subevent_type type="regular"/>
    <room>PLDI-MainTrack-A</room>
    <date>2017/06/20</date>
    <url>http://pldi17.sigplan.org/track/pldi-2017-papers</url>
    <url_link_display>Research Papers</url_link_display>
    <tracks>
      <track>Research Papers</track>
    </tracks>
    <timeslot>
      <slot_id>193848d3-5302-4f02-9037-e5376cdf8c1f</slot_id>
      <title>Synthesizing Highly Expressive SQL Queries from Input-Output Examples</title>
      <room>PLDI-MainTrack-A</room>
      <date>2017/06/20</date>
      <start_time>11:40</start_time>
      <end_time>12:05</end_time>
      <description>SQL is the de facto language for manipulating relational data. Though powerful, many users find it difficult to write SQL queries due to highly expressive constructs. While using the programming-by-example paradigm to help users write SQL queries is an attractive proposition, as evidenced by online help forums such as Stack Overflow, developing techniques for synthesizing SQL queries from given input-output (I/O) examples has been difficult, due to the large space of SQL queries as a result of its rich set of operators.
In this paper, we present a new scalable and efficient algorithm for synthesizing SQL queries based on I/O examples. The key innovation of our algorithm is development of a language for abstract queries, i.e., queries with uninstantiated operators, that can be used to express a large space of SQL queries efficiently. Using abstract queries to represent the search space nicely decomposes the synthesis problem into two tasks: 1) searching for abstract queries that can potentially satisfy the given I/O examples, and 2) instantiating the found abstract queries and ranking the results.
We have implemented this algorithm in a new tool called Scythe and evaluated it using 193 benchmarks collected from Stack Overflow. Our evaluation shows that Scythe can efficiently solve 74% of the benchmarks, most in just a few seconds, and the queries range from simple ones involving a single selection to complex queries with 6 nested subqueires.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Chenglong</first_name>
          <last_name>Wang</last_name>
          <affiliation>University of Washington, USA</affiliation>
          <bio>undefined</bio>
          <picture_url>http://pldi17.sigplan.org/getProfileImage/chenglongwang/a5eaa2e6-bcfe-4c30-9032-9baa6b1125f2/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Alvin</first_name>
          <last_name>Cheung</last_name>
          <affiliation>University of Washington</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://homes.cs.washington.edu/~akcheung</homepage_url>
          <picture_url>http://pldi17.sigplan.org/getProfileImage/alvincheung/8a51cd19-a395-45c9-8b2c-b121ff910c62/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Rastislav</first_name>
          <last_name>Bodik</last_name>
          <affiliation>University of Washington</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.berkeley.edu/~bodik</homepage_url>
          <picture_url>http://pldi17.sigplan.org/getProfileImage/rastislavbodik/ae16ae8e-9d00-41c4-9067-0c37da65dde7/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>61c93bf3-2d8b-4f96-b401-165d562a022b</slot_id>
      <title>Synthesizing Memory Models from Framework Sketches and Litmus Tests</title>
      <room>PLDI-MainTrack-A</room>
      <date>2017/06/20</date>
      <start_time>12:05</start_time>
      <end_time>12:30</end_time>
      <description>A memory consistency model specifies which writes to shared memory a given read may see. Ambiguities or errors in these specifications can lead to bugs in both compilers and applications. Yet architectures usually define their memory models with prose and litmus tests—small concurrent programs that demonstrate allowed and forbidden outcomes. Recent work has formalized the memory models of common architectures through substantial manual effort, but as new architectures emerge, there is a growing need for tools to aid these efforts.
This paper presents MemSynth, a synthesis-aided system for reasoning about axiomatic specifications of memory models. MemSynth takes as input a set of litmus tests and a framework sketch that defines a class of memory models. The sketch comprises a set of axioms with missing expressions (or holes). Given these inputs, MemSynth synthesizes a completion of the axioms—i.e., a memory model—that gives the desired outcome on all tests. The MemSynth engine employs a novel embedding of bounded relational logic in a solver-aided programming language, which enables it to tackle complex synthesis queries intractable to existing relational solvers. This design also enables it to solve new kinds of queries, such as checking if a set of litmus tests unambiguously defines a memory model within a framework sketch.
We show that MemSynth can synthesize specifications for x86 in under two seconds, and for PowerPC in 12 seconds from 768 litmus tests. Our ambiguity check identifies missing tests from both the Intel x86 documentation and the validation suite of a previous PowerPC formalization. We also used MemSynth to reproduce, debug, and automatically repair a paper on comparing memory models in just two days.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>James</first_name>
          <last_name>Bornholt</last_name>
          <affiliation>University of Washington</affiliation>
          <bio>I’m a computer science PhD student in the PLSE and Sampa groups at the University of Washington, advised by Emina Torlak, Dan Grossman, and Luis Ceze. I work on programming languages and formal methods, from program synthesis frameworks to consistency models.</bio>
          <homepage_url>https://homes.cs.washington.edu/~bornholt/</homepage_url>
          <picture_url>http://pldi17.sigplan.org/getProfileImage/jamesbornholt/3b627eda-8767-4bbc-b7f3-575ee248dc3e/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Emina</first_name>
          <last_name>Torlak</last_name>
          <affiliation>University of Washington</affiliation>
          <bio>Emina Torlak is an Assistant Professor at the University of Washington, working at the intersection of programming languages, formal methods, and software engineering. She received her Bachelors (2003), Masters (2004), and Ph.D. (2009) degrees from MIT, and subsequently worked at IBM Research, LogicBlox, and as a research scientist at U.C. Berkeley. Her research focuses on developing automated tools and programming models for computer-aided design, verification, and synthesis of software. She is the creator of the Kodkod constraint solver, which has been used in over 70 academic and industrial tools for software engineering. Emina has applied her expertise to a broad range of problems, from verification of memory-consistency models to generation of test data for decision support applications. Her current work on the Rosette solver-aided language integrates constraint solvers into programming languages to support computer-aided verification, debugging, and synthesis of code, making programming a collaboration between humans and machines.</bio>
          <homepage_url>https://homes.cs.washington.edu/~emina/index.html</homepage_url>
          <picture_url>http://pldi17.sigplan.org/getProfileImage/eminatorlak/b48dd8a1-4bf6-4d29-b6e3-fb0e9ea9ce8e/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>9ae8947f-4da5-468b-aee3-4ebe6a56fc2a</slot_id>
      <title>Component-based Synthesis of Table Consolidation and Transformation Tasks from Examples</title>
      <room>PLDI-MainTrack-A</room>
      <date>2017/06/20</date>
      <start_time>10:50</start_time>
      <end_time>11:15</end_time>
      <description>This paper presents an example-driven synthesis technique for automating a large class of data preparation tasks that arise in data science. Given a set of input tables and an out- put table, our approach synthesizes a table transformation program that performs the desired task. Our approach is not restricted to a fixed set of DSL constructs and can synthesize programs from an arbitrary set of components, including higher-order combinators. At a high-level, our approach performs type-directed enumerative search over partial pro- grams but incorporates two key innovations that allow it to scale: First, our technique can utilize any first-order specification of the components and uses SMT-based deduction to reject partial programs. Second, our algorithm uses partial evaluation to increase the power of deduction and drive enumerative search. We have evaluated our synthesis algorithm on dozens of data preparation tasks obtained from on-line forums, and we show that our approach can automatically solve a large class of problems encountered by R users.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Yu</first_name>
          <last_name>Feng</last_name>
          <affiliation>University of Texas at Austin, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.utexas.edu/~yufeng/</homepage_url>
          <picture_url>http://pldi17.sigplan.org/getProfileImage/yufeng/f8c08193-9ace-4355-b7aa-f31152e651bc/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Ruben</first_name>
          <last_name>Martins</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Jacob</first_name>
          <last_name>Van Geffen</last_name>
          <affiliation>UT Austin</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Isil</first_name>
          <last_name>Dillig</last_name>
          <affiliation>UT Austin</affiliation>
          <bio>Isil Dillig is an assistant professor of computer science at UT Austin. She obtained all her degrees (BS, MS, PhD) in computer science from Stanford University. Prior to joining UT Austin, she was a researcher at Microsoft Research and an assistant professor at the College of William &amp;amp; Mary.</bio>
          <homepage_url>http://www.cs.utexas.edu/~isil/</homepage_url>
          <picture_url>http://pldi17.sigplan.org/getProfileImage/isildillig/e4fa3855-0ae4-4638-84e3-1fe224e64e3f/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Swarat</first_name>
          <last_name>Chaudhuri</last_name>
          <affiliation>Rice University</affiliation>
          <bio>Swarat Chaudhuri is an assistant professor of computer science at Rice University. He is an expert on methods for automated reasoning about systems, in particular abstract interpretation and model checking, and the application of such methods in computer-aided programming.
Swarat received a bachelor’s degree in computer science from the Indian Institute of Technology, Kharagpur, in 2001, and a doctoral degree in computer science from the University of Pennsylvania in 2007. From 2008-2011, he was an assistant professor at the Pennsylvania State University, University Park. He is a recipient of the National Science Foundation CAREER award, the ACM SIGPLAN Outstanding Doctoral Dissertation Award, and the Morris and Dorothy Rubinoff Dissertation Award from the University of Pennsylvania.</bio>
          <homepage_url>http://www.cs.rice.edu/~sc40/</homepage_url>
          <picture_url>http://pldi17.sigplan.org/getProfileImage/swaratchaudhuri/380a995e-c23e-4571-9f61-4f948b82c975/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>caeed7ac-6858-4f7d-be4c-ddc7e3aa0d3b</slot_id>
      <title>Network Configuration Synthesis with Abstract Topologies</title>
      <room>PLDI-MainTrack-A</room>
      <date>2017/06/20</date>
      <start_time>11:15</start_time>
      <end_time>11:40</end_time>
      <description>We develop Methane, a system to synthesize provably-correct configurations for large, evolving networks from high-level specifications of topology, routing policy, and fault-tolerance requirements. It is based on new abstractions for capturing parameterized network topologies and their evolution, and algorithms to analyze the impact of topology and routing policy on fault tolerance. Our algorithms operate entirely on abstract topologies and guarantee correctness for all its concrete instantiations. Methane also guarantees that minimal changes to existing device configurations are required when the network evolves to add or remove devices and links. Our experiments with real-world topologies and policies show that our abstractions and algorithms are effective and that, for large networks, Methane synthesizes configurations two orders of magnitude faster than systems that operate over concrete topologies.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Ryan</first_name>
          <last_name>Beckett</last_name>
          <affiliation>Princeton University</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Ratul</first_name>
          <last_name>Mahajan</last_name>
          <affiliation>Microsoft</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Todd</first_name>
          <last_name>Millstein</last_name>
          <affiliation>University of California, Los Angeles</affiliation>
          <bio>I am a Professor in the Computer Science Department at the University of California, Los Angeles (UCLA).
I was the Program Chair for OOPSLA 2014.</bio>
          <homepage_url>http://www.cs.ucla.edu/~todd/</homepage_url>
          <picture_url>http://pldi17.sigplan.org/getProfileImage/toddmillstein/03692d64-e4ad-4fb1-a2b0-9271ce27715c/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Jitendra</first_name>
          <last_name>Padhye</last_name>
          <affiliation>Microsoft</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>David</first_name>
          <last_name>Walker</last_name>
          <affiliation>Princeton University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.princeton.edu/~dpw/</homepage_url>
          <picture_url>http://pldi17.sigplan.org/getProfileImage/davidwalker/8763137a-03a5-4963-8639-e9f2a3cc8ac9/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>0fd0e409-1dd7-4baf-bd4e-c37c3b235a2b</subevent_id>
    <title>Research Papers: 1' pitches of the day and the next day</title>
    <subevent_type type="regular"/>
    <room>PLDI-MainTrack-A</room>
    <date>2017/06/20</date>
    <url>http://pldi17.sigplan.org/track/pldi-2017-papers</url>
    <url_link_display>Research Papers</url_link_display>
    <tracks>
      <track>Research Papers</track>
    </tracks>
    <timeslot>
      <slot_id>d22e1774-ab51-4780-a2f3-92ad24473a57</slot_id>
      <title>1' Pitches of Tuesday and Wednesday</title>
      <room>PLDI-MainTrack-A</room>
      <date>2017/06/20</date>
      <start_time>09:55</start_time>
      <end_time>10:25</end_time>
      <description>undefined</description>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>992f10be-45eb-43cf-afb8-5618a749e6f3</subevent_id>
    <title>Research Papers: Systems and Performance</title>
    <subevent_type type="regular"/>
    <room>PLDI-MainTrack-A</room>
    <date>2017/06/21</date>
    <url>http://pldi17.sigplan.org/track/pldi-2017-papers</url>
    <url_link_display>Research Papers</url_link_display>
    <tracks>
      <track>Research Papers</track>
    </tracks>
    <timeslot>
      <slot_id>1f33349c-69bb-44dd-8dd8-a2402676bf7e</slot_id>
      <title>Responsive Parallel Computation: Bridging Competitive and Cooperative Threading</title>
      <room>PLDI-MainTrack-A</room>
      <date>2017/06/21</date>
      <start_time>11:10</start_time>
      <end_time>11:35</end_time>
      <description>Competitive and cooperative threading are widely used abstractions in computing. In competitive threading, threads are scheduled preemptively with the goal of minimizing response time, usually of interactive applications. In cooperative threading, threads are scheduled non-preemptively with the goal of maximizing throughput or minimizing the completion time, usually in compute-intensive applications, e.g. scientific computing, machine learning and AI.
Although both of these forms of threading rely on the same abstraction of a thread, they have, to date, remained largely separate forms of computing. Motivated by the recent increase in the mainstream use of multicore computers, we propose a threading model that aims to unify competitive and cooperative threading. To this end, we extend the classic graph-based cost model for cooperative threading to allow for competitive threading, and describe how such a cost model may be used in a programming language by presenting a language and a corresponding cost semantics. Finally, we show that the cost model and the semantics are realizable by presenting an operational semantics for the language that specifies the behavior of an implementation, and presenting an implementation and a small empirical evaluation.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Stefan K.</first_name>
          <last_name>Muller</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Umut</first_name>
          <last_name>Acar</last_name>
          <affiliation>Carnegie Mellon University</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Robert</first_name>
          <last_name>Harper</last_name>
          <affiliation>CWI</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.cmu.edu/~rwh/</homepage_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>443b5bba-d19d-4568-ab80-eaf771bf6983</slot_id>
      <title>Practical Partial Evaluation for High-Performance Dynamic Language Runtimes</title>
      <room>PLDI-MainTrack-A</room>
      <date>2017/06/21</date>
      <start_time>10:45</start_time>
      <end_time>11:10</end_time>
      <description>Most high-performance dynamic language virtual machines duplicate language semantics in the interpreter, compiler, and runtime system, violating the principle to not repeat yourself. In contrast, we define languages solely by writing an interpreter. Compiled code is derived automatically using partial evaluation (the first Futamura projection). The interpreter performs specializations, e.g., augments the interpreted program with type information and profiling information. Partial evaluation incorporates these specializations. This makes partial evaluation practical in the context of dynamic languages, because it reduces the size of the compiled code while still compiling in all parts of an operation that are relevant for a particular program. Deoptimization to the interpreter, re-specialization in the interpreter, and recompilation embrace the dynamic nature of languages. We evaluate our approach comparing newly built JavaScript, Ruby, and R runtimes with current specialized production implementations of those languages. Our general purpose compilation system is competitive with production systems even when they have been heavily specialized and optimized for one particular language.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Thomas</first_name>
          <last_name>Wuerthinger</last_name>
          <affiliation>Oracle Labs</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.wuerthinger.net</homepage_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Christian</first_name>
          <last_name>Wimmer</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <picture_url>http://pldi17.sigplan.org/getProfileImage/christianwimmer/cdeb11d2-56bd-4c5e-81a3-fb4c52918c0b/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Christian</first_name>
          <last_name>Humer</last_name>
          <affiliation>Oracle Labs, Switzerland</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Andreas</first_name>
          <last_name>Woess</last_name>
          <affiliation>Oracle Labs</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Lukas</first_name>
          <last_name>Stadler</last_name>
          <affiliation>Oracle Labs, Austria</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://ssw.jku.at/General/Staff/LS/</homepage_url>
          <picture_url>http://pldi17.sigplan.org/getProfileImage/lukasstadler/879dca17-669b-4d6b-b982-d06c8144264b/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Chris</first_name>
          <last_name>Seaton</last_name>
          <affiliation>Oracle Labs</affiliation>
          <bio>Chris Seaton is a Research Manager at the Virtual Machine Group in Oracle Labs, where he leads the work to implement Ruby using the next generation of Java Virtual Machine technology, and other projects.
Before this he completed a PhD at the University of Manchester under the supervision of Doctor Mikel Luj&amp;aacute;n, where he researched programming languages and irregular parallelism. Before that, he completed an MEng at the University of Bristol on languages with mutable syntax and semantics.
In his spare time he used to develop an award winning medical app that is the first app regulated as a medical device in the UK, and ran a consultancy to help clients such as the NHS to develop revolutionary medical software.</bio>
          <homepage_url>http://chrisseaton.com/</homepage_url>
          <picture_url>http://pldi17.sigplan.org/getProfileImage/chrisseaton/ace700bb-530d-472f-9683-f0f036db05ea/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>7</sort_key>
          <first_name>Gilles</first_name>
          <last_name>Duboscq</last_name>
          <affiliation>Oracle Labs</affiliation>
          <bio>undefined</bio>
          <picture_url>http://pldi17.sigplan.org/getProfileImage/gillesduboscq/cfc3738c-9767-42e8-83d6-43eb891c50b9/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>8</sort_key>
          <first_name>Doug</first_name>
          <last_name>Simon</last_name>
          <affiliation>Oracle Labs</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://labs.oracle.com/pls/apex/f?p=labs:bio:0:116</homepage_url>
          <picture_url>http://pldi17.sigplan.org/getProfileImage/dougsimon/0888588a-855c-4357-8ce6-e683fa06391c/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>9</sort_key>
          <first_name>Matthias</first_name>
          <last_name>Grimmer</last_name>
          <affiliation>Oracle Labs, Austria</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.matthiasgrimmer.com</homepage_url>
          <picture_url>http://pldi17.sigplan.org/getProfileImage/matthiasgrimmer/8c9a67ac-2ea5-4914-9110-3d4a80b16ff0/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>6233ad1b-01a5-4060-bfe1-46b476c4da32</slot_id>
      <title>StreamQRE: Modular Specification and Efficient Evaluation of Quantitative Queries over Streaming Data</title>
      <room>PLDI-MainTrack-A</room>
      <date>2017/06/21</date>
      <start_time>11:35</start_time>
      <end_time>12:00</end_time>
      <description>Real-time decision making in emerging IoT applications typically relies on computing quantitative summaries of large data streams in an efficient and incremental manner. To simplify the task of programming the desired logic, we propose StreamQRE that provides natural and high-level constructs for processing streaming data. Our language has a novel integration of linguistic constructs from two distinct programming paradigms: streaming extensions of relational query languages and quantitative extensions of regular expressions. The former allows the programmer to employ relational constructs to partition the input data by keys and to integrate data streams from different sources, while the latter can be used to exploit the logical hierarchy in the input stream for modular specifications.
We first present the core language with a small set of combinators, formal semantics, and a decidable type system. We then show how to express a number of common patterns with illustrative examples. Our compilation algorithm translates the high-level query into a streaming algorithm with precise complexity bounds on per-item processing time and total memory footprint. We also show how to integrate approximation algorithms in our framework. We report on an implementation in Java, and evaluate it with respect to existing high-performance engines for processing streaming data. Our experimental evaluation shows that (1) StreamQRE allows more natural and succinct specification of queries compared to existing frameworks, (2) the throughput of our implementation is higher than comparable systems (for example, two-to-four times greater than RxJava), and (3) the approximation algorithms supported by our implementation can lead to substantial memory savings.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Konstantinos</first_name>
          <last_name>Mamouras</last_name>
          <affiliation>University of Pennsylvania</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Mukund</first_name>
          <last_name>Raghotaman</last_name>
          <affiliation>University of Pennsylvania</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.cis.upenn.edu/~rmukund/</homepage_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Rajeev</first_name>
          <last_name>Alur</last_name>
          <affiliation>University of Pennsylvania</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Zachary G.</first_name>
          <last_name>Ives</last_name>
          <affiliation>University of Pennsylvania</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Sanjeev</first_name>
          <last_name>Khanna</last_name>
          <affiliation>University of Pennsylvania</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>d01ed812-4be7-4e61-94bf-6460c39a3eae</slot_id>
      <title>Low-Synchronization, Mostly Lock-Free, Elastic Scheduling for Streaming Runtimes</title>
      <room>PLDI-MainTrack-A</room>
      <date>2017/06/21</date>
      <start_time>10:20</start_time>
      <end_time>10:45</end_time>
      <description>We present the scalable, elastic operator scheduler in IBM Streams 4.2. Streams is a distributed stream processing system used in production at many companies in a wide range of industries. The programming language for Streams, SPL, presents operators, tuples and streams as the primary abstractions. A fundamental SPL optimization is operator fusion, where multiple operators execute together in the same process. Streams 4.2 automatically performs fusion at submission time, because we discovered that in practice, customers did not have the expertise to do so. However, this presented a new problem: potentially thousands of operators would execute together in the same process, with no user guidance for thread placement. We needed a way to automatically figure out how many threads to use, with arbitrarily sized applications on a wide variety of hardware, and without any input from programmers. Our solution has two components. The first is a scalable operator scheduler that minimizes synchronization, locks and global data, while allowing threads to execute any operator and dynamically come and go. The second are elastic algorithms to dynamically adjust the number of threads to optimize performance, using the principles of trust and establishing trends. We demonstrate our scheduler’s ability to scale to over a hundreds threads, and our elasticity algorithm’s ability to adapt to diferent workloads on an Intel Xeon system with 176 logical cores, and an IBM Power8 system with 184 logical cores.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Scott</first_name>
          <last_name>Schneider</last_name>
          <affiliation>IBM Research</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Kun-Lung</first_name>
          <last_name>Wu</last_name>
          <affiliation>IBM Research</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>60fb2844-2791-428a-84cf-1b4efc82c42e</subevent_id>
    <title>Research Papers: 1' pitches of the day</title>
    <subevent_type type="regular"/>
    <room>PLDI-MainTrack-A</room>
    <date>2017/06/19</date>
    <url>http://pldi17.sigplan.org/track/pldi-2017-papers</url>
    <url_link_display>Research Papers</url_link_display>
    <tracks>
      <track>Research Papers</track>
    </tracks>
    <timeslot>
      <slot_id>5b019775-f84d-4b65-87e7-f0df7984d7b7</slot_id>
      <title>1' Pitches of Monday</title>
      <room>PLDI-MainTrack-A</room>
      <date>2017/06/19</date>
      <start_time>10:00</start_time>
      <end_time>10:30</end_time>
      <description>undefined</description>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>809050d2-c9c6-4949-878c-30e846a20a9c</subevent_id>
    <title>Research Papers: Correctness</title>
    <subevent_type type="regular"/>
    <room>PLDI-MainTrack-A</room>
    <date>2017/06/20</date>
    <url>http://pldi17.sigplan.org/track/pldi-2017-papers</url>
    <url_link_display>Research Papers</url_link_display>
    <tracks>
      <track>Research Papers</track>
    </tracks>
    <timeslot>
      <slot_id>97979193-6c4a-4150-a1ab-ecc23d32c6ef</slot_id>
      <title>Taming Undefined Behavior in LLVM</title>
      <room>PLDI-MainTrack-A</room>
      <date>2017/06/20</date>
      <start_time>16:35</start_time>
      <end_time>17:00</end_time>
      <description>A central concern for an optimizing compiler is the design of its intermediate representation (IR) for code. The IR should make it easy to perform transformations, and should also afford efficient and precise static analysis.
In this paper we study an aspect of IR design that has received little attention: the role of undefined behavior. The IR for every optimizing compiler we have looked at, including GCC, LLVM, Intel’s, and Microsoft’s, supports one or more forms of undefined behavior (UB), not only to reflect the semantics of UB-heavy programming languages such as C and C++, but also to model inherently unsafe low-level operations such as memory stores and to avoid over-constraining IR semantics to the point that desirable transformations become illegal. The current semantics of LLVM’s IR fails to justify some cases of loop unswitching, global value numbering, and other important ``textbook’’ optimizations, causing long-standing bugs.
We present solutions to the problems we have identified in LLVM’s IR and show that most optimizations currently in LLVM remain sound, and that some desirable new transformations become permissible. Our solutions do not degrade compile time or performance of generated code.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Juneyoung</first_name>
          <last_name>Lee</last_name>
          <affiliation>Seoul National University</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Yoonseung</first_name>
          <last_name>Kim</last_name>
          <affiliation>Seoul National University (South Korea)</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Youngju</first_name>
          <last_name>Song</last_name>
          <affiliation>Seoul National University</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Chung-Kil</first_name>
          <last_name>Hur</last_name>
          <affiliation>Seoul National University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://sf.snu.ac.kr/gil.hur</homepage_url>
          <picture_url>http://pldi17.sigplan.org/getProfileImage/chungkilhur/7a210194-94f1-448e-8461-5b4b54b43558/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Sanjoy</first_name>
          <last_name>Das</last_name>
          <affiliation>Azul Systems</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>David</first_name>
          <last_name>Majnemer</last_name>
          <affiliation>Google</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>7</sort_key>
          <first_name>John</first_name>
          <last_name>Regehr</last_name>
          <affiliation>University of Utah</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.utah.edu/~regehr/</homepage_url>
          <picture_url>http://pldi17.sigplan.org/getProfileImage/johnregehr/2cb23ab0-042a-487a-a859-cbd3147a46a7/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>8</sort_key>
          <first_name>Nuno P.</first_name>
          <last_name>Lopes</last_name>
          <affiliation>Microsoft Research</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://web.ist.utl.pt/nuno.lopes/</homepage_url>
          <picture_url>http://pldi17.sigplan.org/getProfileImage/nunoplopes/51903af2-1afa-498e-95d4-72829128f32c/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>e9cd54e2-5ec5-4fcf-817c-3f9d8a1a9f83</slot_id>
      <title>Repairing Sequential Consistency in C/C++11</title>
      <room>PLDI-MainTrack-A</room>
      <date>2017/06/20</date>
      <start_time>16:10</start_time>
      <end_time>16:35</end_time>
      <description>The C/C++11 memory model defines the semantics of concurrent memory accesses in C/C++, and in particular supports racy “atomic” accesses at a range of different consistency levels, from very weak consistency (“relaxed”) to strong, sequential consistency (“SC”). Unfortunately, as we observe in this paper, the semantics of SC atomic accesses in C/C++11, as well as in all proposed strengthenings of the semantics, is flawed, in that both suggested compilation schemes to Power are unsound. We propose a better semantics for SC accesses that restores the soundness of the compilation schemes to Power, maintains the DRF-SC guarantee, and provides stronger, more useful, guarantees to SC fences. In addition, we formally prove, for the first time, the correctness of the proposed stronger compilation schemes to Power that preserve load-to-store ordering and avoid “thin-air” reads.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Ori</first_name>
          <last_name>Lahav</last_name>
          <affiliation>MPI-SWS</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Viktor</first_name>
          <last_name>Vafeiadis</last_name>
          <affiliation>MPI-SWS, Germany</affiliation>
          <bio>Viktor Vafeiadis is a tenured faculty at the Max Planck Institute for Software Systems (MPI-SWS) in Germany. He got his BA and PhD from the University of Cambridge, and held post-doctoral researcher positions at the University of Cambridge and at Microsoft Research Cambridge before joining MPI-SWS in October 2010.</bio>
          <homepage_url>http://www.mpi-sws.org/~viktor/</homepage_url>
          <picture_url>http://pldi17.sigplan.org/getProfileImage/viktorvafeiadis/6a063832-47ca-4c32-8047-4bf4f74ae764/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Jeehoon</first_name>
          <last_name>Kang</last_name>
          <affiliation>Seoul National University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://sf.snu.ac.kr/jeehoon.kang</homepage_url>
          <picture_url>http://pldi17.sigplan.org/getProfileImage/jeehoonkang/764640a7-91ed-4d37-9f02-a32e54ea94cb/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Chung-Kil</first_name>
          <last_name>Hur</last_name>
          <affiliation>Seoul National University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://sf.snu.ac.kr/gil.hur</homepage_url>
          <picture_url>http://pldi17.sigplan.org/getProfileImage/chungkilhur/7a210194-94f1-448e-8461-5b4b54b43558/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Derek</first_name>
          <last_name>Dreyer</last_name>
          <affiliation>MPI-SWS</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.mpi-sws.org/~dreyer</homepage_url>
          <picture_url>http://pldi17.sigplan.org/getProfileImage/derekdreyer/c2afb333-bc78-499d-92b7-c31938b9e567/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>62bf68b7-e739-4664-bce5-9dabe4bd121c</subevent_id>
    <title>Research Papers: Awards</title>
    <subevent_type type="regular"/>
    <room>PLDI-MainTrack-A</room>
    <date>2017/06/21</date>
    <url>http://pldi17.sigplan.org/track/pldi-2017-papers</url>
    <url_link_display>Research Papers</url_link_display>
    <tracks>
      <track>Research Papers</track>
    </tracks>
    <timeslot>
      <slot_id>4c90d5f3-a720-4178-a295-132fd0952a3c</slot_id>
      <title>Closing</title>
      <room>PLDI-MainTrack-A</room>
      <date>2017/06/21</date>
      <start_time>12:15</start_time>
      <end_time>12:30</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Albert</first_name>
          <last_name>Cohen</last_name>
          <affiliation>INRIA</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://who.rocq.inria.fr/Albert.Cohen</homepage_url>
          <picture_url>http://pldi17.sigplan.org/getProfileImage/albertcohen/274c10d0-dc94-46c6-bde3-4077f30e13d8/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>ce211ef8-372c-4de8-9ee5-6337a5bff526</slot_id>
      <title>Best Paper, Artifact Evaluation, SIGPLAN Test of Time Awards</title>
      <room>PLDI-MainTrack-A</room>
      <date>2017/06/21</date>
      <start_time>12:00</start_time>
      <end_time>12:15</end_time>
      <description>undefined</description>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>7ad247f7-6362-41ee-bf5c-f952cd4824ae</subevent_id>
    <title>Research Papers: Static Analysis and Security</title>
    <subevent_type type="regular"/>
    <room>PLDI-MainTrack-B</room>
    <date>2017/06/20</date>
    <url>http://pldi17.sigplan.org/track/pldi-2017-papers</url>
    <url_link_display>Research Papers</url_link_display>
    <tracks>
      <track>Research Papers</track>
    </tracks>
    <timeslot>
      <slot_id>9dd864f7-0b1c-4747-b7ea-ccf15819fc2e</slot_id>
      <title>Rigorous Analysis of Software Countermeasures against Cache Attacks</title>
      <room>PLDI-MainTrack-B</room>
      <date>2017/06/20</date>
      <start_time>12:05</start_time>
      <end_time>12:30</end_time>
      <description>CPU caches introduce variations into the execution time of programs that can be exploited by adversaries to recover private information about users or cryptographic keys.
Establishing the security of countermeasures against this threat often requires intricate reasoning about the interactions of program code, memory layout, and hardware architecture and has so far only been done for restricted cases.
In this paper we devise novel techniques that provide support for bit-level and arithmetic reasoning about memory accesses in the presence of dynamic memory allocation. These techniques enable us to perform the first rigorous analysis of widely deployed software countermeasures against cache attacks on modular exponentiation, based on executable code.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Goran</first_name>
          <last_name>Doychev</last_name>
          <affiliation>IMDEA Software Institute</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Boris</first_name>
          <last_name>Köpf</last_name>
          <affiliation>IMDEA Software Institute, Spain</affiliation>
          <bio>Boris is an associate research professor at the IMDEA Software Institute. His research focuses on the foundations of computer security. In particular, he is interested in quantitative notions of security, and in techniques for computing corresponding guarantees for real systems. He applies his research to the analysis of side-channel attacks (and countermeasures) and to privacy-preserving data publishing.</bio>
          <homepage_url>http://software.imdea.org/~bkoepf/</homepage_url>
          <picture_url>http://pldi17.sigplan.org/getProfileImage/boriskopf/89c8031b-6f98-4f60-8589-c5ca4f3482df/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>ab99fc24-b931-4393-bef2-97bc22fad962</slot_id>
      <title>Control-Flow Recovery from Partial Failure Reports</title>
      <room>PLDI-MainTrack-B</room>
      <date>2017/06/20</date>
      <start_time>11:40</start_time>
      <end_time>12:05</end_time>
      <description>Debugging is difficult. When software fails in production, debugging is even harder, as failure reports usually provide only an incomplete picture of the failing execution. We present a system that answers control-flow queries posed by developers as formal languages, indicating whether the query expresses control flow that is possible or impossible for a given failure report. We consider three separate approaches that trade off precision, expressiveness for failure constraints, and scalability. We also introduce a new subclass of regular languages, the unreliable trace languages, which are particularly suited to answering control-flow queries in polynomial time. Our system answers queries remarkably efficiently when we encode failure constraints and user queries entirely as unreliable trace languages.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Peter</first_name>
          <last_name>Ohmann</last_name>
          <affiliation>University of Wisconsin - Madison</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://pages.cs.wisc.edu/~ohmann/</homepage_url>
          <picture_url>http://pldi17.sigplan.org/getProfileImage/peterohmann/ec29f252-ae53-4a8a-bfaa-ceac1f487c31/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Alexander L.</first_name>
          <last_name>Brooks</last_name>
          <affiliation>University of Wisconsin, Madison</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Loris</first_name>
          <last_name>D'Antoni</last_name>
          <affiliation>University of Wisconsin–Madison</affiliation>
          <bio>I am an assistant professor at the University of Wisconsin, Madison.</bio>
          <homepage_url>http://pages.cs.wisc.edu/~loris/</homepage_url>
          <picture_url>http://pldi17.sigplan.org/getProfileImage/lorisdantoni/d7a98480-3216-4462-bccf-177e68f71cd8/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Ben</first_name>
          <last_name>Liblit</last_name>
          <affiliation>University of Wisconsin–Madison</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://pages.cs.wisc.edu/~liblit/</homepage_url>
          <picture_url>http://pldi17.sigplan.org/getProfileImage/benliblit/9d2b43b2-f312-47d7-8337-f97fd0597591/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>b7cccec2-c3e5-48aa-a5c2-5238bc5d50d9</slot_id>
      <title>Automatic Program Inversion using Symbolic Transducers</title>
      <room>PLDI-MainTrack-B</room>
      <date>2017/06/20</date>
      <start_time>11:15</start_time>
      <end_time>11:40</end_time>
      <description>We propose a fully-automated technique for inverting functional programs that operate over lists such as string encoders and decoders. We consider programs that can be modeled using symbolic extended finite transducers (\SEFTs), an expressive model that can describe complex list-manipulating programs while retaining several decidable properties. Concretely, given a program $P$ expressed as an \SEFT, we propose techniques for: 1) checking whether $P$ is injective and, if that is the case, 2) building an \SEFT $P^{-1}$ describing its inverse. We first show that it is undecidable to check whether an \SEFT is injective and propose an algorithm for checking injectivity for a restricted, but a practical class of \SEFTs. We then propose an algorithm for inverting \SEFTs based on the following idea: if an \SEFT is injective, inverting it amounts to inverting all its individual transitions. We leverage recent advances program synthesis and show that the transition inversion problem can be expressed as an instance of the syntax-guided synthesis framework. Finally, we implement the proposed techniques in a tool called \genic and show that \genic can invert 13 out 14 real complex string encoders and decoders, producing inverse programs that are substantially identical to manually written ones.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Qinheping</first_name>
          <last_name>Hu</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Loris</first_name>
          <last_name>D'Antoni</last_name>
          <affiliation>University of Wisconsin–Madison</affiliation>
          <bio>I am an assistant professor at the University of Wisconsin, Madison.</bio>
          <homepage_url>http://pages.cs.wisc.edu/~loris/</homepage_url>
          <picture_url>http://pldi17.sigplan.org/getProfileImage/lorisdantoni/d7a98480-3216-4462-bccf-177e68f71cd8/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>c9e9e927-00d6-4d2c-9ff2-562024a6add5</slot_id>
      <title> Decomposition Instead of Self-Composition for Proving the Absence of Timing Channels</title>
      <room>PLDI-MainTrack-B</room>
      <date>2017/06/20</date>
      <start_time>10:50</start_time>
      <end_time>11:15</end_time>
      <description>We describe a novel technique for proving $k$-safety properties (non-interference, determinism, etc.) via a decomposition that enables one to leverage non-relational reasoning techniques. The key is the inter-operation of the following principles. First, we observe that many $k$-safety properties of interest have a particular structure that we call $\psi$\emph{-quotient partitionability} where $\psi$ is a $k$-ary formula. Second, we develop a partitioning strategy of execution traces based on the $k$-safety property $\Phi$ of interest such that if $\psi$ holds for $k$ traces then they must be in the same partition. Finally, within a partition component $T_i$, we observe that we can prove $k$-safety by instead proving a universal property: all traces within the partition satisfy some common property $P_i$, chosen to be strong enough that it implies the $k$-safety property $\Phi$ of any $k$-tuple of traces in components $T_i$.
We apply this strategy to the task of discovering timing side channels. A key feature of our approach is a demand-driven partitioning strategy that uses high/low-annotated regex-like \emph{trails} to reason about one partition component of execution traces at a time. We have applied our technique in a prototype implementation tool called {\sc Blazer}, based on WALA, PPL, Z3, and the brics automaton library. We have proved non-interference of (or synthesized an attack specification for) 25 programs written in Java bytecode, including 7 classic examples from the literature, and 6 examples extracted from the DARPA STAC challenge problems.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Timos</first_name>
          <last_name>Antonopoulos</last_name>
          <affiliation>Yale University</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Paul</first_name>
          <last_name>Gazzillo</last_name>
          <affiliation>Yale University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://paulgazzillo.com</homepage_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Michael</first_name>
          <last_name>Hicks</last_name>
          <affiliation>University of Maryland, College Park</affiliation>
          <bio>Michael Hicks is a Professor in the Computer Science department and UMIACS at the University of Maryland, where he co-directs the laboratory for Programming Languages research (PLUM); he is the former Director of the Maryland Cybersecurity Center (MC2). 
His research focuses on using programming languages and analyses to improve the security, reliability, and availability of software. He is perhaps best known for his work exploring dynamic software updating, which is a technique by which software can be updated without shutting it down. He has explored the design of new programming languages and analysis tools for helping programmers find bugs and software vulnerabilities, and for identifying suspicious or incorrect program executions. 
His recent work has combined ideas from PL and cryptography, e.g., to ensure privacy preserving computations. He also leads the development of a new security-oriented programming contest, “build-it, break-it, fix-it,” which has been offered to the public and to students in his Coursera class on software security. He is the co-editor of the Programming Languages Enthusiast blog and Tweets at @michael_w_hicks.</bio>
          <homepage_url>http://www.cs.umd.edu/~mwh/</homepage_url>
          <picture_url>http://pldi17.sigplan.org/getProfileImage/michaelhicks/aa64e3c6-3516-4e13-affe-77bc32c40565/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Eric</first_name>
          <last_name>Koskinen</last_name>
          <affiliation>Yale University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.yale.edu/homes/ejk/</homepage_url>
          <picture_url>http://pldi17.sigplan.org/getProfileImage/erickoskinen/3413fc94-5f0f-4855-af65-da2309d2632f/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Tachio</first_name>
          <last_name>Terauchi</last_name>
          <affiliation>JAIST</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Shiyi</first_name>
          <last_name>Wei</last_name>
          <affiliation>University of Maryland, College Park</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://people.cs.vt.edu/wei/</homepage_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
  </subevent>
</event>
